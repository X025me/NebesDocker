{"ast":null,"code":"// mixin implementing the buildIdealTree method\nconst rpj = require('read-package-json-fast');\n\nconst npa = require('npm-package-arg');\n\nconst pacote = require('pacote');\n\nconst cacache = require('cacache');\n\nconst semver = require('semver');\n\nconst promiseCallLimit = require('promise-call-limit');\n\nconst getPeerSet = require('../peer-set.js');\n\nconst realpath = require('../../lib/realpath.js');\n\nconst {\n  resolve,\n  dirname\n} = require('path');\n\nconst {\n  promisify\n} = require('util');\n\nconst treeCheck = require('../tree-check.js');\n\nconst readdir = promisify(require('readdir-scoped-modules'));\n\nconst debug = require('../debug.js');\n\nconst fromPath = require('../from-path.js');\n\nconst calcDepFlags = require('../calc-dep-flags.js');\n\nconst Shrinkwrap = require('../shrinkwrap.js');\n\nconst Node = require('../node.js');\n\nconst Link = require('../link.js');\n\nconst addRmPkgDeps = require('../add-rm-pkg-deps.js');\n\nconst gatherDepSet = require('../gather-dep-set.js');\n\nconst optionalSet = require('../optional-set.js');\n\nconst {\n  checkEngine,\n  checkPlatform\n} = require('npm-install-checks'); // enum of return values for canPlaceDep.\n// No, this is a conflict, you may not put that package here\n\n\nconst CONFLICT = Symbol('CONFLICT'); // Yes, this is fine, and should not be a problem\n\nconst OK = Symbol('OK'); // No need, because the package already here is fine\n\nconst KEEP = Symbol('KEEP'); // Yes, clobber the package that is already here\n\nconst REPLACE = Symbol('REPLACE');\n\nconst relpath = require('../relpath.js'); // note: some of these symbols are shared so we can hit\n// them with unit tests and reuse them across mixins\n\n\nconst _complete = Symbol('complete');\n\nconst _depsSeen = Symbol('depsSeen');\n\nconst _depsQueue = Symbol('depsQueue');\n\nconst _currentDep = Symbol('currentDep');\n\nconst _updateAll = Symbol('updateAll');\n\nconst _mutateTree = Symbol('mutateTree');\n\nconst _flagsSuspect = Symbol.for('flagsSuspect');\n\nconst _workspaces = Symbol.for('workspaces');\n\nconst _prune = Symbol('prune');\n\nconst _preferDedupe = Symbol('preferDedupe');\n\nconst _pruneDedupable = Symbol('pruneDedupable');\n\nconst _legacyBundling = Symbol('legacyBundling');\n\nconst _parseSettings = Symbol('parseSettings');\n\nconst _initTree = Symbol('initTree');\n\nconst _applyUserRequests = Symbol('applyUserRequests');\n\nconst _applyUserRequestsToNode = Symbol('applyUserRequestsToNode');\n\nconst _inflateAncientLockfile = Symbol('inflateAncientLockfile');\n\nconst _buildDeps = Symbol('buildDeps');\n\nconst _buildDepStep = Symbol('buildDepStep');\n\nconst _nodeFromEdge = Symbol('nodeFromEdge');\n\nconst _nodeFromSpec = Symbol('nodeFromSpec');\n\nconst _fetchManifest = Symbol('fetchManifest');\n\nconst _problemEdges = Symbol('problemEdges');\n\nconst _manifests = Symbol('manifests');\n\nconst _loadWorkspaces = Symbol.for('loadWorkspaces');\n\nconst _linkFromSpec = Symbol('linkFromSpec');\n\nconst _loadPeerSet = Symbol('loadPeerSet');\n\nconst _updateNames = Symbol.for('updateNames');\n\nconst _placeDep = Symbol.for('placeDep');\n\nconst _canPlaceDep = Symbol.for('canPlaceDep');\n\nconst _canPlacePeers = Symbol('canPlacePeers');\n\nconst _pruneForReplacement = Symbol('pruneForReplacement');\n\nconst _fixDepFlags = Symbol('fixDepFlags');\n\nconst _resolveLinks = Symbol('resolveLinks');\n\nconst _rootNodeFromPackage = Symbol('rootNodeFromPackage');\n\nconst _add = Symbol('add');\n\nconst _resolvedAdd = Symbol.for('resolvedAdd');\n\nconst _queueNamedUpdates = Symbol('queueNamedUpdates');\n\nconst _queueVulnDependents = Symbol('queueVulnDependents');\n\nconst _avoidRange = Symbol('avoidRange');\n\nconst _shouldUpdateNode = Symbol('shouldUpdateNode');\n\nconst resetDepFlags = require('../reset-dep-flags.js');\n\nconst _loadFailures = Symbol('loadFailures');\n\nconst _pruneFailedOptional = Symbol('pruneFailedOptional');\n\nconst _linkNodes = Symbol('linkNodes');\n\nconst _follow = Symbol('follow');\n\nconst _globalStyle = Symbol('globalStyle');\n\nconst _globalRootNode = Symbol('globalRootNode');\n\nconst _isVulnerable = Symbol.for('isVulnerable');\n\nconst _usePackageLock = Symbol.for('usePackageLock');\n\nconst _rpcache = Symbol.for('realpathCache');\n\nconst _stcache = Symbol.for('statCache');\n\nconst _updateFilePath = Symbol('updateFilePath');\n\nconst _followSymlinkPath = Symbol('followSymlinkPath');\n\nconst _getRelpathSpec = Symbol('getRelpathSpec');\n\nconst _retrieveSpecName = Symbol('retrieveSpecName');\n\nconst _strictPeerDeps = Symbol('strictPeerDeps');\n\nconst _checkEngineAndPlatform = Symbol('checkEngineAndPlatform');\n\nconst _checkEngine = Symbol('checkEngine');\n\nconst _checkPlatform = Symbol('checkPlatform');\n\nconst _virtualRoots = Symbol('virtualRoots');\n\nconst _virtualRoot = Symbol('virtualRoot'); // used for the ERESOLVE error to show the last peer conflict encountered\n\n\nconst _peerConflict = Symbol('peerConflict');\n\nconst _failPeerConflict = Symbol('failPeerConflict');\n\nconst _explainPeerConflict = Symbol('explainPeerConflict');\n\nconst _warnPeerConflict = Symbol('warnPeerConflict');\n\nconst _edgesOverridden = Symbol('edgesOverridden'); // exposed symbol for unit testing the placeDep method directly\n\n\nconst _peerSetSource = Symbol.for('peerSetSource'); // used by Reify mixin\n\n\nconst _force = Symbol.for('force');\n\nconst _explicitRequests = Symbol('explicitRequests');\n\nconst _global = Symbol.for('global');\n\nconst _idealTreePrune = Symbol.for('idealTreePrune');\n\nmodule.exports = cls => class IdealTreeBuilder extends cls {\n  constructor(options) {\n    super(options); // normalize trailing slash\n\n    const registry = options.registry || 'https://registry.npmjs.org';\n    options.registry = this.registry = registry.replace(/\\/+$/, '') + '/';\n    const {\n      idealTree = null,\n      global = false,\n      follow = false,\n      globalStyle = false,\n      legacyPeerDeps = false,\n      force = false,\n      packageLock = true,\n      strictPeerDeps = false,\n      workspaces = []\n    } = options;\n    this[_workspaces] = workspaces || [];\n    this[_force] = !!force;\n    this[_strictPeerDeps] = !!strictPeerDeps;\n    this.idealTree = idealTree;\n    this.legacyPeerDeps = legacyPeerDeps;\n    this[_usePackageLock] = packageLock;\n    this[_global] = !!global;\n    this[_globalStyle] = this[_global] || globalStyle;\n    this[_follow] = !!follow;\n    if (this[_workspaces].length && this[_global]) throw new Error('Cannot operate on workspaces in global mode');\n    this[_explicitRequests] = new Set();\n    this[_preferDedupe] = false;\n    this[_legacyBundling] = false;\n    this[_depsSeen] = new Set();\n    this[_depsQueue] = [];\n    this[_currentDep] = null;\n    this[_updateNames] = [];\n    this[_updateAll] = false;\n    this[_mutateTree] = false;\n    this[_loadFailures] = new Set();\n    this[_linkNodes] = new Set();\n    this[_manifests] = new Map();\n    this[_peerConflict] = null;\n    this[_edgesOverridden] = new Set();\n    this[_resolvedAdd] = []; // a map of each module in a peer set to the thing that depended on\n    // that set of peers in the first place.  Use a WeakMap so that we\n    // don't hold onto references for nodes that are garbage collected.\n\n    this[_peerSetSource] = new WeakMap();\n    this[_virtualRoots] = new Map();\n  }\n\n  get explicitRequests() {\n    return new Set(this[_explicitRequests]);\n  } // public method\n\n\n  async buildIdealTree(options = {}) {\n    if (this.idealTree) return Promise.resolve(this.idealTree); // allow the user to set reify options on the ctor as well.\n    // XXX: deprecate separate reify() options object.\n\n    options = { ...this.options,\n      ...options\n    }; // an empty array or any falsey value is the same as null\n\n    if (!options.add || options.add.length === 0) options.add = null;\n    if (!options.rm || options.rm.length === 0) options.rm = null;\n    process.emit('time', 'idealTree');\n\n    if (!options.add && !options.rm && !options.update && this[_global]) {\n      const er = new Error('global requires add, rm, or update option');\n      return Promise.reject(er);\n    } // first get the virtual tree, if possible.  If there's a lockfile, then\n    // that defines the ideal tree, unless the root package.json is not\n    // satisfied by what the ideal tree provides.\n    // from there, we start adding nodes to it to satisfy the deps requested\n    // by the package.json in the root.\n\n\n    this[_parseSettings](options); // start tracker block\n\n\n    this.addTracker('idealTree');\n\n    try {\n      await this[_initTree]();\n      await this[_inflateAncientLockfile]();\n      await this[_applyUserRequests](options);\n      await this[_buildDeps]();\n      await this[_fixDepFlags]();\n      await this[_pruneFailedOptional]();\n      await this[_checkEngineAndPlatform]();\n    } finally {\n      process.emit('timeEnd', 'idealTree');\n      this.finishTracker('idealTree');\n    }\n\n    return treeCheck(this.idealTree);\n  }\n\n  [_checkEngineAndPlatform]() {\n    // engine/platform checks throw, so start the promise chain off first\n    return Promise.resolve().then(() => {\n      for (const node of this.idealTree.inventory.values()) {\n        if (!node.optional) {\n          this[_checkEngine](node);\n\n          this[_checkPlatform](node);\n        }\n      }\n    });\n  }\n\n  [_checkPlatform](node) {\n    checkPlatform(node.package, this[_force]);\n  }\n\n  [_checkEngine](node) {\n    const {\n      engineStrict,\n      npmVersion,\n      nodeVersion\n    } = this.options;\n\n    const c = () => checkEngine(node.package, npmVersion, nodeVersion, this[_force]);\n\n    if (engineStrict) c();else {\n      try {\n        c();\n      } catch (er) {\n        this.log.warn(er.code, er.message, {\n          package: er.pkgid,\n          required: er.required,\n          current: er.current\n        });\n      }\n    }\n  }\n\n  [_parseSettings](options) {\n    const update = options.update === true ? {\n      all: true\n    } : Array.isArray(options.update) ? {\n      names: options.update\n    } : options.update || {};\n    if (update.all || !Array.isArray(update.names)) update.names = [];\n    this[_complete] = !!options.complete;\n    this[_preferDedupe] = !!options.preferDedupe;\n    this[_legacyBundling] = !!options.legacyBundling;\n    this[_updateNames] = update.names;\n    this[_updateAll] = update.all; // we prune by default unless explicitly set to boolean false\n\n    this[_prune] = options.prune !== false; // set if we add anything, but also set here if we know we'll make\n    // changes and thus have to maybe prune later.\n\n    this[_mutateTree] = !!(options.add || options.rm || update.all || update.names.length);\n  } // load the initial tree, either the virtualTree from a shrinkwrap,\n  // or just the root node from a package.json\n\n\n  [_initTree]() {\n    process.emit('time', 'idealTree:init');\n    return (this[_global] ? this[_globalRootNode]() : rpj(this.path + '/package.json').then(pkg => this[_rootNodeFromPackage](pkg), er => {\n      if (er.code === 'EJSONPARSE') throw er;\n      return this[_rootNodeFromPackage]({});\n    })).then(root => this[_loadWorkspaces](root)) // ok to not have a virtual tree.  probably initial install.\n    // When updating all, we load the shrinkwrap, but don't bother\n    // to build out the full virtual tree from it, since we'll be\n    // reconstructing it anyway.\n    .then(root => this[_global] ? root : !this[_usePackageLock] || this[_updateAll] ? Shrinkwrap.reset({\n      path: this.path\n    }).then(meta => Object.assign(root, {\n      meta\n    })) : this.loadVirtual({\n      root\n    })) // if we don't have a lockfile to go from, then start with the\n    // actual tree, so we only make the minimum required changes.\n    // don't do this for global installs or updates, because in those\n    // cases we don't use a lockfile anyway.\n    // Load on a new Arborist object, so the Nodes aren't the same,\n    // or else it'll get super confusing when we change them!\n    .then(async root => {\n      if (!this[_updateAll] && !this[_global] && !root.meta.loadedFromDisk) {\n        await new this.constructor(this.options).loadActual({\n          root\n        });\n        const tree = root.target; // even though we didn't load it from a package-lock.json FILE,\n        // we still loaded it \"from disk\", meaning we have to reset\n        // dep flags before assuming that any mutations were reflected.\n\n        if (tree.children.size) root.meta.loadedFromDisk = true;\n      }\n\n      return root;\n    }).then(tree => {\n      // null the virtual tree, because we're about to hack away at it\n      // if you want another one, load another copy.\n      this.idealTree = tree;\n      this.virtualTree = null;\n      process.emit('timeEnd', 'idealTree:init');\n    });\n  }\n\n  async [_globalRootNode]() {\n    const root = await this[_rootNodeFromPackage]({\n      dependencies: {}\n    }); // this is a gross kludge to handle the fact that we don't save\n    // metadata on the root node in global installs, because the \"root\"\n    // node is something like /usr/local/lib.\n\n    const meta = new Shrinkwrap({\n      path: this.path\n    });\n    meta.reset();\n    root.meta = meta;\n    return root;\n  }\n\n  async [_rootNodeFromPackage](pkg) {\n    // if the path doesn't exist, then we explode at this point. Note that\n    // this is not a problem for reify(), since it creates the root path\n    // before ever loading trees.\n    // TODO: make buildIdealTree() and loadActual handle a missing root path,\n    // or a symlink to a missing target, and let reify() create it as needed.\n    const real = await realpath(this.path, this[_rpcache], this[_stcache]);\n    const Cls = real === this.path ? Node : Link;\n    const root = new Cls({\n      path: this.path,\n      realpath: real,\n      pkg,\n      extraneous: false,\n      dev: false,\n      devOptional: false,\n      peer: false,\n      optional: false,\n      global: this[_global],\n      legacyPeerDeps: this.legacyPeerDeps\n    });\n\n    if (root.isLink) {\n      root.target = new Node({\n        path: real,\n        realpath: real,\n        pkg,\n        extraneous: false,\n        dev: false,\n        devOptional: false,\n        peer: false,\n        optional: false,\n        global: this[_global],\n        legacyPeerDeps: this.legacyPeerDeps,\n        root\n      });\n    }\n\n    return root;\n  } // process the add/rm requests by modifying the root node, and the\n  // update.names request by queueing nodes dependent on those named.\n\n\n  async [_applyUserRequests](options) {\n    process.emit('time', 'idealTree:userRequests');\n    const tree = this.idealTree.target;\n    if (!this[_workspaces].length) await this[_applyUserRequestsToNode](tree, options);else {\n      await Promise.all(this.workspaceNodes(tree, this[_workspaces]).map(node => this[_applyUserRequestsToNode](node, options)));\n    }\n    process.emit('timeEnd', 'idealTree:userRequests');\n  }\n\n  async [_applyUserRequestsToNode](tree, options) {\n    // If we have a list of package names to update, and we know it's\n    // going to update them wherever they are, add any paths into those\n    // named nodes to the buildIdealTree queue.\n    if (!this[_global] && this[_updateNames].length) this[_queueNamedUpdates](); // global updates only update the globalTop nodes, but we need to know\n    // that they're there, and not reinstall the world unnecessarily.\n\n    const globalExplicitUpdateNames = [];\n\n    if (this[_global] && (this[_updateAll] || this[_updateNames].length)) {\n      const nm = resolve(this.path, 'node_modules');\n\n      for (const name of await readdir(nm).catch(() => [])) {\n        tree.package.dependencies = tree.package.dependencies || {};\n\n        const updateName = this[_updateNames].includes(name);\n\n        if (this[_updateAll] || updateName) {\n          if (updateName) globalExplicitUpdateNames.push(name);\n          tree.package.dependencies[name] = '*';\n        }\n      }\n    }\n\n    if (this.auditReport && this.auditReport.size > 0) await this[_queueVulnDependents](options);\n    const {\n      add,\n      rm\n    } = options;\n\n    if (rm && rm.length) {\n      addRmPkgDeps.rm(tree.package, rm);\n\n      for (const name of rm) this[_explicitRequests].add({\n        from: tree,\n        name,\n        action: 'DELETE'\n      });\n    }\n\n    if (add && add.length) await this[_add](tree, options); // triggers a refresh of all edgesOut.  this has to be done BEFORE\n    // adding the edges to explicitRequests, because the package setter\n    // resets all edgesOut.\n\n    if (add && add.length || rm && rm.length || this[_global]) tree.package = tree.package;\n\n    for (const spec of this[_resolvedAdd]) {\n      if (spec.tree === tree) this[_explicitRequests].add(tree.edgesOut.get(spec.name));\n    }\n\n    for (const name of globalExplicitUpdateNames) this[_explicitRequests].add(tree.edgesOut.get(name));\n\n    this[_depsQueue].push(tree);\n  } // This returns a promise because we might not have the name yet,\n  // and need to call pacote.manifest to find the name.\n\n\n  [_add](tree, {\n    add,\n    saveType = null,\n    saveBundle = false\n  }) {\n    // get the name for each of the specs in the list.\n    // ie, doing `foo@bar` we just return foo\n    // but if it's a url or git, we don't know the name until we\n    // fetch it and look in its manifest.\n    return Promise.all(add.map(async rawSpec => {\n      // We do NOT provide the path to npa here, because user-additions\n      // need to be resolved relative to the CWD the user is in.\n      const spec = await this[_retrieveSpecName](npa(rawSpec)).then(spec => this[_updateFilePath](spec)).then(spec => this[_followSymlinkPath](spec));\n      spec.tree = tree;\n      return spec;\n    })).then(add => {\n      this[_resolvedAdd].push(...add); // now add is a list of spec objects with names.\n      // find a home for each of them!\n\n\n      addRmPkgDeps.add({\n        pkg: tree.package,\n        add,\n        saveBundle,\n        saveType,\n        path: this.path,\n        log: this.log\n      });\n    });\n  }\n\n  async [_retrieveSpecName](spec) {\n    // if it's just @'' then we reload whatever's there, or get latest\n    // if it's an explicit tag, we need to install that specific tag version\n    const isTag = spec.rawSpec && spec.type === 'tag';\n    if (spec.name && !isTag) return spec;\n    const mani = await pacote.manifest(spec, { ...this.options\n    }); // if it's a tag type, then we need to run it down to an actual version\n\n    if (isTag) return npa(`${mani.name}@${mani.version}`);\n    spec.name = mani.name;\n    return spec;\n  }\n\n  async [_updateFilePath](spec) {\n    if (spec.type === 'file') return this[_getRelpathSpec](spec, spec.fetchSpec);\n    return spec;\n  }\n\n  async [_followSymlinkPath](spec) {\n    if (spec.type === 'directory') {\n      const real = await realpath(spec.fetchSpec, this[_rpcache], this[_stcache]) // TODO: create synthetic test case to simulate realpath failure\n      .catch(\n      /* istanbul ignore next */\n      () => null);\n      return this[_getRelpathSpec](spec, real);\n    }\n\n    return spec;\n  }\n\n  [_getRelpathSpec](spec, filepath) {\n    /* istanbul ignore else - should also be covered by realpath failure */\n    if (filepath) {\n      const {\n        name\n      } = spec;\n      const tree = this.idealTree.target;\n      spec = npa(`file:${relpath(tree.path, filepath)}`, tree.path);\n      spec.name = name;\n    }\n\n    return spec;\n  } // TODO: provide a way to fix bundled deps by exposing metadata about\n  // what's in the bundle at each published manifest.  Without that, we\n  // can't possibly fix bundled deps without breaking a ton of other stuff,\n  // and leaving the user subject to getting it overwritten later anyway.\n\n\n  async [_queueVulnDependents](options) {\n    for (const vuln of this.auditReport.values()) {\n      for (const node of vuln.nodes) {\n        const bundler = node.getBundler(); // XXX this belongs in the audit report itself, not here.\n        // We shouldn't even get these things here, and they shouldn't\n        // be printed by npm-audit-report as if they can be fixed, because\n        // they can't.\n\n        if (bundler) {\n          this.log.warn(`audit fix ${node.name}@${node.version}`, `${node.location}\\nis a bundled dependency of\\n${bundler.name}@${bundler.version} at ${bundler.location}\\n` + 'It cannot be fixed automatically.\\n' + `Check for updates to the ${bundler.name} package.`);\n          continue;\n        }\n\n        for (const edge of node.edgesIn) {\n          this.addTracker('idealTree', edge.from.name, edge.from.location);\n\n          this[_depsQueue].push(edge.from);\n        }\n      }\n    } // note any that can't be fixed at the root level without --force\n    // if there's a fix, we use that.  otherwise, the user has to remove it,\n    // find a different thing, fix the upstream, etc.\n    //\n    // XXX: how to handle top nodes that aren't the root?  Maybe the report\n    // just tells the user to cd into that directory and fix it?\n\n\n    if (this[_force] && this.auditReport && this.auditReport.topVulns.size) {\n      options.add = options.add || [];\n      options.rm = options.rm || [];\n      const nodesTouched = new Set();\n\n      for (const [name, topVuln] of this.auditReport.topVulns.entries()) {\n        const {\n          simpleRange,\n          topNodes,\n          fixAvailable\n        } = topVuln;\n\n        for (const node of topNodes) {\n          if (!node.isProjectRoot && !node.isWorkspace) {\n            // not something we're going to fix, sorry.  have to cd into\n            // that directory and fix it yourself.\n            this.log.warn('audit', 'Manual fix required in linked project ' + `at ./${node.location} for ${name}@${simpleRange}.\\n` + `'cd ./${node.location}' and run 'npm audit' for details.`);\n            continue;\n          }\n\n          if (!fixAvailable) {\n            this.log.warn('audit', `No fix available for ${name}@${simpleRange}`);\n            continue;\n          }\n\n          const {\n            isSemVerMajor,\n            version\n          } = fixAvailable;\n          const breakingMessage = isSemVerMajor ? 'a SemVer major change' : 'outside your stated dependency range';\n          this.log.warn('audit', `Updating ${name} to ${version},` + `which is ${breakingMessage}.`);\n          await this[_add](node, {\n            add: [`${name}@${version}`]\n          });\n          nodesTouched.add(node);\n        }\n      }\n\n      for (const node of nodesTouched) node.package = node.package;\n    }\n  }\n\n  [_isVulnerable](node) {\n    return this.auditReport && this.auditReport.isVulnerable(node);\n  }\n\n  [_avoidRange](name) {\n    if (!this.auditReport) return null;\n    const vuln = this.auditReport.get(name);\n    if (!vuln) return null;\n    return vuln.range;\n  }\n\n  [_queueNamedUpdates]() {\n    // ignore top nodes, since they are not loaded the same way, and\n    // probably have their own project associated with them.\n    // for every node with one of the names on the list, we add its\n    // dependents to the queue to be evaluated.  in buildDepStep,\n    // anything on the update names list will get refreshed, even if\n    // it isn't a problem.\n    // XXX this could be faster by doing a series of inventory.query('name')\n    // calls rather than walking over everything in the tree.\n    const set = this.idealTree.inventory.filter(n => this[_shouldUpdateNode](n));\n\n    for (const node of set) {\n      for (const edge of node.edgesIn) {\n        this.addTracker('idealTree', edge.from.name, edge.from.location);\n\n        this[_depsQueue].push(edge.from);\n      }\n    }\n  }\n\n  [_shouldUpdateNode](node) {\n    return this[_updateNames].includes(node.name) && !node.isTop && !node.inDepBundle && !node.inShrinkwrap;\n  }\n\n  async [_inflateAncientLockfile]() {\n    const {\n      meta,\n      inventory\n    } = this.idealTree;\n    const ancient = meta.ancientLockfile;\n    const old = meta.loadedFromDisk && !(meta.originalLockfileVersion >= 2);\n    if (inventory.size === 0 || !ancient && !old) return; // if the lockfile is from node v5 or earlier, then we'll have to reload\n    // all the manifests of everything we encounter.  this is costly, but at\n    // least it's just a one-time hit.\n\n    process.emit('time', 'idealTree:inflate');\n    const heading = ancient ? 'ancient lockfile' : 'old lockfile';\n    this.log.warn(heading, `\nThe ${meta.type} file was created with an old version of npm,\nso supplemental metadata must be fetched from the registry.\n\nThis is a one-time fix-up, please be patient...\n`);\n    this.addTracker('idealTree:inflate');\n    const queue = [];\n\n    for (const node of inventory.values()) {\n      if (node.isProjectRoot) continue;\n      queue.push(async () => {\n        this.log.silly('inflate', node.location);\n        const {\n          resolved,\n          version,\n          path,\n          name,\n          location,\n          integrity\n        } = node; // don't try to hit the registry for linked deps\n\n        const useResolved = resolved && (!version || resolved.startsWith('file:'));\n        const id = useResolved ? resolved : version || `file:${node.path}`;\n        const spec = npa.resolve(name, id, dirname(path));\n        const sloc = location.substr('node_modules/'.length);\n        const t = `idealTree:inflate:${sloc}`;\n        this.addTracker(t);\n        await pacote.manifest(spec, { ...this.options,\n          resolved: resolved,\n          integrity: integrity,\n          fullMetadata: false\n        }).then(mani => {\n          node.package = { ...mani,\n            _id: `${mani.name}@${mani.version}`\n          };\n        }).catch(er => {\n          const warning = `Could not fetch metadata for ${name}@${id}`;\n          this.log.warn(heading, warning, er);\n        });\n        this.finishTracker(t);\n      });\n    }\n\n    await promiseCallLimit(queue); // have to re-calc dep flags, because the nodes don't have edges\n    // until their packages get assigned, so everything looks extraneous\n\n    calcDepFlags(this.idealTree); // yes, yes, this isn't the \"original\" version, but now that it's been\n    // upgraded, we need to make sure we don't do the work to upgrade it\n    // again, since it's now as new as can be.\n\n    meta.originalLockfileVersion = 2;\n    this.finishTracker('idealTree:inflate');\n    process.emit('timeEnd', 'idealTree:inflate');\n  } // at this point we have a virtual tree with the actual root node's\n  // package deps, which may be partly or entirely incomplete, invalid\n  // or extraneous.\n\n\n  [_buildDeps]() {\n    process.emit('time', 'idealTree:buildDeps');\n    const tree = this.idealTree.target;\n\n    this[_depsQueue].push(tree);\n\n    this.log.silly('idealTree', 'buildDeps');\n    this.addTracker('idealTree', tree.name, '');\n    return this[_buildDepStep]().then(() => process.emit('timeEnd', 'idealTree:buildDeps'));\n  }\n\n  async [_buildDepStep]() {\n    // removes tracker of previous dependency in the queue\n    if (this[_currentDep]) {\n      const {\n        location,\n        name\n      } = this[_currentDep];\n      process.emit('timeEnd', `idealTree:${location || '#root'}`);\n      this.finishTracker('idealTree', name, location);\n      this[_currentDep] = null;\n    }\n\n    if (!this[_depsQueue].length) return this[_resolveLinks](); // sort physically shallower deps up to the front of the queue,\n    // because they'll affect things deeper in, then alphabetical\n\n    this[_depsQueue].sort((a, b) => a.depth - b.depth || a.path.localeCompare(b.path, 'en'));\n\n    const node = this[_depsQueue].shift();\n\n    const bd = node.package.bundleDependencies;\n    const hasBundle = bd && Array.isArray(bd) && bd.length;\n    const {\n      hasShrinkwrap\n    } = node; // if the node was already visited, or has since been removed from the\n    // tree, skip over it and process the rest of the queue.  If a node has\n    // a shrinkwrap, also skip it, because it's going to get its deps\n    // satisfied by whatever's in that file anyway.\n\n    if (this[_depsSeen].has(node) || node.root !== this.idealTree || hasShrinkwrap && !this[_complete]) return this[_buildDepStep]();\n\n    this[_depsSeen].add(node);\n\n    this[_currentDep] = node;\n    process.emit('time', `idealTree:${node.location || '#root'}`); // if we're loading a _complete_ ideal tree, for a --package-lock-only\n    // installation for example, we have to crack open the tarball and\n    // look inside if it has bundle deps or shrinkwraps.  note that this is\n    // not necessary during a reification, because we just update the\n    // ideal tree by reading bundles/shrinkwraps in place.\n    // Don't bother if the node is from the actual tree and hasn't\n    // been resolved, because we can't fetch it anyway, could be anything!\n\n    const crackOpen = this[_complete] && node !== this.idealTree && node.resolved && (hasBundle || hasShrinkwrap);\n\n    if (crackOpen) {\n      const Arborist = this.constructor;\n      const opt = { ...this.options\n      };\n      await cacache.tmp.withTmp(this.cache, opt, async path => {\n        await pacote.extract(node.resolved, path, { ...opt,\n          resolved: node.resolved,\n          integrity: node.integrity\n        });\n\n        if (hasShrinkwrap) {\n          await new Arborist({ ...this.options,\n            path\n          }).loadVirtual({\n            root: node\n          });\n        }\n\n        if (hasBundle) {\n          await new Arborist({ ...this.options,\n            path\n          }).loadActual({\n            root: node,\n            ignoreMissing: true\n          });\n        }\n      });\n    } // if any deps are missing or invalid, then we fetch the manifest for\n    // the thing we want, and build a new dep node from that.\n    // Then, find the ideal placement for that node.  The ideal placement\n    // searches from the node's deps (or parent deps in the case of non-root\n    // peer deps), and walks up the tree until it finds the highest spot\n    // where it doesn't cause any conflicts.\n    //\n    // A conflict can be:\n    // - A node by that name already exists at that location.\n    // - The parent has a peer dep on that name\n    // - One of the node's peer deps conflicts at that location, unless the\n    //   peer dep is met by a node at that location, which is fine.\n    //\n    // If we create a new node, then build its ideal deps as well.\n    //\n    // Note: this is the same \"maximally naive\" deduping tree-building\n    // algorithm that npm has used since v3.  In a case like this:\n    //\n    // root -> (a@1, b@1||2)\n    // a -> (b@1)\n    //\n    // You'll end up with a tree like this:\n    //\n    // root\n    // +-- a@1\n    // |   +-- b@1\n    // +-- b@2\n    //\n    // rather than this, more deduped, but just as correct tree:\n    //\n    // root\n    // +-- a@1\n    // +-- b@1\n    //\n    // Another way to look at it is that this algorithm favors getting higher\n    // version deps at higher levels in the tree, even if that reduces\n    // potential deduplication.\n    //\n    // Set `preferDedupe: true` in the options to replace the shallower\n    // dep if allowed.\n\n\n    const tasks = [];\n    const peerSource = this[_peerSetSource].get(node) || node;\n\n    for (const edge of this[_problemEdges](node)) {\n      if (this[_edgesOverridden].has(edge)) continue; // peerSetSource is only relevant when we have a peerEntryEdge\n      // otherwise we're setting regular non-peer deps as if they have\n      // a virtual root of whatever brought in THIS node.\n      // so we VR the node itself if the edge is not a peer\n\n      const source = edge.peer ? peerSource : node;\n\n      const virtualRoot = this[_virtualRoot](source, true); // reuse virtual root if we already have one, but don't\n      // try to do the override ahead of time, since we MAY be able\n      // to create a more correct tree than the virtual root could.\n\n\n      const vrEdge = virtualRoot && virtualRoot.edgesOut.get(edge.name);\n      const vrDep = vrEdge && vrEdge.valid && vrEdge.to; // only re-use the virtualRoot if it's a peer edge we're placing.\n      // otherwise, we end up in situations where we override peer deps that\n      // we could have otherwise found homes for.  Eg:\n      // xy -> (x, y)\n      // x -> PEER(z@1)\n      // y -> PEER(z@2)\n      // If xy is a dependency, we can resolve this like:\n      // project\n      // +-- xy\n      // |   +-- y\n      // |   +-- z@2\n      // +-- x\n      // +-- z@1\n      // But if x and y are loaded in the same virtual root, then they will\n      // be forced to agree on a version of z.\n\n      const required = new Set([edge.from]);\n      const parent = edge.peer ? virtualRoot : null;\n      const dep = vrDep && vrDep.satisfies(edge) ? vrDep : await this[_nodeFromEdge](edge, parent, null, required);\n      /* istanbul ignore next */\n\n      debug(() => {\n        if (!dep) throw new Error('no dep??');\n      });\n      tasks.push({\n        edge,\n        dep\n      });\n    }\n\n    const placed = tasks.sort((a, b) => a.edge.name.localeCompare(b.edge.name, 'en')).map(({\n      edge,\n      dep\n    }) => this[_placeDep](dep, node, edge));\n    const promises = [];\n\n    for (const set of placed) {\n      for (const node of set) {\n        this[_mutateTree] = true;\n        this.addTracker('idealTree', node.name, node.location);\n\n        this[_depsQueue].push(node); // we're certainly going to need these soon, fetch them asap\n        // if it fails at this point, though, dont' worry because it\n        // may well be an optional dep that has gone missing.  it'll\n        // fail later anyway.\n\n\n        const from = fromPath(node);\n        promises.push(...this[_problemEdges](node).map(e => this[_fetchManifest](npa.resolve(e.name, e.spec, from)).catch(er => null)));\n      }\n    }\n\n    await Promise.all(promises);\n\n    for (const {\n      to\n    } of node.edgesOut.values()) {\n      if (to && to.isLink && to.target) this[_linkNodes].add(to);\n    }\n\n    return this[_buildDepStep]();\n  } // loads a node from an edge, and then loads its peer deps (and their\n  // peer deps, on down the line) into a virtual root parent.\n\n\n  async [_nodeFromEdge](edge, parent_, secondEdge, required) {\n    // create a virtual root node with the same deps as the node that\n    // is requesting this one, so that we can get all the peer deps in\n    // a context where they're likely to be resolvable.\n    // Note that the virtual root will also have virtual copies of the\n    // targets of any child Links, so that they resolve appropriately.\n    const parent = parent_ || this[_virtualRoot](edge.from);\n\n    const realParent = edge.peer ? edge.from.resolveParent : edge.from;\n    const spec = npa.resolve(edge.name, edge.spec, edge.from.path);\n    const first = await this[_nodeFromSpec](edge.name, spec, parent, edge); // we might have a case where the parent has a peer dependency on\n    // `foo@*` which resolves to v2, but another dep in the set has a\n    // peerDependency on `foo@1`.  In that case, if we force it to be v2,\n    // we're unnecessarily triggering an ERESOLVE.\n    // If we have a second edge to worry about, and it's not satisfied\n    // by the first node, try a second and see if that satisfies the\n    // original edge here.\n\n    const spec2 = secondEdge && npa.resolve(edge.name, secondEdge.spec, secondEdge.from.path);\n    const second = secondEdge && !secondEdge.valid ? await this[_nodeFromSpec](edge.name, spec2, parent, secondEdge) : null; // pick the second one if they're both happy with that, otherwise first\n\n    const node = second && edge.valid ? second : first; // ensure the one we want is the one that's placed\n\n    node.parent = parent;\n    if (required.has(edge.from) && edge.type !== 'peerOptional' || secondEdge && required.has(secondEdge.from) && secondEdge.type !== 'peerOptional') required.add(node); // handle otherwise unresolvable dependency nesting loops by\n    // creating a symbolic link\n    // a1 -> b1 -> a2 -> b2 -> a1 -> ...\n    // instead of nesting forever, when the loop occurs, create\n    // a symbolic link to the earlier instance\n\n    for (let p = edge.from.resolveParent; p; p = p.resolveParent) {\n      if (p.matches(node) && !p.isTop) return new Link({\n        parent: realParent,\n        target: p\n      });\n    } // keep track of the thing that caused this node to be included.\n\n\n    const src = parent.sourceReference;\n\n    this[_peerSetSource].set(node, src);\n\n    return this[_loadPeerSet](node, required);\n  }\n\n  [_virtualRoot](node, reuse = false) {\n    if (reuse && this[_virtualRoots].has(node)) return this[_virtualRoots].get(node);\n    const vr = new Node({\n      path: node.realpath,\n      sourceReference: node,\n      legacyPeerDeps: this.legacyPeerDeps\n    }); // also need to set up any targets from any link deps, so that\n    // they are properly reflected in the virtual environment\n\n    for (const child of node.children.values()) {\n      if (child.isLink) {\n        new Node({\n          path: child.realpath,\n          sourceReference: child.target,\n          root: vr\n        });\n      }\n    }\n\n    this[_virtualRoots].set(node, vr);\n\n    return vr;\n  }\n\n  [_problemEdges](node) {\n    // skip over any bundled deps, they're not our problem.\n    // Note that this WILL fetch bundled meta-deps which are also dependencies\n    // but not listed as bundled deps.  When reifying, we first unpack any\n    // nodes that have bundleDependencies, then do a loadActual on them, move\n    // the nodes into the ideal tree, and then prune.  So, fetching those\n    // possibly-bundled meta-deps at this point doesn't cause any worse\n    // problems than a few unnecessary packument fetches.\n    // also skip over any nodes in the tree that failed to load, since those\n    // will crash the install later on anyway.\n    const bd = node.isProjectRoot || node.isWorkspace ? null : node.package.bundleDependencies;\n    const bundled = new Set(bd || []);\n    return [...node.edgesOut.values()].filter(edge => {\n      // If it's included in a bundle, we take whatever is specified.\n      if (bundled.has(edge.name)) return false; // If it's already been logged as a load failure, skip it.\n\n      if (edge.to && this[_loadFailures].has(edge.to)) return false; // If it's shrinkwrapped, we use what the shrinkwap wants.\n\n      if (edge.to && edge.to.inShrinkwrap) return false; // If the edge has no destination, that's a problem, unless\n      // if it's peerOptional and not explicitly requested.\n\n      if (!edge.to) {\n        return edge.type !== 'peerOptional' || this[_explicitRequests].has(edge);\n      } // If the edge has an error, there's a problem.\n\n\n      if (!edge.valid) return true; // If user has explicitly asked to update this package by name, it's a problem.\n\n      if (this[_updateNames].includes(edge.name)) return true; // If we're fixing a security vulnerability with this package, it's a problem.\n\n      if (this[_isVulnerable](edge.to)) return true; // If the user has explicitly asked to install this package, it's a \"problem\".\n\n      if (this[_explicitRequests].has(edge)) return true; // No problems!\n\n      return false;\n    });\n  }\n\n  async [_fetchManifest](spec) {\n    const options = { ...this.options,\n      avoid: this[_avoidRange](spec.name)\n    }; // get the intended spec and stored metadata from yarn.lock file,\n    // if available and valid.\n\n    spec = this.idealTree.meta.checkYarnLock(spec, options);\n    if (this[_manifests].has(spec.raw)) return this[_manifests].get(spec.raw);else {\n      this.log.silly('fetch manifest', spec.raw);\n      const p = pacote.manifest(spec, options).then(mani => {\n        this[_manifests].set(spec.raw, mani);\n\n        return mani;\n      });\n\n      this[_manifests].set(spec.raw, p);\n\n      return p;\n    }\n  }\n\n  [_nodeFromSpec](name, spec, parent, edge) {\n    // pacote will slap integrity on its options, so we have to clone\n    // the object so it doesn't get mutated.\n    // Don't bother to load the manifest for link deps, because the target\n    // might be within another package that doesn't exist yet.\n    const {\n      legacyPeerDeps\n    } = this;\n    return spec.type === 'directory' ? this[_linkFromSpec](name, spec, parent, edge) : this[_fetchManifest](spec).then(pkg => new Node({\n      name,\n      pkg,\n      parent,\n      legacyPeerDeps\n    }), error => {\n      error.requiredBy = edge.from.location || '.'; // failed to load the spec, either because of enotarget or\n      // fetch failure of some other sort.  save it so we can verify\n      // later that it's optional, otherwise the error is fatal.\n\n      const n = new Node({\n        name,\n        parent,\n        error,\n        legacyPeerDeps\n      });\n\n      this[_loadFailures].add(n);\n\n      return n;\n    });\n  }\n\n  [_linkFromSpec](name, spec, parent, edge) {\n    const realpath = spec.fetchSpec;\n    const {\n      legacyPeerDeps\n    } = this;\n    return rpj(realpath + '/package.json').catch(() => ({})).then(pkg => {\n      const link = new Link({\n        name,\n        parent,\n        realpath,\n        pkg,\n        legacyPeerDeps\n      });\n\n      this[_linkNodes].add(link);\n\n      return link;\n    });\n  } // load all peer deps and meta-peer deps into the node's parent\n  // At the end of this, the node's peer-type outward edges are all\n  // resolved, and so are all of theirs, but other dep types are not.\n  // We prefer to get peer deps that meet the requiring node's dependency,\n  // if possible, since that almost certainly works (since that package was\n  // developed with this set of deps) and will typically be more restrictive.\n  // Note that the peers in the set can conflict either with each other,\n  // or with a direct dependency from the virtual root parent!  In strict\n  // mode, this is always an error.  In force mode, it never is, and we\n  // prefer the parent's non-peer dep over a peer dep, or the version that\n  // gets placed first.  In non-strict mode, we behave strictly if the\n  // virtual root is based on the root project, and allow non-peer parent\n  // deps to override, but throw if no preference can be determined.\n\n\n  async [_loadPeerSet](node, required) {\n    const peerEdges = [...node.edgesOut.values()] // we typically only install non-optional peers, but we have to\n    // factor them into the peerSet so that we can avoid conflicts\n    .filter(e => e.peer && !(e.valid && e.to)).sort(({\n      name: a\n    }, {\n      name: b\n    }) => a.localeCompare(b, 'en'));\n\n    for (const edge of peerEdges) {\n      // already placed this one, and we're happy with it.\n      if (edge.valid && edge.to) continue;\n      const parentEdge = node.parent.edgesOut.get(edge.name);\n      const {\n        isProjectRoot,\n        isWorkspace\n      } = node.parent.sourceReference;\n      const isMine = isProjectRoot || isWorkspace;\n      const conflictOK = this[_force] || !isMine && !this[_strictPeerDeps];\n\n      if (!edge.to) {\n        if (!parentEdge) {\n          // easy, just put the thing there\n          await this[_nodeFromEdge](edge, node.parent, null, required);\n          continue;\n        } else {\n          // if the parent's edge is very broad like >=1, and the edge in\n          // question is something like 1.x, then we want to get a 1.x, not\n          // a 2.x.  pass along the child edge as an advisory guideline.\n          // if the parent edge doesn't satisfy the child edge, and the\n          // child edge doesn't satisfy the parent edge, then we have\n          // a conflict.  this is always a problem in strict mode, never\n          // in force mode, and a problem in non-strict mode if this isn't\n          // on behalf of our project.  in all such cases, we warn at least.\n          const dep = await this[_nodeFromEdge](parentEdge, node.parent, edge, required); // hooray! that worked!\n\n          if (edge.valid) continue; // allow it.  either we're overriding, or it's not something\n          // that will be installed by default anyway, and we'll fail when\n          // we get to the point where we need to, if we need to.\n\n          if (conflictOK || !required.has(dep)) continue; // problem\n\n          this[_failPeerConflict](edge, parentEdge);\n        }\n      } // There is something present already, and we're not happy about it\n      // See if the thing we WOULD be happy with is also going to satisfy\n      // the other dependents on the current node.\n\n\n      const current = edge.to;\n      const dep = await this[_nodeFromEdge](edge, null, null, required);\n\n      if (dep.canReplace(current)) {\n        await this[_nodeFromEdge](edge, node.parent, null, required);\n        continue;\n      } // at this point we know that there is a dep there, and\n      // we don't like it.  always fail strictly, always allow forcibly or\n      // in non-strict mode if it's not our fault.  don't warn here, because\n      // we are going to warn again when we place the deps, if we end up\n      // overriding for something else.  If the thing that has this dep\n      // isn't also required, then there's a good chance we won't need it,\n      // so allow it for now and let it conflict if it turns out to actually\n      // be necessary for the installation.\n\n\n      if (conflictOK || !required.has(edge.from)) continue; // ok, it's the root, or we're in unforced strict mode, so this is bad\n\n      this[_failPeerConflict](edge, parentEdge);\n    }\n\n    return node;\n  }\n\n  [_failPeerConflict](edge, currentEdge) {\n    const expl = this[_explainPeerConflict](edge, currentEdge);\n\n    throw Object.assign(new Error('unable to resolve dependency tree'), expl);\n  }\n\n  [_explainPeerConflict](edge, currentEdge) {\n    const node = edge.from;\n    const curNode = node.resolve(edge.name);\n    const pc = this[_peerConflict] || {\n      peer: null,\n      current: null\n    };\n    const current = curNode ? curNode.explain() : pc.current;\n    const peerConflict = pc.peer;\n    return {\n      code: 'ERESOLVE',\n      current,\n      // it SHOULD be impossible to get here without a current node in place,\n      // but this at least gives us something report on when bugs creep into\n      // the tree handling logic.\n      currentEdge: currentEdge ? currentEdge.explain() : null,\n      edge: edge.explain(),\n      peerConflict,\n      strictPeerDeps: this[_strictPeerDeps],\n      force: this[_force]\n    };\n  }\n\n  [_warnPeerConflict](edge) {\n    // track that we've overridden this edge, so that we don't keep trying\n    // to re-resolve it in an infinite loop.\n    this[_edgesOverridden].add(edge);\n\n    const expl = this[_explainPeerConflict](edge);\n\n    this.log.warn('ERESOLVE', 'overriding peer dependency', expl);\n  } // starting from either node, or in the case of non-root peer deps,\n  // the node's parent, walk up the tree until we find the first spot\n  // where this dep cannot be placed, and use the one right before that.\n  // place dep, requested by node, to satisfy edge\n  // XXX split this out into a separate method or mixin?  It's quite a lot\n  // of functionality that ought to have its own unit tests more conveniently.\n\n\n  [_placeDep](dep, node, edge, peerEntryEdge = null, peerPath = []) {\n    if (edge.to && !edge.error && !this[_explicitRequests].has(edge) && !this[_updateNames].includes(edge.name) && !this[_isVulnerable](edge.to)) return []; // top nodes should still get peer deps from their fsParent if possible,\n    // and only install locally if there's no other option, eg for a link\n    // outside of the project root, or for a conflicted dep.\n\n    const start = edge.peer && !node.isProjectRoot ? node.resolveParent || node : node;\n    let target;\n    let canPlace = null;\n    let isSource = false;\n\n    const source = this[_peerSetSource].get(dep);\n\n    for (let check = start; check; check = check.resolveParent) {\n      // we always give the FIRST place we possibly *can* put this a little\n      // extra prioritization with peer dep overrides and deduping\n      if (check === source) isSource = true; // if the current location has a peerDep on it, then we can't place here\n      // this is pretty rare to hit, since we always prefer deduping peers.\n\n      const checkEdge = check.edgesOut.get(edge.name);\n      if (!check.isTop && checkEdge && checkEdge.peer) continue;\n\n      const cp = this[_canPlaceDep](dep, check, edge, peerEntryEdge, peerPath, isSource);\n\n      isSource = false; // anything other than a conflict is fine to proceed with\n\n      if (cp !== CONFLICT) {\n        canPlace = cp;\n        target = check;\n      } else break; // nest packages like npm v1 and v2\n      // very disk-inefficient\n\n\n      if (this[_legacyBundling]) break; // when installing globally, or just in global style, we never place\n      // deps above the first level.\n\n      const tree = this.idealTree && this.idealTree.target;\n      if (this[_globalStyle] && check.resolveParent === tree) break;\n    } // if we can't find a target, that means that the last placed checked\n    // (and all the places before it) had a copy already.  if we're in\n    // --force mode, then the user has explicitly said that they're ok\n    // with conflicts.  This can only occur in --force mode in the case\n    // when a node was added to the tree with a peerOptional dep that we\n    // ignored, and then later, that edge became invalid, and we fail to\n    // resolve it.  We will warn about it in a moment.\n\n\n    if (!target) {\n      if (this[_force]) {\n        // we know that there is a dep (not the root) which is the target\n        // of this edge, or else it wouldn't have been a conflict.\n        target = edge.to.resolveParent;\n        canPlace = KEEP;\n      } else this[_failPeerConflict](edge);\n    } else {\n      // it worked, so we clearly have no peer conflicts at this point.\n      this[_peerConflict] = null;\n    }\n\n    this.log.silly('placeDep', target.location || 'ROOT', `${dep.name}@${dep.version}`, canPlace.description ||\n    /* istanbul ignore next */\n    canPlace, `for: ${node.package._id || node.location}`, `want: ${edge.spec || '*'}`); // Can only get KEEP here if the original edge was valid,\n    // and we're checking for an update but it's already up to date.\n\n    if (canPlace === KEEP) {\n      if (edge.peer && !target.children.get(edge.name).satisfies(edge)) {\n        // this is an overridden peer dep\n        this[_warnPeerConflict](edge);\n      } // if we get a KEEP in a update scenario, then we MAY have something\n      // already duplicating this unnecessarily!  For example:\n      // ```\n      // root\n      // +-- x (dep: y@1.x)\n      // |   +-- y@1.0.0\n      // +-- y@1.1.0\n      // ```\n      // Now say we do `reify({update:['y']})`, and the latest version is\n      // 1.1.0, which we already have in the root.  We'll try to place y@1.1.0\n      // first in x, then in the root, ending with KEEP, because we already\n      // have it.  In that case, we ought to REMOVE the nm/x/nm/y node, because\n      // it is an unnecessary duplicate.\n\n\n      this[_pruneDedupable](target);\n\n      return [];\n    } // figure out which of this node's peer deps will get placed as well\n\n\n    const virtualRoot = dep.parent;\n    const newDep = new dep.constructor({\n      name: dep.name,\n      pkg: dep.package,\n      resolved: dep.resolved,\n      integrity: dep.integrity,\n      legacyPeerDeps: this.legacyPeerDeps,\n      error: dep.errors[0],\n      ...(dep.isLink ? {\n        target: dep.target,\n        realpath: dep.target.path\n      } : {})\n    });\n    if (this[_loadFailures].has(dep)) this[_loadFailures].add(newDep);\n    const placed = [newDep];\n    const oldChild = target.children.get(edge.name);\n\n    if (oldChild) {\n      // if we're replacing, we should also remove any nodes for edges that\n      // are now invalid, and where this (or its deps) is the only dependent,\n      // and also recurse on that pruning.  Otherwise leaving that dep node\n      // around can result in spurious conflicts pushing nodes deeper into\n      // the tree than needed in the case of cycles that will be removed\n      // later anyway.\n      const oldDeps = [];\n\n      for (const [name, edge] of oldChild.edgesOut.entries()) {\n        if (!newDep.edgesOut.has(name) && edge.to) oldDeps.push(...gatherDepSet([edge.to], e => e.to !== edge.to));\n      }\n\n      newDep.replace(oldChild);\n\n      this[_pruneForReplacement](newDep, oldDeps); // this may also create some invalid edges, for example if we're\n      // intentionally causing something to get nested which was previously\n      // placed in this location.\n\n\n      for (const edgeIn of newDep.edgesIn) {\n        if (edgeIn.invalid && edgeIn !== edge) {\n          this[_depsQueue].push(edgeIn.from);\n\n          this[_depsSeen].delete(edgeIn.from);\n        }\n      }\n    } else newDep.parent = target;\n\n    if (edge.peer && !newDep.satisfies(edge)) {\n      // this is an overridden peer dep\n      this[_warnPeerConflict](edge);\n    } // If the edge is not an error, then we're updating something, and\n    // MAY end up putting a better/identical node further up the tree in\n    // a way that causes an unnecessary duplication.  If so, remove the\n    // now-unnecessary node.\n\n\n    if (edge.valid && edge.to && edge.to !== newDep) this[_pruneDedupable](edge.to, false); // visit any dependents who are upset by this change\n    // if it's an angry overridden peer edge, however, make sure we\n    // skip over it!\n\n    for (const edgeIn of newDep.edgesIn) {\n      if (edgeIn !== edge && !edgeIn.valid && !this[_depsSeen].has(edge.from)) {\n        this.addTracker('idealTree', edgeIn.from.name, edgeIn.from.location);\n\n        this[_depsQueue].push(edgeIn.from);\n      }\n    } // in case we just made some duplicates that can be removed,\n    // prune anything deeper in the tree that can be replaced by this\n\n\n    if (this.idealTree) {\n      for (const node of this.idealTree.inventory.query('name', newDep.name)) {\n        if (!node.isTop && node.isDescendantOf(target)) this[_pruneDedupable](node, false);\n      }\n    } // also place its unmet or invalid peer deps at this location\n    // note that newDep has now been removed from the virtualRoot set\n    // by virtue of being placed in the target's node_modules.\n    // loop through any peer deps from the thing we just placed, and place\n    // those ones as well.  it's safe to do this with the virtual nodes,\n    // because we're copying rather than moving them out of the virtual root,\n    // otherwise they'd be gone and the peer set would change throughout\n    // this loop.\n\n\n    for (const peerEdge of newDep.edgesOut.values()) {\n      const peer = virtualRoot.children.get(peerEdge.name); // Note: if the virtualRoot *doesn't* have the peer, then that means\n      // it's an optional peer dep.  If it's not being properly met (ie,\n      // peerEdge.valid is false), that this is likely heading for an\n      // ERESOLVE error, unless it can walk further up the tree.\n\n      if (!peerEdge.peer || peerEdge.valid || !peer) continue;\n\n      const peerPlaced = this[_placeDep](peer, newDep, peerEdge, peerEntryEdge || edge, peerPath);\n\n      placed.push(...peerPlaced);\n    } // we're done with this now, clean it up.\n\n\n    this[_virtualRoots].delete(virtualRoot.sourceReference);\n\n    return placed;\n  } // prune all the nodes in a branch of the tree that can be safely removed\n  // This is only the most basic duplication detection; it finds if there\n  // is another satisfying node further up the tree, and if so, dedupes.\n  // Even in legacyBundling mode, we do this amount of deduplication.\n\n\n  [_pruneDedupable](node, descend = true) {\n    if (node.canDedupe(this[_preferDedupe])) {\n      node.root = null;\n      return;\n    }\n\n    if (descend) {\n      // sort these so that they're deterministically ordered\n      // otherwise, resulting tree shape is dependent on the order\n      // in which they happened to be resolved.\n      const nodeSort = (a, b) => a.location.localeCompare(b.location, 'en');\n\n      const children = [...node.children.values()].sort(nodeSort);\n      const fsChildren = [...node.fsChildren].sort(nodeSort);\n\n      for (const child of children) this[_pruneDedupable](child);\n\n      for (const topNode of fsChildren) {\n        const children = [...topNode.children.values()].sort(nodeSort);\n\n        for (const child of children) this[_pruneDedupable](child);\n      }\n    }\n  }\n\n  [_pruneForReplacement](node, oldDeps) {\n    // gather up all the invalid edgesOut, and any now-extraneous\n    // deps that the new node doesn't depend on but the old one did.\n    const invalidDeps = new Set([...node.edgesOut.values()].filter(e => e.to && !e.valid).map(e => e.to));\n\n    for (const dep of oldDeps) {\n      const set = gatherDepSet([dep], e => e.to !== dep && e.valid);\n\n      for (const dep of set) invalidDeps.add(dep);\n    } // ignore dependency edges from the node being replaced, but\n    // otherwise filter the set down to just the set with no\n    // dependencies from outside the set, except the node in question.\n\n\n    const deps = gatherDepSet(invalidDeps, edge => edge.from !== node && edge.to !== node && edge.valid); // now just delete whatever's left, because it's junk\n\n    for (const dep of deps) dep.parent = null;\n  } // check if we can place DEP in TARGET to satisfy EDGE\n  // Need to verify:\n  // - no child by that name there already\n  // - target does not have a peer dep on name\n  // - no higher-level pkg by that name and incompatible spec is depended on\n  //   by anything lower in the tree.\n  // - node's peer deps and meta-peer deps are siblings in a virtual root at\n  //   this point.  make sure that the whole family can come along, so apply\n  //   the same checks to each of them.  They may land higher up in the tree,\n  //   but we need to know that they CAN live here.\n  // Responses:\n  // - OK - Yes, because there is nothing there and no conflicts caused\n  // - REPLACE - Yes, and you can clobber what's there\n  // - KEEP - No, but what's there is fine\n  // - CONFLICT - You may not put that there\n  //\n  // Check peers on OK or REPLACE.  KEEP and CONFLICT do not require peer\n  // checking, because either we're leaving it alone, or it won't work anyway.\n  // When we check peers, we pass along the peerEntryEdge to track the\n  // original edge that caused us to load the family of peer dependencies.\n\n\n  [_canPlaceDep](dep, target, edge, peerEntryEdge = null, peerPath = [], isSource = false) {\n    /* istanbul ignore next */\n    debug(() => {\n      if (!dep) throw new Error('no dep??');\n    });\n    const entryEdge = peerEntryEdge || edge;\n\n    const source = this[_peerSetSource].get(dep);\n\n    isSource = isSource || target === source; // if we're overriding the source, then we care if the *target* is\n    // ours, even if it wasn't actually the original source, since we\n    // are depending on something that has a dep that can't go in its own\n    // folder.  for example, a -> b, b -> PEER(a).  Even though a is the\n    // source, b has to be installed up a level, and if the root package\n    // depends on a, and it has a conflict, it's our problem.  So, the root\n    // (or whatever is bringing in a) becomes the \"effective source\" for\n    // the purposes of this calculation.\n\n    const {\n      isProjectRoot,\n      isWorkspace\n    } = isSource ? target : source || {};\n    const isMine = isProjectRoot || isWorkspace; // Useful testing thingie right here.\n    // peerEntryEdge should *always* be a non-peer dependency, or a peer\n    // dependency from the root node.  When we get spurious ERESOLVE errors,\n    // or *don't* get ERESOLVE errors when we should, check to see if this\n    // fails, because it MAY mean we got off track somehow.\n\n    /* istanbul ignore next - debug check, should be impossible */\n\n    debug(() => {\n      if (peerEntryEdge && peerEntryEdge.peer && !peerEntryEdge.from.isTop) throw new Error('lost original peerEntryEdge somehow?');\n    });\n\n    if (target.children.has(edge.name)) {\n      const current = target.children.get(edge.name); // same thing = keep, UNLESS the current doesn't satisfy and new\n      // one does satisfy.  This can happen if it's a link to a matching target\n      // at a different location, which satisfies a version dep, but not a\n      // file: dep.  If neither of them satisfy, then we can replace it,\n      // because presumably it's better for a peer or something.\n\n      if (dep.matches(current)) {\n        if (current.satisfies(edge) || !dep.satisfies(edge)) return KEEP;\n      }\n\n      const {\n        version: curVer\n      } = current;\n      const {\n        version: newVer\n      } = dep;\n      const tryReplace = curVer && newVer && semver.gte(newVer, curVer);\n\n      if (tryReplace && dep.canReplace(current)) {\n        const res = this[_canPlacePeers](dep, target, edge, REPLACE, peerEntryEdge, peerPath, isSource);\n        /* istanbul ignore else - It's extremely rare that a replaceable\n         * node would be a conflict, if the current one wasn't a conflict,\n         * but it is theoretically possible if peer deps are pinned.  In\n         * that case we treat it like any other conflict, and keep trying */\n\n\n        if (res !== CONFLICT) return res;\n      } // ok, can't replace the current with new one, but maybe current is ok?\n      // no need to check if it's a peer that's valid to be here, because\n      // peers are always placed along with their entry source\n\n\n      if (edge.satisfiedBy(current)) return KEEP; // if we prefer deduping, then try replacing newer with older\n      // we always prefer to dedupe peers, because they are trying\n      // a bit harder to be singletons.\n\n      const preferDedupe = this[_preferDedupe] || edge.peer;\n\n      if (preferDedupe && !tryReplace && dep.canReplace(current)) {\n        const res = this[_canPlacePeers](dep, target, edge, REPLACE, peerEntryEdge, peerPath, isSource);\n        /* istanbul ignore else - It's extremely rare that a replaceable\n         * node would be a conflict, if the current one wasn't a conflict,\n         * but it is theoretically possible if peer deps are pinned.  In\n         * that case we treat it like any other conflict, and keep trying */\n\n\n        if (res !== CONFLICT) return res;\n      } // check for conflict override cases.\n      // first: is this the only place this thing can go?  If the target is\n      // the source, then one of these things are true.\n      //\n      // 1. the conflicted dep was deduped up to here from a lower dependency\n      // w -> (x,y)\n      // x -> (z)\n      // y -> PEER(p@1)\n      // z -> (q)\n      // q -> (p@2)\n      //\n      // When building, let's say that x is fully placed, with all of its\n      // deps, and we're _adding_ y.  Since the peer on p@1 was not initially\n      // present, it's been deduped up to w, and now needs to be pushed out.\n      // Replace it, and potentially also replace its peer set (though that'll\n      // be accomplished by making the same determination when we call\n      // _canPlacePeers)\n      //\n      // 2. the dep we're TRYING to place here ought to be overridden by the\n      // one that's here now, because current is (a) a direct dep of the\n      // source, or (b) an already-placed peer in a conflicted peer set, or\n      // (c) an already-placed peer in a different peer set at the same level.\n      // If strict or ours, conflict.  Otherwise, keep.\n\n\n      if (isSource) {\n        // check to see if the current module could go deeper in the tree\n        let canReplace = true; // only do this check when we're placing peers.  when we're placing\n        // the original in the source, we know that the edge from the source\n        // is the thing we're trying to place, so its peer set will need to be\n        // placed here as well.  the virtualRoot already has the appropriate\n        // overrides applied.\n\n        if (peerEntryEdge) {\n          const currentPeerSet = getPeerSet(current); // We are effectively replacing currentPeerSet with newPeerSet\n          // If there are any non-peer deps coming into the currentPeerSet,\n          // which are currently valid, and are from the target, then that\n          // means that we have to ensure that they're not going to be made\n          // invalid by putting the newPeerSet in place.\n          // If the edge comes from somewhere deeper than the target, then\n          // that's fine, because we'll create an invalid edge, detect it,\n          // and duplicate the node further into the tree.\n          // loop through the currentPeerSet checking for valid edges on\n          // the members of the peer set which will be made invalid.\n\n          const targetEdges = new Set();\n\n          for (const p of currentPeerSet) {\n            for (const edge of p.edgesIn) {\n              // edge from within the peerSet, ignore\n              if (currentPeerSet.has(edge.from)) continue; // only care about valid edges from target.\n              // edges from elsewhere can dupe if offended, invalid edges\n              // are already being fixed or will be later.\n\n              if (edge.from !== target || !edge.valid) continue;\n              targetEdges.add(edge);\n            }\n          }\n\n          for (const edge of targetEdges) {\n            // see if we intend to replace this one anyway\n            const rep = dep.parent.children.get(edge.name);\n            const current = edge.to;\n\n            if (!rep) {\n              // this isn't one we're replacing.  but it WAS included in the\n              // peerSet for some reason, so make sure that it's still\n              // ok with the replacements in the new peerSet\n              for (const curEdge of current.edgesOut.values()) {\n                const newRepDep = dep.parent.children.get(curEdge.name);\n\n                if (curEdge.valid && newRepDep && !newRepDep.satisfies(curEdge)) {\n                  canReplace = false;\n                  break;\n                }\n              }\n\n              continue;\n            } // was this replacement already an override of some sort?\n\n\n            const override = [...rep.edgesIn].some(e => !e.valid); // if we have a rep, and it's ok to put in this location, and\n            // it's not already part of an override in the peerSet, then\n            // we can continue with it.\n\n            if (rep.satisfies(edge) && !override) continue; // Otherwise, we cannot replace.\n\n            canReplace = false;\n            break;\n          } // if we're going to be replacing the peerSet, we have to remove\n          // and re-resolve any members of the old peerSet that are not\n          // present in the new one, and which will have invalid edges.\n          // We know that they're not depended upon by the target, or else\n          // they would have caused a conflict, so they'll get landed deeper\n          // in the tree, if possible.\n\n\n          if (canReplace) {\n            let needNesting = false;\n\n            OUTER: for (const node of currentPeerSet) {\n              const rep = dep.parent.children.get(node.name); // has a replacement, already addressed above\n\n              if (rep) continue; // ok, it has been placed here to dedupe, see if it needs to go\n              // back deeper within the tree.\n\n              for (const edge of node.edgesOut.values()) {\n                const repDep = dep.parent.children.get(edge.name); // not in new peerSet, maybe fine.\n\n                if (!repDep) continue; // new thing will be fine, no worries\n\n                if (repDep.satisfies(edge)) continue; // uhoh, we'll have to nest them.\n\n                needNesting = true;\n                break OUTER;\n              }\n            } // to nest, just delete everything without a target dep\n            // that's in the current peerSet, and add their dependants\n            // to the _depsQueue for evaluation.  Some of these MAY end\n            // up in the same location again, and that's fine.\n\n\n            if (needNesting) {\n              // avoid mutating the tree while we're examining it\n              const dependants = new Set();\n              const reresolve = new Set();\n\n              OUTER: for (const node of currentPeerSet) {\n                const rep = dep.parent.children.get(node.name);\n                if (rep) continue; // create a separate set for each one, so we can skip any\n                // that might somehow have an incoming target edge\n\n                const deps = new Set();\n\n                for (const edge of node.edgesIn) {\n                  // a target dep, skip this dep entirely, already addressed\n                  // ignoring for coverage, because it really ought to be\n                  // impossible, but I can't prove it yet, so this is here\n                  // for safety.\n\n                  /* istanbul ignore if - should be impossible */\n                  if (edge.from === target) continue OUTER; // ignore this edge, it'll either be replaced or re-resolved\n\n                  if (currentPeerSet.has(edge.from)) continue; // ok, we care about this one.\n\n                  deps.add(edge.from);\n                }\n\n                reresolve.add(node);\n\n                for (const d of deps) dependants.add(d);\n              }\n\n              for (const dependant of dependants) {\n                this[_depsQueue].push(dependant);\n\n                this[_depsSeen].delete(dependant);\n              }\n\n              for (const node of reresolve) node.root = null;\n            }\n          }\n        }\n\n        if (canReplace) {\n          const ret = this[_canPlacePeers](dep, target, edge, REPLACE, peerEntryEdge, peerPath, isSource);\n          /* istanbul ignore else - extremely rare that the peer set would\n           * conflict if we can replace the node in question, but theoretically\n           * possible, if peer deps are pinned aggressively. */\n\n\n          if (ret !== CONFLICT) return ret;\n        } // so it's not a deeper dep that's been deduped.  That means that the\n        // only way it could have ended up here is if it's a conflicted peer.\n\n        /* istanbul ignore else - would have already crashed if not forced,\n         * and either mine or strict, when creating the peerSet.  Keeping this\n         * check so that we're not only relying on action at a distance. */\n\n\n        if (!this[_strictPeerDeps] && !isMine || this[_force]) {\n          this[_warnPeerConflict](edge, dep);\n\n          return KEEP;\n        }\n      } // no justification for overriding, and no agreement possible.\n\n\n      return CONFLICT;\n    } // no existing node at this location!\n    // check to see if the target doesn't have a child by that name,\n    // but WANTS one, and won't be happy with this one.  if this is the\n    // edge we're looking to resolve, then not relevant, of course.\n\n\n    if (target !== entryEdge.from && target.edgesOut.has(dep.name)) {\n      const targetEdge = target.edgesOut.get(dep.name); // It might be that the dep would not be valid here, BUT some other\n      // version would.  Could to try to resolve that, but that makes this no\n      // longer a pure synchronous function.  ugh.\n      // This is a pretty unlikely scenario in a normal install, because we\n      // resolve the peer dep set against the parent dependencies, and\n      // presumably they all worked together SOMEWHERE to get published in the\n      // first place, and since we resolve shallower deps before deeper ones,\n      // this can only occur by a child having a peer dep that does not satisfy\n      // the parent.  It can happen if we're doing a deep update limited by\n      // a specific name, however, or if a dep makes an incompatible change\n      // to its peer dep in a non-semver-major version bump, or if the parent\n      // is unbounded in its dependency list.\n\n      if (!targetEdge.satisfiedBy(dep)) return CONFLICT;\n    } // check to see what that name resolves to here, and who may depend on\n    // being able to reach it by crawling up past this parent.  we know\n    // at this point that it's not the target's direct child node.  if it's\n    // a direct dep of the target, we just make the invalid edge and\n    // resolve it later.\n\n\n    const current = target !== entryEdge.from && target.resolve(dep.name);\n\n    if (current) {\n      for (const edge of current.edgesIn.values()) {\n        if (!edge.from.isTop && edge.from.isDescendantOf(target) && edge.valid) {\n          if (!edge.satisfiedBy(dep)) return CONFLICT;\n        }\n      }\n    } // no objections!  ok to place here\n\n\n    return this[_canPlacePeers](dep, target, edge, OK, peerEntryEdge, peerPath, isSource);\n  } // make sure the family of peer deps can live here alongside it.\n  // this doesn't guarantee that THIS solution will be the one we take,\n  // but it does establish that SOME solution exists at this level in\n  // the tree.\n\n\n  [_canPlacePeers](dep, target, edge, ret, peerEntryEdge, peerPath, isSource) {\n    // do not go in cycles when we're resolving a peer group\n    if (!dep.parent || peerEntryEdge && peerPath.includes(dep)) return ret;\n    const entryEdge = peerEntryEdge || edge;\n    peerPath = [...peerPath, dep];\n\n    for (const peerEdge of dep.edgesOut.values()) {\n      if (!peerEdge.peer || !peerEdge.to) continue;\n      const peer = peerEdge.to;\n\n      const canPlacePeer = this[_canPlaceDep](peer, target, peerEdge, entryEdge, peerPath, isSource);\n\n      if (canPlacePeer !== CONFLICT) continue;\n      const current = target.resolve(peer.name);\n      this[_peerConflict] = {\n        peer: peer.explain(peerEdge),\n        current: current && current.explain()\n      };\n      return CONFLICT;\n    }\n\n    return ret;\n  } // go through all the links in the this[_linkNodes] set\n  // for each one:\n  // - if outside the root, ignore it, assume it's fine, it's not our problem\n  // - if a node in the tree already, assign the target to that node.\n  // - if a path under an existing node, then assign that as the fsParent,\n  //   and add it to the _depsQueue\n  //\n  // call buildDepStep if anything was added to the queue, otherwise we're done\n\n\n  [_resolveLinks]() {\n    for (const link of this[_linkNodes]) {\n      this[_linkNodes].delete(link); // link we never ended up placing, skip it\n\n\n      if (link.root !== this.idealTree) continue;\n      const tree = this.idealTree.target;\n      const external = !link.target.isDescendantOf(tree); // outside the root, somebody else's problem, ignore it\n\n      if (external && !this[_follow]) continue; // didn't find a parent for it or it has not been seen yet\n      // so go ahead and process it.\n\n      const unseenLink = (link.target.parent || link.target.fsParent) && !this[_depsSeen].has(link.target);\n\n      if (this[_follow] && !link.target.parent && !link.target.fsParent || unseenLink) {\n        this.addTracker('idealTree', link.target.name, link.target.location);\n\n        this[_depsQueue].push(link.target);\n      }\n    }\n\n    if (this[_depsQueue].length) return this[_buildDepStep]();\n  }\n\n  [_fixDepFlags]() {\n    process.emit('time', 'idealTree:fixDepFlags');\n    const metaFromDisk = this.idealTree.meta.loadedFromDisk;\n    const flagsSuspect = this[_flagsSuspect];\n    const mutateTree = this[_mutateTree]; // if the options set prune:false, then we don't prune, but we still\n    // mark the extraneous items in the tree if we modified it at all.\n    // If we did no modifications, we just iterate over the extraneous nodes.\n    // if we started with an empty tree, then the dep flags are already\n    // all set to true, and there can be nothing extraneous, so there's\n    // nothing to prune, because we built it from scratch.  if we didn't\n    // add or remove anything, then also nothing to do.\n\n    if (metaFromDisk && mutateTree) resetDepFlags(this.idealTree); // update all the dev/optional/etc flags in the tree\n    // either we started with a fresh tree, or we\n    // reset all the flags to find the extraneous nodes.\n    //\n    // if we started from a blank slate, or changed something, then\n    // the dep flags will be all set to true.\n\n    if (!metaFromDisk || mutateTree) calcDepFlags(this.idealTree);else {\n      // otherwise just unset all the flags on the root node\n      // since they will sometimes have the default value\n      this.idealTree.extraneous = false;\n      this.idealTree.dev = false;\n      this.idealTree.optional = false;\n      this.idealTree.devOptional = false;\n      this.idealTree.peer = false;\n    } // at this point, any node marked as extraneous should be pruned.\n    // if we started from a shrinkwrap, and then added/removed something,\n    // then the tree is suspect.  Prune what is marked as extraneous.\n    // otherwise, don't bother.\n\n    const needPrune = metaFromDisk && (mutateTree || flagsSuspect);\n    if (this[_prune] && needPrune) this[_idealTreePrune]();\n    process.emit('timeEnd', 'idealTree:fixDepFlags');\n  }\n\n  [_idealTreePrune]() {\n    for (const node of this.idealTree.inventory.filter(n => n.extraneous)) node.parent = null;\n  }\n\n  [_pruneFailedOptional]() {\n    for (const node of this[_loadFailures]) {\n      if (!node.optional) throw node.errors[0];\n      const set = optionalSet(node);\n\n      for (const node of set) node.parent = null;\n    }\n  }\n\n};","map":{"version":3,"sources":["/Users/johndoe/Nebe-data-vistualization/node_modules/npm/node_modules/@npmcli/arborist/lib/arborist/build-ideal-tree.js"],"names":["rpj","require","npa","pacote","cacache","semver","promiseCallLimit","getPeerSet","realpath","resolve","dirname","promisify","treeCheck","readdir","debug","fromPath","calcDepFlags","Shrinkwrap","Node","Link","addRmPkgDeps","gatherDepSet","optionalSet","checkEngine","checkPlatform","CONFLICT","Symbol","OK","KEEP","REPLACE","relpath","_complete","_depsSeen","_depsQueue","_currentDep","_updateAll","_mutateTree","_flagsSuspect","for","_workspaces","_prune","_preferDedupe","_pruneDedupable","_legacyBundling","_parseSettings","_initTree","_applyUserRequests","_applyUserRequestsToNode","_inflateAncientLockfile","_buildDeps","_buildDepStep","_nodeFromEdge","_nodeFromSpec","_fetchManifest","_problemEdges","_manifests","_loadWorkspaces","_linkFromSpec","_loadPeerSet","_updateNames","_placeDep","_canPlaceDep","_canPlacePeers","_pruneForReplacement","_fixDepFlags","_resolveLinks","_rootNodeFromPackage","_add","_resolvedAdd","_queueNamedUpdates","_queueVulnDependents","_avoidRange","_shouldUpdateNode","resetDepFlags","_loadFailures","_pruneFailedOptional","_linkNodes","_follow","_globalStyle","_globalRootNode","_isVulnerable","_usePackageLock","_rpcache","_stcache","_updateFilePath","_followSymlinkPath","_getRelpathSpec","_retrieveSpecName","_strictPeerDeps","_checkEngineAndPlatform","_checkEngine","_checkPlatform","_virtualRoots","_virtualRoot","_peerConflict","_failPeerConflict","_explainPeerConflict","_warnPeerConflict","_edgesOverridden","_peerSetSource","_force","_explicitRequests","_global","_idealTreePrune","module","exports","cls","IdealTreeBuilder","constructor","options","registry","replace","idealTree","global","follow","globalStyle","legacyPeerDeps","force","packageLock","strictPeerDeps","workspaces","length","Error","Set","Map","WeakMap","explicitRequests","buildIdealTree","Promise","add","rm","process","emit","update","er","reject","addTracker","finishTracker","then","node","inventory","values","optional","package","engineStrict","npmVersion","nodeVersion","c","log","warn","code","message","pkgid","required","current","all","Array","isArray","names","complete","preferDedupe","legacyBundling","prune","path","pkg","root","reset","meta","Object","assign","loadVirtual","loadedFromDisk","loadActual","tree","target","children","size","virtualTree","dependencies","real","Cls","extraneous","dev","devOptional","peer","isLink","workspaceNodes","map","globalExplicitUpdateNames","nm","name","catch","updateName","includes","push","auditReport","from","action","spec","edgesOut","get","saveType","saveBundle","rawSpec","isTag","type","mani","manifest","version","fetchSpec","filepath","vuln","nodes","bundler","getBundler","location","edge","edgesIn","topVulns","nodesTouched","topVuln","entries","simpleRange","topNodes","fixAvailable","isProjectRoot","isWorkspace","isSemVerMajor","breakingMessage","isVulnerable","range","set","filter","n","isTop","inDepBundle","inShrinkwrap","ancient","ancientLockfile","old","originalLockfileVersion","heading","queue","silly","resolved","integrity","useResolved","startsWith","id","sloc","substr","t","fullMetadata","_id","warning","sort","a","b","depth","localeCompare","shift","bd","bundleDependencies","hasBundle","hasShrinkwrap","has","crackOpen","Arborist","opt","tmp","withTmp","cache","extract","ignoreMissing","tasks","peerSource","source","virtualRoot","vrEdge","vrDep","valid","to","parent","dep","satisfies","placed","promises","e","parent_","secondEdge","realParent","resolveParent","first","spec2","second","p","matches","src","sourceReference","reuse","vr","child","bundled","avoid","checkYarnLock","raw","error","requiredBy","link","peerEdges","parentEdge","isMine","conflictOK","canReplace","currentEdge","expl","curNode","pc","explain","peerConflict","peerEntryEdge","peerPath","start","canPlace","isSource","check","checkEdge","cp","description","newDep","errors","oldChild","oldDeps","edgeIn","invalid","delete","query","isDescendantOf","peerEdge","peerPlaced","descend","canDedupe","nodeSort","fsChildren","topNode","invalidDeps","deps","entryEdge","curVer","newVer","tryReplace","gte","res","satisfiedBy","currentPeerSet","targetEdges","rep","curEdge","newRepDep","override","some","needNesting","OUTER","repDep","dependants","reresolve","d","dependant","ret","targetEdge","canPlacePeer","external","unseenLink","fsParent","metaFromDisk","flagsSuspect","mutateTree","needPrune"],"mappings":"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","sourcesContent":["// mixin implementing the buildIdealTree method\nconst rpj = require('read-package-json-fast')\nconst npa = require('npm-package-arg')\nconst pacote = require('pacote')\nconst cacache = require('cacache')\nconst semver = require('semver')\nconst promiseCallLimit = require('promise-call-limit')\nconst getPeerSet = require('../peer-set.js')\nconst realpath = require('../../lib/realpath.js')\nconst { resolve, dirname } = require('path')\nconst { promisify } = require('util')\nconst treeCheck = require('../tree-check.js')\nconst readdir = promisify(require('readdir-scoped-modules'))\n\nconst debug = require('../debug.js')\nconst fromPath = require('../from-path.js')\nconst calcDepFlags = require('../calc-dep-flags.js')\nconst Shrinkwrap = require('../shrinkwrap.js')\nconst Node = require('../node.js')\nconst Link = require('../link.js')\nconst addRmPkgDeps = require('../add-rm-pkg-deps.js')\nconst gatherDepSet = require('../gather-dep-set.js')\nconst optionalSet = require('../optional-set.js')\nconst {checkEngine, checkPlatform} = require('npm-install-checks')\n\n// enum of return values for canPlaceDep.\n// No, this is a conflict, you may not put that package here\nconst CONFLICT = Symbol('CONFLICT')\n// Yes, this is fine, and should not be a problem\nconst OK = Symbol('OK')\n// No need, because the package already here is fine\nconst KEEP = Symbol('KEEP')\n// Yes, clobber the package that is already here\nconst REPLACE = Symbol('REPLACE')\n\nconst relpath = require('../relpath.js')\n\n// note: some of these symbols are shared so we can hit\n// them with unit tests and reuse them across mixins\nconst _complete = Symbol('complete')\nconst _depsSeen = Symbol('depsSeen')\nconst _depsQueue = Symbol('depsQueue')\nconst _currentDep = Symbol('currentDep')\nconst _updateAll = Symbol('updateAll')\nconst _mutateTree = Symbol('mutateTree')\nconst _flagsSuspect = Symbol.for('flagsSuspect')\nconst _workspaces = Symbol.for('workspaces')\nconst _prune = Symbol('prune')\nconst _preferDedupe = Symbol('preferDedupe')\nconst _pruneDedupable = Symbol('pruneDedupable')\nconst _legacyBundling = Symbol('legacyBundling')\nconst _parseSettings = Symbol('parseSettings')\nconst _initTree = Symbol('initTree')\nconst _applyUserRequests = Symbol('applyUserRequests')\nconst _applyUserRequestsToNode = Symbol('applyUserRequestsToNode')\nconst _inflateAncientLockfile = Symbol('inflateAncientLockfile')\nconst _buildDeps = Symbol('buildDeps')\nconst _buildDepStep = Symbol('buildDepStep')\nconst _nodeFromEdge = Symbol('nodeFromEdge')\nconst _nodeFromSpec = Symbol('nodeFromSpec')\nconst _fetchManifest = Symbol('fetchManifest')\nconst _problemEdges = Symbol('problemEdges')\nconst _manifests = Symbol('manifests')\nconst _loadWorkspaces = Symbol.for('loadWorkspaces')\nconst _linkFromSpec = Symbol('linkFromSpec')\nconst _loadPeerSet = Symbol('loadPeerSet')\nconst _updateNames = Symbol.for('updateNames')\nconst _placeDep = Symbol.for('placeDep')\nconst _canPlaceDep = Symbol.for('canPlaceDep')\nconst _canPlacePeers = Symbol('canPlacePeers')\nconst _pruneForReplacement = Symbol('pruneForReplacement')\nconst _fixDepFlags = Symbol('fixDepFlags')\nconst _resolveLinks = Symbol('resolveLinks')\nconst _rootNodeFromPackage = Symbol('rootNodeFromPackage')\nconst _add = Symbol('add')\nconst _resolvedAdd = Symbol.for('resolvedAdd')\nconst _queueNamedUpdates = Symbol('queueNamedUpdates')\nconst _queueVulnDependents = Symbol('queueVulnDependents')\nconst _avoidRange = Symbol('avoidRange')\nconst _shouldUpdateNode = Symbol('shouldUpdateNode')\nconst resetDepFlags = require('../reset-dep-flags.js')\nconst _loadFailures = Symbol('loadFailures')\nconst _pruneFailedOptional = Symbol('pruneFailedOptional')\nconst _linkNodes = Symbol('linkNodes')\nconst _follow = Symbol('follow')\nconst _globalStyle = Symbol('globalStyle')\nconst _globalRootNode = Symbol('globalRootNode')\nconst _isVulnerable = Symbol.for('isVulnerable')\nconst _usePackageLock = Symbol.for('usePackageLock')\nconst _rpcache = Symbol.for('realpathCache')\nconst _stcache = Symbol.for('statCache')\nconst _updateFilePath = Symbol('updateFilePath')\nconst _followSymlinkPath = Symbol('followSymlinkPath')\nconst _getRelpathSpec = Symbol('getRelpathSpec')\nconst _retrieveSpecName = Symbol('retrieveSpecName')\nconst _strictPeerDeps = Symbol('strictPeerDeps')\nconst _checkEngineAndPlatform = Symbol('checkEngineAndPlatform')\nconst _checkEngine = Symbol('checkEngine')\nconst _checkPlatform = Symbol('checkPlatform')\nconst _virtualRoots = Symbol('virtualRoots')\nconst _virtualRoot = Symbol('virtualRoot')\n\n// used for the ERESOLVE error to show the last peer conflict encountered\nconst _peerConflict = Symbol('peerConflict')\n\nconst _failPeerConflict = Symbol('failPeerConflict')\nconst _explainPeerConflict = Symbol('explainPeerConflict')\nconst _warnPeerConflict = Symbol('warnPeerConflict')\nconst _edgesOverridden = Symbol('edgesOverridden')\n// exposed symbol for unit testing the placeDep method directly\nconst _peerSetSource = Symbol.for('peerSetSource')\n\n// used by Reify mixin\nconst _force = Symbol.for('force')\nconst _explicitRequests = Symbol('explicitRequests')\nconst _global = Symbol.for('global')\nconst _idealTreePrune = Symbol.for('idealTreePrune')\n\nmodule.exports = cls => class IdealTreeBuilder extends cls {\n  constructor (options) {\n    super(options)\n\n    // normalize trailing slash\n    const registry = options.registry || 'https://registry.npmjs.org'\n    options.registry = this.registry = registry.replace(/\\/+$/, '') + '/'\n\n    const {\n      idealTree = null,\n      global = false,\n      follow = false,\n      globalStyle = false,\n      legacyPeerDeps = false,\n      force = false,\n      packageLock = true,\n      strictPeerDeps = false,\n      workspaces = [],\n    } = options\n\n    this[_workspaces] = workspaces || []\n    this[_force] = !!force\n    this[_strictPeerDeps] = !!strictPeerDeps\n\n    this.idealTree = idealTree\n    this.legacyPeerDeps = legacyPeerDeps\n\n    this[_usePackageLock] = packageLock\n    this[_global] = !!global\n    this[_globalStyle] = this[_global] || globalStyle\n    this[_follow] = !!follow\n\n    if (this[_workspaces].length && this[_global])\n      throw new Error('Cannot operate on workspaces in global mode')\n\n    this[_explicitRequests] = new Set()\n    this[_preferDedupe] = false\n    this[_legacyBundling] = false\n    this[_depsSeen] = new Set()\n    this[_depsQueue] = []\n    this[_currentDep] = null\n    this[_updateNames] = []\n    this[_updateAll] = false\n    this[_mutateTree] = false\n    this[_loadFailures] = new Set()\n    this[_linkNodes] = new Set()\n    this[_manifests] = new Map()\n    this[_peerConflict] = null\n    this[_edgesOverridden] = new Set()\n    this[_resolvedAdd] = []\n\n    // a map of each module in a peer set to the thing that depended on\n    // that set of peers in the first place.  Use a WeakMap so that we\n    // don't hold onto references for nodes that are garbage collected.\n    this[_peerSetSource] = new WeakMap()\n    this[_virtualRoots] = new Map()\n  }\n\n  get explicitRequests () {\n    return new Set(this[_explicitRequests])\n  }\n\n  // public method\n  async buildIdealTree (options = {}) {\n    if (this.idealTree)\n      return Promise.resolve(this.idealTree)\n\n    // allow the user to set reify options on the ctor as well.\n    // XXX: deprecate separate reify() options object.\n    options = { ...this.options, ...options }\n\n    // an empty array or any falsey value is the same as null\n    if (!options.add || options.add.length === 0)\n      options.add = null\n    if (!options.rm || options.rm.length === 0)\n      options.rm = null\n\n    process.emit('time', 'idealTree')\n\n    if (!options.add && !options.rm && !options.update && this[_global]) {\n      const er = new Error('global requires add, rm, or update option')\n      return Promise.reject(er)\n    }\n\n    // first get the virtual tree, if possible.  If there's a lockfile, then\n    // that defines the ideal tree, unless the root package.json is not\n    // satisfied by what the ideal tree provides.\n    // from there, we start adding nodes to it to satisfy the deps requested\n    // by the package.json in the root.\n\n    this[_parseSettings](options)\n\n    // start tracker block\n    this.addTracker('idealTree')\n\n    try {\n      await this[_initTree]()\n      await this[_inflateAncientLockfile]()\n      await this[_applyUserRequests](options)\n      await this[_buildDeps]()\n      await this[_fixDepFlags]()\n      await this[_pruneFailedOptional]()\n      await this[_checkEngineAndPlatform]()\n    } finally {\n      process.emit('timeEnd', 'idealTree')\n      this.finishTracker('idealTree')\n    }\n\n    return treeCheck(this.idealTree)\n  }\n\n  [_checkEngineAndPlatform] () {\n    // engine/platform checks throw, so start the promise chain off first\n    return Promise.resolve()\n      .then(() => {\n        for (const node of this.idealTree.inventory.values()) {\n          if (!node.optional) {\n            this[_checkEngine](node)\n            this[_checkPlatform](node)\n          }\n        }\n      })\n  }\n\n  [_checkPlatform] (node) {\n    checkPlatform(node.package, this[_force])\n  }\n\n  [_checkEngine] (node) {\n    const { engineStrict, npmVersion, nodeVersion } = this.options\n    const c = () => checkEngine(node.package, npmVersion, nodeVersion, this[_force])\n\n    if (engineStrict)\n      c()\n    else {\n      try {\n        c()\n      } catch (er) {\n        this.log.warn(er.code, er.message, {\n          package: er.pkgid,\n          required: er.required,\n          current: er.current,\n        })\n      }\n    }\n  }\n\n  [_parseSettings] (options) {\n    const update = options.update === true ? { all: true }\n      : Array.isArray(options.update) ? { names: options.update }\n      : options.update || {}\n\n    if (update.all || !Array.isArray(update.names))\n      update.names = []\n\n    this[_complete] = !!options.complete\n    this[_preferDedupe] = !!options.preferDedupe\n    this[_legacyBundling] = !!options.legacyBundling\n    this[_updateNames] = update.names\n\n    this[_updateAll] = update.all\n    // we prune by default unless explicitly set to boolean false\n    this[_prune] = options.prune !== false\n\n    // set if we add anything, but also set here if we know we'll make\n    // changes and thus have to maybe prune later.\n    this[_mutateTree] = !!(\n      options.add ||\n      options.rm ||\n      update.all ||\n      update.names.length\n    )\n  }\n\n  // load the initial tree, either the virtualTree from a shrinkwrap,\n  // or just the root node from a package.json\n  [_initTree] () {\n    process.emit('time', 'idealTree:init')\n    return (\n      this[_global] ? this[_globalRootNode]()\n      : rpj(this.path + '/package.json').then(\n        pkg => this[_rootNodeFromPackage](pkg),\n        er => {\n          if (er.code === 'EJSONPARSE')\n            throw er\n          return this[_rootNodeFromPackage]({})\n        }\n      ))\n      .then(root => this[_loadWorkspaces](root))\n      // ok to not have a virtual tree.  probably initial install.\n      // When updating all, we load the shrinkwrap, but don't bother\n      // to build out the full virtual tree from it, since we'll be\n      // reconstructing it anyway.\n      .then(root => this[_global] ? root\n      : !this[_usePackageLock] || this[_updateAll]\n        ? Shrinkwrap.reset({ path: this.path })\n          .then(meta => Object.assign(root, {meta}))\n        : this.loadVirtual({ root }))\n\n      // if we don't have a lockfile to go from, then start with the\n      // actual tree, so we only make the minimum required changes.\n      // don't do this for global installs or updates, because in those\n      // cases we don't use a lockfile anyway.\n      // Load on a new Arborist object, so the Nodes aren't the same,\n      // or else it'll get super confusing when we change them!\n      .then(async root => {\n        if (!this[_updateAll] && !this[_global] && !root.meta.loadedFromDisk) {\n          await new this.constructor(this.options).loadActual({ root })\n          const tree = root.target\n          // even though we didn't load it from a package-lock.json FILE,\n          // we still loaded it \"from disk\", meaning we have to reset\n          // dep flags before assuming that any mutations were reflected.\n          if (tree.children.size)\n            root.meta.loadedFromDisk = true\n        }\n        return root\n      })\n\n      .then(tree => {\n        // null the virtual tree, because we're about to hack away at it\n        // if you want another one, load another copy.\n        this.idealTree = tree\n        this.virtualTree = null\n        process.emit('timeEnd', 'idealTree:init')\n      })\n  }\n\n  async [_globalRootNode] () {\n    const root = await this[_rootNodeFromPackage]({ dependencies: {} })\n    // this is a gross kludge to handle the fact that we don't save\n    // metadata on the root node in global installs, because the \"root\"\n    // node is something like /usr/local/lib.\n    const meta = new Shrinkwrap({ path: this.path })\n    meta.reset()\n    root.meta = meta\n    return root\n  }\n\n  async [_rootNodeFromPackage] (pkg) {\n    // if the path doesn't exist, then we explode at this point. Note that\n    // this is not a problem for reify(), since it creates the root path\n    // before ever loading trees.\n    // TODO: make buildIdealTree() and loadActual handle a missing root path,\n    // or a symlink to a missing target, and let reify() create it as needed.\n    const real = await realpath(this.path, this[_rpcache], this[_stcache])\n    const Cls = real === this.path ? Node : Link\n    const root = new Cls({\n      path: this.path,\n      realpath: real,\n      pkg,\n      extraneous: false,\n      dev: false,\n      devOptional: false,\n      peer: false,\n      optional: false,\n      global: this[_global],\n      legacyPeerDeps: this.legacyPeerDeps,\n    })\n    if (root.isLink) {\n      root.target = new Node({\n        path: real,\n        realpath: real,\n        pkg,\n        extraneous: false,\n        dev: false,\n        devOptional: false,\n        peer: false,\n        optional: false,\n        global: this[_global],\n        legacyPeerDeps: this.legacyPeerDeps,\n        root,\n      })\n    }\n    return root\n  }\n\n  // process the add/rm requests by modifying the root node, and the\n  // update.names request by queueing nodes dependent on those named.\n  async [_applyUserRequests] (options) {\n    process.emit('time', 'idealTree:userRequests')\n    const tree = this.idealTree.target\n\n    if (!this[_workspaces].length)\n      await this[_applyUserRequestsToNode](tree, options)\n    else {\n      await Promise.all(this.workspaceNodes(tree, this[_workspaces])\n        .map(node => this[_applyUserRequestsToNode](node, options)))\n    }\n\n    process.emit('timeEnd', 'idealTree:userRequests')\n  }\n\n  async [_applyUserRequestsToNode] (tree, options) {\n    // If we have a list of package names to update, and we know it's\n    // going to update them wherever they are, add any paths into those\n    // named nodes to the buildIdealTree queue.\n    if (!this[_global] && this[_updateNames].length)\n      this[_queueNamedUpdates]()\n\n    // global updates only update the globalTop nodes, but we need to know\n    // that they're there, and not reinstall the world unnecessarily.\n    const globalExplicitUpdateNames = []\n    if (this[_global] && (this[_updateAll] || this[_updateNames].length)) {\n      const nm = resolve(this.path, 'node_modules')\n      for (const name of await readdir(nm).catch(() => [])) {\n        tree.package.dependencies = tree.package.dependencies || {}\n        const updateName = this[_updateNames].includes(name)\n        if (this[_updateAll] || updateName) {\n          if (updateName)\n            globalExplicitUpdateNames.push(name)\n          tree.package.dependencies[name] = '*'\n        }\n      }\n    }\n\n    if (this.auditReport && this.auditReport.size > 0)\n      await this[_queueVulnDependents](options)\n\n    const { add, rm } = options\n\n    if (rm && rm.length) {\n      addRmPkgDeps.rm(tree.package, rm)\n      for (const name of rm)\n        this[_explicitRequests].add({ from: tree, name, action: 'DELETE' })\n    }\n\n    if (add && add.length)\n      await this[_add](tree, options)\n\n    // triggers a refresh of all edgesOut.  this has to be done BEFORE\n    // adding the edges to explicitRequests, because the package setter\n    // resets all edgesOut.\n    if (add && add.length || rm && rm.length || this[_global])\n      tree.package = tree.package\n\n    for (const spec of this[_resolvedAdd]) {\n      if (spec.tree === tree)\n        this[_explicitRequests].add(tree.edgesOut.get(spec.name))\n    }\n    for (const name of globalExplicitUpdateNames)\n      this[_explicitRequests].add(tree.edgesOut.get(name))\n\n    this[_depsQueue].push(tree)\n  }\n\n  // This returns a promise because we might not have the name yet,\n  // and need to call pacote.manifest to find the name.\n  [_add] (tree, {add, saveType = null, saveBundle = false}) {\n    // get the name for each of the specs in the list.\n    // ie, doing `foo@bar` we just return foo\n    // but if it's a url or git, we don't know the name until we\n    // fetch it and look in its manifest.\n    return Promise.all(add.map(async rawSpec => {\n      // We do NOT provide the path to npa here, because user-additions\n      // need to be resolved relative to the CWD the user is in.\n      const spec = await this[_retrieveSpecName](npa(rawSpec))\n        .then(spec => this[_updateFilePath](spec))\n        .then(spec => this[_followSymlinkPath](spec))\n      spec.tree = tree\n      return spec\n    })).then(add => {\n      this[_resolvedAdd].push(...add)\n      // now add is a list of spec objects with names.\n      // find a home for each of them!\n      addRmPkgDeps.add({\n        pkg: tree.package,\n        add,\n        saveBundle,\n        saveType,\n        path: this.path,\n        log: this.log,\n      })\n    })\n  }\n\n  async [_retrieveSpecName] (spec) {\n    // if it's just @'' then we reload whatever's there, or get latest\n    // if it's an explicit tag, we need to install that specific tag version\n    const isTag = spec.rawSpec && spec.type === 'tag'\n\n    if (spec.name && !isTag)\n      return spec\n\n    const mani = await pacote.manifest(spec, { ...this.options })\n    // if it's a tag type, then we need to run it down to an actual version\n    if (isTag)\n      return npa(`${mani.name}@${mani.version}`)\n\n    spec.name = mani.name\n    return spec\n  }\n\n  async [_updateFilePath] (spec) {\n    if (spec.type === 'file')\n      return this[_getRelpathSpec](spec, spec.fetchSpec)\n\n    return spec\n  }\n\n  async [_followSymlinkPath] (spec) {\n    if (spec.type === 'directory') {\n      const real = await (\n        realpath(spec.fetchSpec, this[_rpcache], this[_stcache])\n          // TODO: create synthetic test case to simulate realpath failure\n          .catch(/* istanbul ignore next */() => null)\n      )\n\n      return this[_getRelpathSpec](spec, real)\n    }\n    return spec\n  }\n\n  [_getRelpathSpec] (spec, filepath) {\n    /* istanbul ignore else - should also be covered by realpath failure */\n    if (filepath) {\n      const { name } = spec\n      const tree = this.idealTree.target\n      spec = npa(`file:${relpath(tree.path, filepath)}`, tree.path)\n      spec.name = name\n    }\n    return spec\n  }\n\n  // TODO: provide a way to fix bundled deps by exposing metadata about\n  // what's in the bundle at each published manifest.  Without that, we\n  // can't possibly fix bundled deps without breaking a ton of other stuff,\n  // and leaving the user subject to getting it overwritten later anyway.\n  async [_queueVulnDependents] (options) {\n    for (const vuln of this.auditReport.values()) {\n      for (const node of vuln.nodes) {\n        const bundler = node.getBundler()\n\n        // XXX this belongs in the audit report itself, not here.\n        // We shouldn't even get these things here, and they shouldn't\n        // be printed by npm-audit-report as if they can be fixed, because\n        // they can't.\n        if (bundler) {\n          this.log.warn(`audit fix ${node.name}@${node.version}`,\n            `${node.location}\\nis a bundled dependency of\\n${\n            bundler.name}@${bundler.version} at ${bundler.location}\\n` +\n            'It cannot be fixed automatically.\\n' +\n            `Check for updates to the ${bundler.name} package.`)\n          continue\n        }\n\n        for (const edge of node.edgesIn) {\n          this.addTracker('idealTree', edge.from.name, edge.from.location)\n          this[_depsQueue].push(edge.from)\n        }\n      }\n    }\n\n    // note any that can't be fixed at the root level without --force\n    // if there's a fix, we use that.  otherwise, the user has to remove it,\n    // find a different thing, fix the upstream, etc.\n    //\n    // XXX: how to handle top nodes that aren't the root?  Maybe the report\n    // just tells the user to cd into that directory and fix it?\n    if (this[_force] && this.auditReport && this.auditReport.topVulns.size) {\n      options.add = options.add || []\n      options.rm = options.rm || []\n      const nodesTouched = new Set()\n      for (const [name, topVuln] of this.auditReport.topVulns.entries()) {\n        const {\n          simpleRange,\n          topNodes,\n          fixAvailable,\n        } = topVuln\n        for (const node of topNodes) {\n          if (!node.isProjectRoot && !node.isWorkspace) {\n            // not something we're going to fix, sorry.  have to cd into\n            // that directory and fix it yourself.\n            this.log.warn('audit', 'Manual fix required in linked project ' +\n              `at ./${node.location} for ${name}@${simpleRange}.\\n` +\n              `'cd ./${node.location}' and run 'npm audit' for details.`)\n            continue\n          }\n\n          if (!fixAvailable) {\n            this.log.warn('audit', `No fix available for ${name}@${simpleRange}`)\n            continue\n          }\n\n          const { isSemVerMajor, version } = fixAvailable\n          const breakingMessage = isSemVerMajor\n            ? 'a SemVer major change'\n            : 'outside your stated dependency range'\n          this.log.warn('audit', `Updating ${name} to ${version},` +\n            `which is ${breakingMessage}.`)\n\n          await this[_add](node, { add: [`${name}@${version}`] })\n          nodesTouched.add(node)\n        }\n      }\n      for (const node of nodesTouched)\n        node.package = node.package\n    }\n  }\n\n  [_isVulnerable] (node) {\n    return this.auditReport && this.auditReport.isVulnerable(node)\n  }\n\n  [_avoidRange] (name) {\n    if (!this.auditReport)\n      return null\n    const vuln = this.auditReport.get(name)\n    if (!vuln)\n      return null\n    return vuln.range\n  }\n\n  [_queueNamedUpdates] () {\n    // ignore top nodes, since they are not loaded the same way, and\n    // probably have their own project associated with them.\n\n    // for every node with one of the names on the list, we add its\n    // dependents to the queue to be evaluated.  in buildDepStep,\n    // anything on the update names list will get refreshed, even if\n    // it isn't a problem.\n\n    // XXX this could be faster by doing a series of inventory.query('name')\n    // calls rather than walking over everything in the tree.\n    const set = this.idealTree.inventory\n      .filter(n => this[_shouldUpdateNode](n))\n    for (const node of set) {\n      for (const edge of node.edgesIn) {\n        this.addTracker('idealTree', edge.from.name, edge.from.location)\n        this[_depsQueue].push(edge.from)\n      }\n    }\n  }\n\n  [_shouldUpdateNode] (node) {\n    return this[_updateNames].includes(node.name) &&\n      !node.isTop &&\n      !node.inDepBundle &&\n      !node.inShrinkwrap\n  }\n\n  async [_inflateAncientLockfile] () {\n    const { meta, inventory } = this.idealTree\n    const ancient = meta.ancientLockfile\n    const old = meta.loadedFromDisk && !(meta.originalLockfileVersion >= 2)\n\n    if (inventory.size === 0 || !ancient && !old)\n      return\n\n    // if the lockfile is from node v5 or earlier, then we'll have to reload\n    // all the manifests of everything we encounter.  this is costly, but at\n    // least it's just a one-time hit.\n    process.emit('time', 'idealTree:inflate')\n\n    const heading = ancient ? 'ancient lockfile' : 'old lockfile'\n    this.log.warn(heading,\n      `\nThe ${meta.type} file was created with an old version of npm,\nso supplemental metadata must be fetched from the registry.\n\nThis is a one-time fix-up, please be patient...\n`)\n\n    this.addTracker('idealTree:inflate')\n    const queue = []\n    for (const node of inventory.values()) {\n      if (node.isProjectRoot)\n        continue\n\n      queue.push(async () => {\n        this.log.silly('inflate', node.location)\n        const { resolved, version, path, name, location, integrity } = node\n        // don't try to hit the registry for linked deps\n        const useResolved = resolved && (\n          !version || resolved.startsWith('file:')\n        )\n        const id = useResolved ? resolved\n          : version || `file:${node.path}`\n        const spec = npa.resolve(name, id, dirname(path))\n        const sloc = location.substr('node_modules/'.length)\n        const t = `idealTree:inflate:${sloc}`\n        this.addTracker(t)\n        await pacote.manifest(spec, {\n          ...this.options,\n          resolved: resolved,\n          integrity: integrity,\n          fullMetadata: false,\n        }).then(mani => {\n          node.package = { ...mani, _id: `${mani.name}@${mani.version}` }\n        }).catch((er) => {\n          const warning = `Could not fetch metadata for ${name}@${id}`\n          this.log.warn(heading, warning, er)\n        })\n        this.finishTracker(t)\n      })\n    }\n    await promiseCallLimit(queue)\n\n    // have to re-calc dep flags, because the nodes don't have edges\n    // until their packages get assigned, so everything looks extraneous\n    calcDepFlags(this.idealTree)\n\n    // yes, yes, this isn't the \"original\" version, but now that it's been\n    // upgraded, we need to make sure we don't do the work to upgrade it\n    // again, since it's now as new as can be.\n    meta.originalLockfileVersion = 2\n    this.finishTracker('idealTree:inflate')\n    process.emit('timeEnd', 'idealTree:inflate')\n  }\n\n  // at this point we have a virtual tree with the actual root node's\n  // package deps, which may be partly or entirely incomplete, invalid\n  // or extraneous.\n  [_buildDeps] () {\n    process.emit('time', 'idealTree:buildDeps')\n    const tree = this.idealTree.target\n    this[_depsQueue].push(tree)\n    this.log.silly('idealTree', 'buildDeps')\n    this.addTracker('idealTree', tree.name, '')\n    return this[_buildDepStep]()\n      .then(() => process.emit('timeEnd', 'idealTree:buildDeps'))\n  }\n\n  async [_buildDepStep] () {\n    // removes tracker of previous dependency in the queue\n    if (this[_currentDep]) {\n      const { location, name } = this[_currentDep]\n      process.emit('timeEnd', `idealTree:${location || '#root'}`)\n      this.finishTracker('idealTree', name, location)\n      this[_currentDep] = null\n    }\n\n    if (!this[_depsQueue].length)\n      return this[_resolveLinks]()\n\n    // sort physically shallower deps up to the front of the queue,\n    // because they'll affect things deeper in, then alphabetical\n    this[_depsQueue].sort((a, b) =>\n      (a.depth - b.depth) || a.path.localeCompare(b.path, 'en'))\n\n    const node = this[_depsQueue].shift()\n    const bd = node.package.bundleDependencies\n    const hasBundle = bd && Array.isArray(bd) && bd.length\n    const { hasShrinkwrap } = node\n\n    // if the node was already visited, or has since been removed from the\n    // tree, skip over it and process the rest of the queue.  If a node has\n    // a shrinkwrap, also skip it, because it's going to get its deps\n    // satisfied by whatever's in that file anyway.\n    if (this[_depsSeen].has(node) ||\n        node.root !== this.idealTree ||\n        hasShrinkwrap && !this[_complete])\n      return this[_buildDepStep]()\n\n    this[_depsSeen].add(node)\n    this[_currentDep] = node\n    process.emit('time', `idealTree:${node.location || '#root'}`)\n\n    // if we're loading a _complete_ ideal tree, for a --package-lock-only\n    // installation for example, we have to crack open the tarball and\n    // look inside if it has bundle deps or shrinkwraps.  note that this is\n    // not necessary during a reification, because we just update the\n    // ideal tree by reading bundles/shrinkwraps in place.\n    // Don't bother if the node is from the actual tree and hasn't\n    // been resolved, because we can't fetch it anyway, could be anything!\n    const crackOpen = this[_complete] &&\n      node !== this.idealTree &&\n      node.resolved &&\n      (hasBundle || hasShrinkwrap)\n    if (crackOpen) {\n      const Arborist = this.constructor\n      const opt = { ...this.options }\n      await cacache.tmp.withTmp(this.cache, opt, async path => {\n        await pacote.extract(node.resolved, path, {\n          ...opt,\n          resolved: node.resolved,\n          integrity: node.integrity,\n        })\n\n        if (hasShrinkwrap) {\n          await new Arborist({ ...this.options, path })\n            .loadVirtual({ root: node })\n        }\n\n        if (hasBundle) {\n          await new Arborist({ ...this.options, path })\n            .loadActual({ root: node, ignoreMissing: true })\n        }\n      })\n    }\n\n    // if any deps are missing or invalid, then we fetch the manifest for\n    // the thing we want, and build a new dep node from that.\n    // Then, find the ideal placement for that node.  The ideal placement\n    // searches from the node's deps (or parent deps in the case of non-root\n    // peer deps), and walks up the tree until it finds the highest spot\n    // where it doesn't cause any conflicts.\n    //\n    // A conflict can be:\n    // - A node by that name already exists at that location.\n    // - The parent has a peer dep on that name\n    // - One of the node's peer deps conflicts at that location, unless the\n    //   peer dep is met by a node at that location, which is fine.\n    //\n    // If we create a new node, then build its ideal deps as well.\n    //\n    // Note: this is the same \"maximally naive\" deduping tree-building\n    // algorithm that npm has used since v3.  In a case like this:\n    //\n    // root -> (a@1, b@1||2)\n    // a -> (b@1)\n    //\n    // You'll end up with a tree like this:\n    //\n    // root\n    // +-- a@1\n    // |   +-- b@1\n    // +-- b@2\n    //\n    // rather than this, more deduped, but just as correct tree:\n    //\n    // root\n    // +-- a@1\n    // +-- b@1\n    //\n    // Another way to look at it is that this algorithm favors getting higher\n    // version deps at higher levels in the tree, even if that reduces\n    // potential deduplication.\n    //\n    // Set `preferDedupe: true` in the options to replace the shallower\n    // dep if allowed.\n\n    const tasks = []\n    const peerSource = this[_peerSetSource].get(node) || node\n    for (const edge of this[_problemEdges](node)) {\n      if (this[_edgesOverridden].has(edge))\n        continue\n\n      // peerSetSource is only relevant when we have a peerEntryEdge\n      // otherwise we're setting regular non-peer deps as if they have\n      // a virtual root of whatever brought in THIS node.\n      // so we VR the node itself if the edge is not a peer\n      const source = edge.peer ? peerSource : node\n\n      const virtualRoot = this[_virtualRoot](source, true)\n      // reuse virtual root if we already have one, but don't\n      // try to do the override ahead of time, since we MAY be able\n      // to create a more correct tree than the virtual root could.\n      const vrEdge = virtualRoot && virtualRoot.edgesOut.get(edge.name)\n      const vrDep = vrEdge && vrEdge.valid && vrEdge.to\n      // only re-use the virtualRoot if it's a peer edge we're placing.\n      // otherwise, we end up in situations where we override peer deps that\n      // we could have otherwise found homes for.  Eg:\n      // xy -> (x, y)\n      // x -> PEER(z@1)\n      // y -> PEER(z@2)\n      // If xy is a dependency, we can resolve this like:\n      // project\n      // +-- xy\n      // |   +-- y\n      // |   +-- z@2\n      // +-- x\n      // +-- z@1\n      // But if x and y are loaded in the same virtual root, then they will\n      // be forced to agree on a version of z.\n      const required = new Set([edge.from])\n      const parent = edge.peer ? virtualRoot : null\n      const dep = vrDep && vrDep.satisfies(edge) ? vrDep\n        : await this[_nodeFromEdge](edge, parent, null, required)\n\n      /* istanbul ignore next */\n      debug(() => {\n        if (!dep)\n          throw new Error('no dep??')\n      })\n\n      tasks.push({edge, dep})\n    }\n\n    const placed = tasks\n      .sort((a, b) => a.edge.name.localeCompare(b.edge.name, 'en'))\n      .map(({ edge, dep }) => this[_placeDep](dep, node, edge))\n\n    const promises = []\n    for (const set of placed) {\n      for (const node of set) {\n        this[_mutateTree] = true\n        this.addTracker('idealTree', node.name, node.location)\n        this[_depsQueue].push(node)\n\n        // we're certainly going to need these soon, fetch them asap\n        // if it fails at this point, though, dont' worry because it\n        // may well be an optional dep that has gone missing.  it'll\n        // fail later anyway.\n        const from = fromPath(node)\n        promises.push(...this[_problemEdges](node).map(e =>\n          this[_fetchManifest](npa.resolve(e.name, e.spec, from))\n            .catch(er => null)))\n      }\n    }\n    await Promise.all(promises)\n\n    for (const { to } of node.edgesOut.values()) {\n      if (to && to.isLink && to.target)\n        this[_linkNodes].add(to)\n    }\n\n    return this[_buildDepStep]()\n  }\n\n  // loads a node from an edge, and then loads its peer deps (and their\n  // peer deps, on down the line) into a virtual root parent.\n  async [_nodeFromEdge] (edge, parent_, secondEdge, required) {\n    // create a virtual root node with the same deps as the node that\n    // is requesting this one, so that we can get all the peer deps in\n    // a context where they're likely to be resolvable.\n    // Note that the virtual root will also have virtual copies of the\n    // targets of any child Links, so that they resolve appropriately.\n    const parent = parent_ || this[_virtualRoot](edge.from)\n    const realParent = edge.peer ? edge.from.resolveParent : edge.from\n\n    const spec = npa.resolve(edge.name, edge.spec, edge.from.path)\n    const first = await this[_nodeFromSpec](edge.name, spec, parent, edge)\n\n    // we might have a case where the parent has a peer dependency on\n    // `foo@*` which resolves to v2, but another dep in the set has a\n    // peerDependency on `foo@1`.  In that case, if we force it to be v2,\n    // we're unnecessarily triggering an ERESOLVE.\n    // If we have a second edge to worry about, and it's not satisfied\n    // by the first node, try a second and see if that satisfies the\n    // original edge here.\n    const spec2 = secondEdge && npa.resolve(\n      edge.name,\n      secondEdge.spec,\n      secondEdge.from.path\n    )\n    const second = secondEdge && !secondEdge.valid\n      ? await this[_nodeFromSpec](edge.name, spec2, parent, secondEdge)\n      : null\n\n    // pick the second one if they're both happy with that, otherwise first\n    const node = second && edge.valid ? second : first\n    // ensure the one we want is the one that's placed\n    node.parent = parent\n\n    if (required.has(edge.from) && edge.type !== 'peerOptional' ||\n        secondEdge && (\n          required.has(secondEdge.from) && secondEdge.type !== 'peerOptional'))\n      required.add(node)\n\n    // handle otherwise unresolvable dependency nesting loops by\n    // creating a symbolic link\n    // a1 -> b1 -> a2 -> b2 -> a1 -> ...\n    // instead of nesting forever, when the loop occurs, create\n    // a symbolic link to the earlier instance\n    for (let p = edge.from.resolveParent; p; p = p.resolveParent) {\n      if (p.matches(node) && !p.isTop)\n        return new Link({ parent: realParent, target: p })\n    }\n\n    // keep track of the thing that caused this node to be included.\n    const src = parent.sourceReference\n    this[_peerSetSource].set(node, src)\n    return this[_loadPeerSet](node, required)\n  }\n\n  [_virtualRoot] (node, reuse = false) {\n    if (reuse && this[_virtualRoots].has(node))\n      return this[_virtualRoots].get(node)\n\n    const vr = new Node({\n      path: node.realpath,\n      sourceReference: node,\n      legacyPeerDeps: this.legacyPeerDeps,\n    })\n\n    // also need to set up any targets from any link deps, so that\n    // they are properly reflected in the virtual environment\n    for (const child of node.children.values()) {\n      if (child.isLink) {\n        new Node({\n          path: child.realpath,\n          sourceReference: child.target,\n          root: vr,\n        })\n      }\n    }\n\n    this[_virtualRoots].set(node, vr)\n    return vr\n  }\n\n  [_problemEdges] (node) {\n    // skip over any bundled deps, they're not our problem.\n    // Note that this WILL fetch bundled meta-deps which are also dependencies\n    // but not listed as bundled deps.  When reifying, we first unpack any\n    // nodes that have bundleDependencies, then do a loadActual on them, move\n    // the nodes into the ideal tree, and then prune.  So, fetching those\n    // possibly-bundled meta-deps at this point doesn't cause any worse\n    // problems than a few unnecessary packument fetches.\n\n    // also skip over any nodes in the tree that failed to load, since those\n    // will crash the install later on anyway.\n    const bd = node.isProjectRoot || node.isWorkspace ? null\n      : node.package.bundleDependencies\n    const bundled = new Set(bd || [])\n\n    return [...node.edgesOut.values()]\n      .filter(edge => {\n        // If it's included in a bundle, we take whatever is specified.\n        if (bundled.has(edge.name))\n          return false\n\n        // If it's already been logged as a load failure, skip it.\n        if (edge.to && this[_loadFailures].has(edge.to))\n          return false\n\n        // If it's shrinkwrapped, we use what the shrinkwap wants.\n        if (edge.to && edge.to.inShrinkwrap)\n          return false\n\n        // If the edge has no destination, that's a problem, unless\n        // if it's peerOptional and not explicitly requested.\n        if (!edge.to) {\n          return edge.type !== 'peerOptional' ||\n            this[_explicitRequests].has(edge)\n        }\n\n        // If the edge has an error, there's a problem.\n        if (!edge.valid)\n          return true\n\n        // If user has explicitly asked to update this package by name, it's a problem.\n        if (this[_updateNames].includes(edge.name))\n          return true\n\n        // If we're fixing a security vulnerability with this package, it's a problem.\n        if (this[_isVulnerable](edge.to))\n          return true\n\n        // If the user has explicitly asked to install this package, it's a \"problem\".\n        if (this[_explicitRequests].has(edge))\n          return true\n\n        // No problems!\n        return false\n      })\n  }\n\n  async [_fetchManifest] (spec) {\n    const options = {\n      ...this.options,\n      avoid: this[_avoidRange](spec.name),\n    }\n    // get the intended spec and stored metadata from yarn.lock file,\n    // if available and valid.\n    spec = this.idealTree.meta.checkYarnLock(spec, options)\n\n    if (this[_manifests].has(spec.raw))\n      return this[_manifests].get(spec.raw)\n    else {\n      this.log.silly('fetch manifest', spec.raw)\n      const p = pacote.manifest(spec, options)\n        .then(mani => {\n          this[_manifests].set(spec.raw, mani)\n          return mani\n        })\n      this[_manifests].set(spec.raw, p)\n      return p\n    }\n  }\n\n  [_nodeFromSpec] (name, spec, parent, edge) {\n    // pacote will slap integrity on its options, so we have to clone\n    // the object so it doesn't get mutated.\n    // Don't bother to load the manifest for link deps, because the target\n    // might be within another package that doesn't exist yet.\n    const { legacyPeerDeps } = this\n    return spec.type === 'directory'\n      ? this[_linkFromSpec](name, spec, parent, edge)\n      : this[_fetchManifest](spec)\n        .then(pkg => new Node({ name, pkg, parent, legacyPeerDeps }), error => {\n          error.requiredBy = edge.from.location || '.'\n\n          // failed to load the spec, either because of enotarget or\n          // fetch failure of some other sort.  save it so we can verify\n          // later that it's optional, otherwise the error is fatal.\n          const n = new Node({\n            name,\n            parent,\n            error,\n            legacyPeerDeps,\n          })\n          this[_loadFailures].add(n)\n          return n\n        })\n  }\n\n  [_linkFromSpec] (name, spec, parent, edge) {\n    const realpath = spec.fetchSpec\n    const { legacyPeerDeps } = this\n    return rpj(realpath + '/package.json').catch(() => ({})).then(pkg => {\n      const link = new Link({ name, parent, realpath, pkg, legacyPeerDeps })\n      this[_linkNodes].add(link)\n      return link\n    })\n  }\n\n  // load all peer deps and meta-peer deps into the node's parent\n  // At the end of this, the node's peer-type outward edges are all\n  // resolved, and so are all of theirs, but other dep types are not.\n  // We prefer to get peer deps that meet the requiring node's dependency,\n  // if possible, since that almost certainly works (since that package was\n  // developed with this set of deps) and will typically be more restrictive.\n  // Note that the peers in the set can conflict either with each other,\n  // or with a direct dependency from the virtual root parent!  In strict\n  // mode, this is always an error.  In force mode, it never is, and we\n  // prefer the parent's non-peer dep over a peer dep, or the version that\n  // gets placed first.  In non-strict mode, we behave strictly if the\n  // virtual root is based on the root project, and allow non-peer parent\n  // deps to override, but throw if no preference can be determined.\n  async [_loadPeerSet] (node, required) {\n    const peerEdges = [...node.edgesOut.values()]\n      // we typically only install non-optional peers, but we have to\n      // factor them into the peerSet so that we can avoid conflicts\n      .filter(e => e.peer && !(e.valid && e.to))\n      .sort(({name: a}, {name: b}) => a.localeCompare(b, 'en'))\n\n    for (const edge of peerEdges) {\n      // already placed this one, and we're happy with it.\n      if (edge.valid && edge.to)\n        continue\n\n      const parentEdge = node.parent.edgesOut.get(edge.name)\n      const {isProjectRoot, isWorkspace} = node.parent.sourceReference\n      const isMine = isProjectRoot || isWorkspace\n      const conflictOK = this[_force] || !isMine && !this[_strictPeerDeps]\n\n      if (!edge.to) {\n        if (!parentEdge) {\n          // easy, just put the thing there\n          await this[_nodeFromEdge](edge, node.parent, null, required)\n          continue\n        } else {\n          // if the parent's edge is very broad like >=1, and the edge in\n          // question is something like 1.x, then we want to get a 1.x, not\n          // a 2.x.  pass along the child edge as an advisory guideline.\n          // if the parent edge doesn't satisfy the child edge, and the\n          // child edge doesn't satisfy the parent edge, then we have\n          // a conflict.  this is always a problem in strict mode, never\n          // in force mode, and a problem in non-strict mode if this isn't\n          // on behalf of our project.  in all such cases, we warn at least.\n          const dep = await this[_nodeFromEdge](parentEdge, node.parent, edge, required)\n\n          // hooray! that worked!\n          if (edge.valid)\n            continue\n\n          // allow it.  either we're overriding, or it's not something\n          // that will be installed by default anyway, and we'll fail when\n          // we get to the point where we need to, if we need to.\n          if (conflictOK || !required.has(dep))\n            continue\n\n          // problem\n          this[_failPeerConflict](edge, parentEdge)\n        }\n      }\n\n      // There is something present already, and we're not happy about it\n      // See if the thing we WOULD be happy with is also going to satisfy\n      // the other dependents on the current node.\n      const current = edge.to\n      const dep = await this[_nodeFromEdge](edge, null, null, required)\n      if (dep.canReplace(current)) {\n        await this[_nodeFromEdge](edge, node.parent, null, required)\n        continue\n      }\n\n      // at this point we know that there is a dep there, and\n      // we don't like it.  always fail strictly, always allow forcibly or\n      // in non-strict mode if it's not our fault.  don't warn here, because\n      // we are going to warn again when we place the deps, if we end up\n      // overriding for something else.  If the thing that has this dep\n      // isn't also required, then there's a good chance we won't need it,\n      // so allow it for now and let it conflict if it turns out to actually\n      // be necessary for the installation.\n      if (conflictOK || !required.has(edge.from))\n        continue\n\n      // ok, it's the root, or we're in unforced strict mode, so this is bad\n      this[_failPeerConflict](edge, parentEdge)\n    }\n    return node\n  }\n\n  [_failPeerConflict] (edge, currentEdge) {\n    const expl = this[_explainPeerConflict](edge, currentEdge)\n    throw Object.assign(new Error('unable to resolve dependency tree'), expl)\n  }\n\n  [_explainPeerConflict] (edge, currentEdge) {\n    const node = edge.from\n    const curNode = node.resolve(edge.name)\n    const pc = this[_peerConflict] || { peer: null, current: null }\n    const current = curNode ? curNode.explain() : pc.current\n    const peerConflict = pc.peer\n    return {\n      code: 'ERESOLVE',\n      current,\n      // it SHOULD be impossible to get here without a current node in place,\n      // but this at least gives us something report on when bugs creep into\n      // the tree handling logic.\n      currentEdge: currentEdge ? currentEdge.explain() : null,\n      edge: edge.explain(),\n      peerConflict,\n      strictPeerDeps: this[_strictPeerDeps],\n      force: this[_force],\n    }\n  }\n\n  [_warnPeerConflict] (edge) {\n    // track that we've overridden this edge, so that we don't keep trying\n    // to re-resolve it in an infinite loop.\n    this[_edgesOverridden].add(edge)\n    const expl = this[_explainPeerConflict](edge)\n    this.log.warn('ERESOLVE', 'overriding peer dependency', expl)\n  }\n\n  // starting from either node, or in the case of non-root peer deps,\n  // the node's parent, walk up the tree until we find the first spot\n  // where this dep cannot be placed, and use the one right before that.\n  // place dep, requested by node, to satisfy edge\n  // XXX split this out into a separate method or mixin?  It's quite a lot\n  // of functionality that ought to have its own unit tests more conveniently.\n  [_placeDep] (dep, node, edge, peerEntryEdge = null, peerPath = []) {\n    if (edge.to &&\n        !edge.error &&\n        !this[_explicitRequests].has(edge) &&\n        !this[_updateNames].includes(edge.name) &&\n        !this[_isVulnerable](edge.to))\n      return []\n\n    // top nodes should still get peer deps from their fsParent if possible,\n    // and only install locally if there's no other option, eg for a link\n    // outside of the project root, or for a conflicted dep.\n    const start = edge.peer && !node.isProjectRoot ? node.resolveParent || node\n      : node\n\n    let target\n    let canPlace = null\n    let isSource = false\n    const source = this[_peerSetSource].get(dep)\n    for (let check = start; check; check = check.resolveParent) {\n      // we always give the FIRST place we possibly *can* put this a little\n      // extra prioritization with peer dep overrides and deduping\n      if (check === source)\n        isSource = true\n\n      // if the current location has a peerDep on it, then we can't place here\n      // this is pretty rare to hit, since we always prefer deduping peers.\n      const checkEdge = check.edgesOut.get(edge.name)\n      if (!check.isTop && checkEdge && checkEdge.peer)\n        continue\n\n      const cp = this[_canPlaceDep](dep, check, edge, peerEntryEdge, peerPath, isSource)\n      isSource = false\n\n      // anything other than a conflict is fine to proceed with\n      if (cp !== CONFLICT) {\n        canPlace = cp\n        target = check\n      } else\n        break\n\n      // nest packages like npm v1 and v2\n      // very disk-inefficient\n      if (this[_legacyBundling])\n        break\n\n      // when installing globally, or just in global style, we never place\n      // deps above the first level.\n      const tree = this.idealTree && this.idealTree.target\n      if (this[_globalStyle] && check.resolveParent === tree)\n        break\n    }\n\n    // if we can't find a target, that means that the last placed checked\n    // (and all the places before it) had a copy already.  if we're in\n    // --force mode, then the user has explicitly said that they're ok\n    // with conflicts.  This can only occur in --force mode in the case\n    // when a node was added to the tree with a peerOptional dep that we\n    // ignored, and then later, that edge became invalid, and we fail to\n    // resolve it.  We will warn about it in a moment.\n    if (!target) {\n      if (this[_force]) {\n        // we know that there is a dep (not the root) which is the target\n        // of this edge, or else it wouldn't have been a conflict.\n        target = edge.to.resolveParent\n        canPlace = KEEP\n      } else\n        this[_failPeerConflict](edge)\n    } else {\n      // it worked, so we clearly have no peer conflicts at this point.\n      this[_peerConflict] = null\n    }\n\n    this.log.silly(\n      'placeDep',\n      target.location || 'ROOT',\n      `${dep.name}@${dep.version}`,\n      canPlace.description || /* istanbul ignore next */ canPlace,\n      `for: ${node.package._id || node.location}`,\n      `want: ${edge.spec || '*'}`\n    )\n\n    // Can only get KEEP here if the original edge was valid,\n    // and we're checking for an update but it's already up to date.\n    if (canPlace === KEEP) {\n      if (edge.peer && !target.children.get(edge.name).satisfies(edge)) {\n        // this is an overridden peer dep\n        this[_warnPeerConflict](edge)\n      }\n\n      // if we get a KEEP in a update scenario, then we MAY have something\n      // already duplicating this unnecessarily!  For example:\n      // ```\n      // root\n      // +-- x (dep: y@1.x)\n      // |   +-- y@1.0.0\n      // +-- y@1.1.0\n      // ```\n      // Now say we do `reify({update:['y']})`, and the latest version is\n      // 1.1.0, which we already have in the root.  We'll try to place y@1.1.0\n      // first in x, then in the root, ending with KEEP, because we already\n      // have it.  In that case, we ought to REMOVE the nm/x/nm/y node, because\n      // it is an unnecessary duplicate.\n      this[_pruneDedupable](target)\n      return []\n    }\n\n    // figure out which of this node's peer deps will get placed as well\n    const virtualRoot = dep.parent\n\n    const newDep = new dep.constructor({\n      name: dep.name,\n      pkg: dep.package,\n      resolved: dep.resolved,\n      integrity: dep.integrity,\n      legacyPeerDeps: this.legacyPeerDeps,\n      error: dep.errors[0],\n      ...(dep.isLink ? { target: dep.target, realpath: dep.target.path } : {}),\n    })\n    if (this[_loadFailures].has(dep))\n      this[_loadFailures].add(newDep)\n\n    const placed = [newDep]\n    const oldChild = target.children.get(edge.name)\n    if (oldChild) {\n      // if we're replacing, we should also remove any nodes for edges that\n      // are now invalid, and where this (or its deps) is the only dependent,\n      // and also recurse on that pruning.  Otherwise leaving that dep node\n      // around can result in spurious conflicts pushing nodes deeper into\n      // the tree than needed in the case of cycles that will be removed\n      // later anyway.\n      const oldDeps = []\n      for (const [name, edge] of oldChild.edgesOut.entries()) {\n        if (!newDep.edgesOut.has(name) && edge.to)\n          oldDeps.push(...gatherDepSet([edge.to], e => e.to !== edge.to))\n      }\n      newDep.replace(oldChild)\n      this[_pruneForReplacement](newDep, oldDeps)\n      // this may also create some invalid edges, for example if we're\n      // intentionally causing something to get nested which was previously\n      // placed in this location.\n      for (const edgeIn of newDep.edgesIn) {\n        if (edgeIn.invalid && edgeIn !== edge) {\n          this[_depsQueue].push(edgeIn.from)\n          this[_depsSeen].delete(edgeIn.from)\n        }\n      }\n    } else\n      newDep.parent = target\n\n    if (edge.peer && !newDep.satisfies(edge)) {\n      // this is an overridden peer dep\n      this[_warnPeerConflict](edge)\n    }\n\n    // If the edge is not an error, then we're updating something, and\n    // MAY end up putting a better/identical node further up the tree in\n    // a way that causes an unnecessary duplication.  If so, remove the\n    // now-unnecessary node.\n    if (edge.valid && edge.to && edge.to !== newDep)\n      this[_pruneDedupable](edge.to, false)\n\n    // visit any dependents who are upset by this change\n    // if it's an angry overridden peer edge, however, make sure we\n    // skip over it!\n    for (const edgeIn of newDep.edgesIn) {\n      if (edgeIn !== edge && !edgeIn.valid && !this[_depsSeen].has(edge.from)) {\n        this.addTracker('idealTree', edgeIn.from.name, edgeIn.from.location)\n        this[_depsQueue].push(edgeIn.from)\n      }\n    }\n\n    // in case we just made some duplicates that can be removed,\n    // prune anything deeper in the tree that can be replaced by this\n    if (this.idealTree) {\n      for (const node of this.idealTree.inventory.query('name', newDep.name)) {\n        if (!node.isTop && node.isDescendantOf(target))\n          this[_pruneDedupable](node, false)\n      }\n    }\n\n    // also place its unmet or invalid peer deps at this location\n    // note that newDep has now been removed from the virtualRoot set\n    // by virtue of being placed in the target's node_modules.\n    // loop through any peer deps from the thing we just placed, and place\n    // those ones as well.  it's safe to do this with the virtual nodes,\n    // because we're copying rather than moving them out of the virtual root,\n    // otherwise they'd be gone and the peer set would change throughout\n    // this loop.\n    for (const peerEdge of newDep.edgesOut.values()) {\n      const peer = virtualRoot.children.get(peerEdge.name)\n\n      // Note: if the virtualRoot *doesn't* have the peer, then that means\n      // it's an optional peer dep.  If it's not being properly met (ie,\n      // peerEdge.valid is false), that this is likely heading for an\n      // ERESOLVE error, unless it can walk further up the tree.\n      if (!peerEdge.peer || peerEdge.valid || !peer)\n        continue\n\n      const peerPlaced = this[_placeDep](\n        peer, newDep, peerEdge, peerEntryEdge || edge, peerPath)\n      placed.push(...peerPlaced)\n    }\n\n    // we're done with this now, clean it up.\n    this[_virtualRoots].delete(virtualRoot.sourceReference)\n\n    return placed\n  }\n\n  // prune all the nodes in a branch of the tree that can be safely removed\n  // This is only the most basic duplication detection; it finds if there\n  // is another satisfying node further up the tree, and if so, dedupes.\n  // Even in legacyBundling mode, we do this amount of deduplication.\n  [_pruneDedupable] (node, descend = true) {\n    if (node.canDedupe(this[_preferDedupe])) {\n      node.root = null\n      return\n    }\n    if (descend) {\n      // sort these so that they're deterministically ordered\n      // otherwise, resulting tree shape is dependent on the order\n      // in which they happened to be resolved.\n      const nodeSort = (a, b) => a.location.localeCompare(b.location, 'en')\n\n      const children = [...node.children.values()].sort(nodeSort)\n      const fsChildren = [...node.fsChildren].sort(nodeSort)\n      for (const child of children)\n        this[_pruneDedupable](child)\n      for (const topNode of fsChildren) {\n        const children = [...topNode.children.values()].sort(nodeSort)\n        for (const child of children)\n          this[_pruneDedupable](child)\n      }\n    }\n  }\n\n  [_pruneForReplacement] (node, oldDeps) {\n    // gather up all the invalid edgesOut, and any now-extraneous\n    // deps that the new node doesn't depend on but the old one did.\n    const invalidDeps = new Set([...node.edgesOut.values()]\n      .filter(e => e.to && !e.valid).map(e => e.to))\n    for (const dep of oldDeps) {\n      const set = gatherDepSet([dep], e => e.to !== dep && e.valid)\n      for (const dep of set)\n        invalidDeps.add(dep)\n    }\n\n    // ignore dependency edges from the node being replaced, but\n    // otherwise filter the set down to just the set with no\n    // dependencies from outside the set, except the node in question.\n    const deps = gatherDepSet(invalidDeps, edge =>\n      edge.from !== node && edge.to !== node && edge.valid)\n\n    // now just delete whatever's left, because it's junk\n    for (const dep of deps)\n      dep.parent = null\n  }\n\n  // check if we can place DEP in TARGET to satisfy EDGE\n  // Need to verify:\n  // - no child by that name there already\n  // - target does not have a peer dep on name\n  // - no higher-level pkg by that name and incompatible spec is depended on\n  //   by anything lower in the tree.\n  // - node's peer deps and meta-peer deps are siblings in a virtual root at\n  //   this point.  make sure that the whole family can come along, so apply\n  //   the same checks to each of them.  They may land higher up in the tree,\n  //   but we need to know that they CAN live here.\n  // Responses:\n  // - OK - Yes, because there is nothing there and no conflicts caused\n  // - REPLACE - Yes, and you can clobber what's there\n  // - KEEP - No, but what's there is fine\n  // - CONFLICT - You may not put that there\n  //\n  // Check peers on OK or REPLACE.  KEEP and CONFLICT do not require peer\n  // checking, because either we're leaving it alone, or it won't work anyway.\n  // When we check peers, we pass along the peerEntryEdge to track the\n  // original edge that caused us to load the family of peer dependencies.\n  [_canPlaceDep] (dep, target, edge, peerEntryEdge = null, peerPath = [], isSource = false) {\n    /* istanbul ignore next */\n    debug(() => {\n      if (!dep)\n        throw new Error('no dep??')\n    })\n    const entryEdge = peerEntryEdge || edge\n    const source = this[_peerSetSource].get(dep)\n\n    isSource = isSource || target === source\n    // if we're overriding the source, then we care if the *target* is\n    // ours, even if it wasn't actually the original source, since we\n    // are depending on something that has a dep that can't go in its own\n    // folder.  for example, a -> b, b -> PEER(a).  Even though a is the\n    // source, b has to be installed up a level, and if the root package\n    // depends on a, and it has a conflict, it's our problem.  So, the root\n    // (or whatever is bringing in a) becomes the \"effective source\" for\n    // the purposes of this calculation.\n    const { isProjectRoot, isWorkspace } = isSource ? target : source || {}\n    const isMine = isProjectRoot || isWorkspace\n\n    // Useful testing thingie right here.\n    // peerEntryEdge should *always* be a non-peer dependency, or a peer\n    // dependency from the root node.  When we get spurious ERESOLVE errors,\n    // or *don't* get ERESOLVE errors when we should, check to see if this\n    // fails, because it MAY mean we got off track somehow.\n    /* istanbul ignore next - debug check, should be impossible */\n    debug(() => {\n      if (peerEntryEdge && peerEntryEdge.peer && !peerEntryEdge.from.isTop)\n        throw new Error('lost original peerEntryEdge somehow?')\n    })\n\n    if (target.children.has(edge.name)) {\n      const current = target.children.get(edge.name)\n\n      // same thing = keep, UNLESS the current doesn't satisfy and new\n      // one does satisfy.  This can happen if it's a link to a matching target\n      // at a different location, which satisfies a version dep, but not a\n      // file: dep.  If neither of them satisfy, then we can replace it,\n      // because presumably it's better for a peer or something.\n      if (dep.matches(current)) {\n        if (current.satisfies(edge) || !dep.satisfies(edge))\n          return KEEP\n      }\n\n      const { version: curVer } = current\n      const { version: newVer } = dep\n      const tryReplace = curVer && newVer && semver.gte(newVer, curVer)\n      if (tryReplace && dep.canReplace(current)) {\n        const res = this[_canPlacePeers](dep, target, edge, REPLACE, peerEntryEdge, peerPath, isSource)\n        /* istanbul ignore else - It's extremely rare that a replaceable\n         * node would be a conflict, if the current one wasn't a conflict,\n         * but it is theoretically possible if peer deps are pinned.  In\n         * that case we treat it like any other conflict, and keep trying */\n        if (res !== CONFLICT)\n          return res\n      }\n\n      // ok, can't replace the current with new one, but maybe current is ok?\n      // no need to check if it's a peer that's valid to be here, because\n      // peers are always placed along with their entry source\n      if (edge.satisfiedBy(current))\n        return KEEP\n\n      // if we prefer deduping, then try replacing newer with older\n      // we always prefer to dedupe peers, because they are trying\n      // a bit harder to be singletons.\n      const preferDedupe = this[_preferDedupe] || edge.peer\n      if (preferDedupe && !tryReplace && dep.canReplace(current)) {\n        const res = this[_canPlacePeers](dep, target, edge, REPLACE, peerEntryEdge, peerPath, isSource)\n        /* istanbul ignore else - It's extremely rare that a replaceable\n         * node would be a conflict, if the current one wasn't a conflict,\n         * but it is theoretically possible if peer deps are pinned.  In\n         * that case we treat it like any other conflict, and keep trying */\n        if (res !== CONFLICT)\n          return res\n      }\n\n      // check for conflict override cases.\n      // first: is this the only place this thing can go?  If the target is\n      // the source, then one of these things are true.\n      //\n      // 1. the conflicted dep was deduped up to here from a lower dependency\n      // w -> (x,y)\n      // x -> (z)\n      // y -> PEER(p@1)\n      // z -> (q)\n      // q -> (p@2)\n      //\n      // When building, let's say that x is fully placed, with all of its\n      // deps, and we're _adding_ y.  Since the peer on p@1 was not initially\n      // present, it's been deduped up to w, and now needs to be pushed out.\n      // Replace it, and potentially also replace its peer set (though that'll\n      // be accomplished by making the same determination when we call\n      // _canPlacePeers)\n      //\n      // 2. the dep we're TRYING to place here ought to be overridden by the\n      // one that's here now, because current is (a) a direct dep of the\n      // source, or (b) an already-placed peer in a conflicted peer set, or\n      // (c) an already-placed peer in a different peer set at the same level.\n      // If strict or ours, conflict.  Otherwise, keep.\n      if (isSource) {\n        // check to see if the current module could go deeper in the tree\n        let canReplace = true\n        // only do this check when we're placing peers.  when we're placing\n        // the original in the source, we know that the edge from the source\n        // is the thing we're trying to place, so its peer set will need to be\n        // placed here as well.  the virtualRoot already has the appropriate\n        // overrides applied.\n        if (peerEntryEdge) {\n          const currentPeerSet = getPeerSet(current)\n\n          // We are effectively replacing currentPeerSet with newPeerSet\n          // If there are any non-peer deps coming into the currentPeerSet,\n          // which are currently valid, and are from the target, then that\n          // means that we have to ensure that they're not going to be made\n          // invalid by putting the newPeerSet in place.\n          // If the edge comes from somewhere deeper than the target, then\n          // that's fine, because we'll create an invalid edge, detect it,\n          // and duplicate the node further into the tree.\n          // loop through the currentPeerSet checking for valid edges on\n          // the members of the peer set which will be made invalid.\n          const targetEdges = new Set()\n          for (const p of currentPeerSet) {\n            for (const edge of p.edgesIn) {\n              // edge from within the peerSet, ignore\n              if (currentPeerSet.has(edge.from))\n                continue\n              // only care about valid edges from target.\n              // edges from elsewhere can dupe if offended, invalid edges\n              // are already being fixed or will be later.\n              if (edge.from !== target || !edge.valid)\n                continue\n              targetEdges.add(edge)\n            }\n          }\n\n          for (const edge of targetEdges) {\n            // see if we intend to replace this one anyway\n            const rep = dep.parent.children.get(edge.name)\n            const current = edge.to\n            if (!rep) {\n              // this isn't one we're replacing.  but it WAS included in the\n              // peerSet for some reason, so make sure that it's still\n              // ok with the replacements in the new peerSet\n              for (const curEdge of current.edgesOut.values()) {\n                const newRepDep = dep.parent.children.get(curEdge.name)\n                if (curEdge.valid && newRepDep && !newRepDep.satisfies(curEdge)) {\n                  canReplace = false\n                  break\n                }\n              }\n              continue\n            }\n\n            // was this replacement already an override of some sort?\n            const override = [...rep.edgesIn].some(e => !e.valid)\n            // if we have a rep, and it's ok to put in this location, and\n            // it's not already part of an override in the peerSet, then\n            // we can continue with it.\n            if (rep.satisfies(edge) && !override)\n              continue\n            // Otherwise, we cannot replace.\n            canReplace = false\n            break\n          }\n          // if we're going to be replacing the peerSet, we have to remove\n          // and re-resolve any members of the old peerSet that are not\n          // present in the new one, and which will have invalid edges.\n          // We know that they're not depended upon by the target, or else\n          // they would have caused a conflict, so they'll get landed deeper\n          // in the tree, if possible.\n          if (canReplace) {\n            let needNesting = false\n            OUTER: for (const node of currentPeerSet) {\n              const rep = dep.parent.children.get(node.name)\n              // has a replacement, already addressed above\n              if (rep)\n                continue\n\n              // ok, it has been placed here to dedupe, see if it needs to go\n              // back deeper within the tree.\n              for (const edge of node.edgesOut.values()) {\n                const repDep = dep.parent.children.get(edge.name)\n                // not in new peerSet, maybe fine.\n                if (!repDep)\n                  continue\n\n                // new thing will be fine, no worries\n                if (repDep.satisfies(edge))\n                  continue\n\n                // uhoh, we'll have to nest them.\n                needNesting = true\n                break OUTER\n              }\n            }\n\n            // to nest, just delete everything without a target dep\n            // that's in the current peerSet, and add their dependants\n            // to the _depsQueue for evaluation.  Some of these MAY end\n            // up in the same location again, and that's fine.\n            if (needNesting) {\n              // avoid mutating the tree while we're examining it\n              const dependants = new Set()\n              const reresolve = new Set()\n              OUTER: for (const node of currentPeerSet) {\n                const rep = dep.parent.children.get(node.name)\n                if (rep)\n                  continue\n                // create a separate set for each one, so we can skip any\n                // that might somehow have an incoming target edge\n                const deps = new Set()\n                for (const edge of node.edgesIn) {\n                  // a target dep, skip this dep entirely, already addressed\n                  // ignoring for coverage, because it really ought to be\n                  // impossible, but I can't prove it yet, so this is here\n                  // for safety.\n                  /* istanbul ignore if - should be impossible */\n                  if (edge.from === target)\n                    continue OUTER\n                  // ignore this edge, it'll either be replaced or re-resolved\n                  if (currentPeerSet.has(edge.from))\n                    continue\n                  // ok, we care about this one.\n                  deps.add(edge.from)\n                }\n                reresolve.add(node)\n                for (const d of deps)\n                  dependants.add(d)\n              }\n              for (const dependant of dependants) {\n                this[_depsQueue].push(dependant)\n                this[_depsSeen].delete(dependant)\n              }\n              for (const node of reresolve)\n                node.root = null\n            }\n          }\n        }\n\n        if (canReplace) {\n          const ret = this[_canPlacePeers](dep, target, edge, REPLACE, peerEntryEdge, peerPath, isSource)\n          /* istanbul ignore else - extremely rare that the peer set would\n           * conflict if we can replace the node in question, but theoretically\n           * possible, if peer deps are pinned aggressively. */\n          if (ret !== CONFLICT)\n            return ret\n        }\n\n        // so it's not a deeper dep that's been deduped.  That means that the\n        // only way it could have ended up here is if it's a conflicted peer.\n        /* istanbul ignore else - would have already crashed if not forced,\n         * and either mine or strict, when creating the peerSet.  Keeping this\n         * check so that we're not only relying on action at a distance. */\n        if (!this[_strictPeerDeps] && !isMine || this[_force]) {\n          this[_warnPeerConflict](edge, dep)\n          return KEEP\n        }\n      }\n\n      // no justification for overriding, and no agreement possible.\n      return CONFLICT\n    }\n\n    // no existing node at this location!\n    // check to see if the target doesn't have a child by that name,\n    // but WANTS one, and won't be happy with this one.  if this is the\n    // edge we're looking to resolve, then not relevant, of course.\n    if (target !== entryEdge.from && target.edgesOut.has(dep.name)) {\n      const targetEdge = target.edgesOut.get(dep.name)\n      // It might be that the dep would not be valid here, BUT some other\n      // version would.  Could to try to resolve that, but that makes this no\n      // longer a pure synchronous function.  ugh.\n      // This is a pretty unlikely scenario in a normal install, because we\n      // resolve the peer dep set against the parent dependencies, and\n      // presumably they all worked together SOMEWHERE to get published in the\n      // first place, and since we resolve shallower deps before deeper ones,\n      // this can only occur by a child having a peer dep that does not satisfy\n      // the parent.  It can happen if we're doing a deep update limited by\n      // a specific name, however, or if a dep makes an incompatible change\n      // to its peer dep in a non-semver-major version bump, or if the parent\n      // is unbounded in its dependency list.\n      if (!targetEdge.satisfiedBy(dep))\n        return CONFLICT\n    }\n\n    // check to see what that name resolves to here, and who may depend on\n    // being able to reach it by crawling up past this parent.  we know\n    // at this point that it's not the target's direct child node.  if it's\n    // a direct dep of the target, we just make the invalid edge and\n    // resolve it later.\n    const current = target !== entryEdge.from && target.resolve(dep.name)\n    if (current) {\n      for (const edge of current.edgesIn.values()) {\n        if (!edge.from.isTop && edge.from.isDescendantOf(target) && edge.valid) {\n          if (!edge.satisfiedBy(dep))\n            return CONFLICT\n        }\n      }\n    }\n\n    // no objections!  ok to place here\n    return this[_canPlacePeers](dep, target, edge, OK, peerEntryEdge, peerPath, isSource)\n  }\n\n  // make sure the family of peer deps can live here alongside it.\n  // this doesn't guarantee that THIS solution will be the one we take,\n  // but it does establish that SOME solution exists at this level in\n  // the tree.\n  [_canPlacePeers] (dep, target, edge, ret, peerEntryEdge, peerPath, isSource) {\n    // do not go in cycles when we're resolving a peer group\n    if (!dep.parent || peerEntryEdge && peerPath.includes(dep))\n      return ret\n\n    const entryEdge = peerEntryEdge || edge\n    peerPath = [...peerPath, dep]\n\n    for (const peerEdge of dep.edgesOut.values()) {\n      if (!peerEdge.peer || !peerEdge.to)\n        continue\n      const peer = peerEdge.to\n      const canPlacePeer = this[_canPlaceDep](peer, target, peerEdge, entryEdge, peerPath, isSource)\n      if (canPlacePeer !== CONFLICT)\n        continue\n\n      const current = target.resolve(peer.name)\n      this[_peerConflict] = {\n        peer: peer.explain(peerEdge),\n        current: current && current.explain(),\n      }\n      return CONFLICT\n    }\n    return ret\n  }\n\n  // go through all the links in the this[_linkNodes] set\n  // for each one:\n  // - if outside the root, ignore it, assume it's fine, it's not our problem\n  // - if a node in the tree already, assign the target to that node.\n  // - if a path under an existing node, then assign that as the fsParent,\n  //   and add it to the _depsQueue\n  //\n  // call buildDepStep if anything was added to the queue, otherwise we're done\n  [_resolveLinks] () {\n    for (const link of this[_linkNodes]) {\n      this[_linkNodes].delete(link)\n\n      // link we never ended up placing, skip it\n      if (link.root !== this.idealTree)\n        continue\n\n      const tree = this.idealTree.target\n      const external = !link.target.isDescendantOf(tree)\n\n      // outside the root, somebody else's problem, ignore it\n      if (external && !this[_follow])\n        continue\n\n      // didn't find a parent for it or it has not been seen yet\n      // so go ahead and process it.\n      const unseenLink = (link.target.parent || link.target.fsParent) &&\n        !this[_depsSeen].has(link.target)\n\n      if (this[_follow] &&\n          !link.target.parent &&\n          !link.target.fsParent ||\n          unseenLink) {\n        this.addTracker('idealTree', link.target.name, link.target.location)\n        this[_depsQueue].push(link.target)\n      }\n    }\n\n    if (this[_depsQueue].length)\n      return this[_buildDepStep]()\n  }\n\n  [_fixDepFlags] () {\n    process.emit('time', 'idealTree:fixDepFlags')\n    const metaFromDisk = this.idealTree.meta.loadedFromDisk\n    const flagsSuspect = this[_flagsSuspect]\n    const mutateTree = this[_mutateTree]\n    // if the options set prune:false, then we don't prune, but we still\n    // mark the extraneous items in the tree if we modified it at all.\n    // If we did no modifications, we just iterate over the extraneous nodes.\n    // if we started with an empty tree, then the dep flags are already\n    // all set to true, and there can be nothing extraneous, so there's\n    // nothing to prune, because we built it from scratch.  if we didn't\n    // add or remove anything, then also nothing to do.\n    if (metaFromDisk && mutateTree)\n      resetDepFlags(this.idealTree)\n\n    // update all the dev/optional/etc flags in the tree\n    // either we started with a fresh tree, or we\n    // reset all the flags to find the extraneous nodes.\n    //\n    // if we started from a blank slate, or changed something, then\n    // the dep flags will be all set to true.\n    if (!metaFromDisk || mutateTree)\n      calcDepFlags(this.idealTree)\n    else {\n      // otherwise just unset all the flags on the root node\n      // since they will sometimes have the default value\n      this.idealTree.extraneous = false\n      this.idealTree.dev = false\n      this.idealTree.optional = false\n      this.idealTree.devOptional = false\n      this.idealTree.peer = false\n    }\n\n    // at this point, any node marked as extraneous should be pruned.\n    // if we started from a shrinkwrap, and then added/removed something,\n    // then the tree is suspect.  Prune what is marked as extraneous.\n    // otherwise, don't bother.\n    const needPrune = metaFromDisk && (mutateTree || flagsSuspect)\n    if (this[_prune] && needPrune)\n      this[_idealTreePrune]()\n    process.emit('timeEnd', 'idealTree:fixDepFlags')\n  }\n\n  [_idealTreePrune] () {\n    for (const node of this.idealTree.inventory.filter(n => n.extraneous))\n      node.parent = null\n  }\n\n  [_pruneFailedOptional] () {\n    for (const node of this[_loadFailures]) {\n      if (!node.optional)\n        throw node.errors[0]\n\n      const set = optionalSet(node)\n      for (const node of set)\n        node.parent = null\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}