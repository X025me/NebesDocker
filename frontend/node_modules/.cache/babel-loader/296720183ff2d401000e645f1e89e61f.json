{"ast":null,"code":"// add and remove dependency specs to/from pkg manifest\nconst add = ({\n  pkg,\n  add,\n  saveBundle,\n  saveType,\n  log\n}) => {\n  for (const spec of add) addSingle({\n    pkg,\n    spec,\n    saveBundle,\n    saveType,\n    log\n  });\n\n  return pkg;\n}; // Canonical source of both the map between saveType and where it correlates to\n// in the package, and the names of all our dependencies attributes\n\n\nconst saveTypeMap = new Map([['dev', 'devDependencies'], ['optional', 'optionalDependencies'], ['prod', 'dependencies'], ['peerOptional', 'peerDependencies'], ['peer', 'peerDependencies']]);\n\nconst addSingle = ({\n  pkg,\n  spec,\n  saveBundle,\n  saveType,\n  log\n}) => {\n  const {\n    name,\n    rawSpec\n  } = spec; // if the user does not give us a type, we infer which type(s)\n  // to keep based on the same order of priority we do when\n  // building the tree as defined in the _loadDeps method of\n  // the node class.\n\n  if (!saveType) saveType = inferSaveType(pkg, spec.name);\n\n  if (saveType === 'prod') {\n    // a production dependency can only exist as production (rpj ensures it\n    // doesn't coexist w/ optional)\n    deleteSubKey(pkg, 'devDependencies', name, 'dependencies', log);\n    deleteSubKey(pkg, 'peerDependencies', name, 'dependencies', log);\n  } else if (saveType === 'dev') {\n    // a dev dependency may co-exist as peer, or optional, but not production\n    deleteSubKey(pkg, 'dependencies', name, 'devDependencies', log);\n  } else if (saveType === 'optional') {\n    // an optional dependency may co-exist as dev (rpj ensures it doesn't\n    // coexist w/ prod)\n    deleteSubKey(pkg, 'peerDependencies', name, 'optionalDependencies', log);\n  } else {\n    // peer or peerOptional is all that's left\n    // a peer dependency may coexist as dev\n    deleteSubKey(pkg, 'dependencies', name, 'peerDependencies', log);\n    deleteSubKey(pkg, 'optionalDependencies', name, 'peerDependencies', log);\n  }\n\n  const depType = saveTypeMap.get(saveType);\n  pkg[depType] = pkg[depType] || {};\n  if (rawSpec !== '' || pkg[depType][name] === undefined) pkg[depType][name] = rawSpec || '*';\n\n  if (saveType === 'optional') {\n    // Affordance for previous npm versions that require this behaviour\n    pkg.dependencies = pkg.dependencies || {};\n    pkg.dependencies[name] = pkg.optionalDependencies[name];\n  }\n\n  if (saveType === 'peer' || saveType === 'peerOptional') {\n    const pdm = pkg.peerDependenciesMeta || {};\n    if (saveType === 'peer' && pdm[name] && pdm[name].optional) pdm[name].optional = false;else if (saveType === 'peerOptional') {\n      pdm[name] = pdm[name] || {};\n      pdm[name].optional = true;\n      pkg.peerDependenciesMeta = pdm;\n    } // peerDeps are often also a devDep, so that they can be tested when\n    // using package managers that don't auto-install peer deps\n\n    if (pkg.devDependencies && pkg.devDependencies[name] !== undefined) pkg.devDependencies[name] = pkg.peerDependencies[name];\n  }\n\n  if (saveBundle && saveType !== 'peer' && saveType !== 'peerOptional') {\n    // keep it sorted, keep it unique\n    const bd = new Set(pkg.bundleDependencies || []);\n    bd.add(spec.name);\n    pkg.bundleDependencies = [...bd].sort((a, b) => a.localeCompare(b, 'en'));\n  }\n}; // Finds where the package is already in the spec and infers saveType from that\n\n\nconst inferSaveType = (pkg, name) => {\n  for (const saveType of saveTypeMap.keys()) {\n    if (hasSubKey(pkg, saveTypeMap.get(saveType), name)) {\n      if (saveType === 'peerOptional' && (!hasSubKey(pkg, 'peerDependenciesMeta', name) || !pkg.peerDependenciesMeta[name].optional)) return 'peer';\n      return saveType;\n    }\n  }\n\n  return 'prod';\n};\n\nconst hasSubKey = (pkg, depType, name) => {\n  return pkg[depType] && Object.prototype.hasOwnProperty.call(pkg[depType], name);\n}; // Removes a subkey and warns about it if it's being replaced\n\n\nconst deleteSubKey = (pkg, depType, name, replacedBy, log) => {\n  if (hasSubKey(pkg, depType, name)) {\n    if (replacedBy && log) log.warn('idealTree', `Removing ${depType}.${name} in favor of ${replacedBy}.${name}`);\n    delete pkg[depType][name]; // clean up peerDependenciesMeta if we are removing something from peerDependencies\n\n    if (depType === 'peerDependencies' && pkg.peerDependenciesMeta) {\n      delete pkg.peerDependenciesMeta[name];\n      if (!Object.keys(pkg.peerDependenciesMeta).length) delete pkg.peerDependenciesMeta;\n    }\n\n    if (!Object.keys(pkg[depType]).length) delete pkg[depType];\n  }\n};\n\nconst rm = (pkg, rm) => {\n  for (const depType of new Set(saveTypeMap.values())) {\n    for (const name of rm) deleteSubKey(pkg, depType, name);\n  }\n\n  if (pkg.bundleDependencies) {\n    pkg.bundleDependencies = pkg.bundleDependencies.filter(name => !rm.includes(name));\n    if (!pkg.bundleDependencies.length) delete pkg.bundleDependencies;\n  }\n\n  return pkg;\n};\n\nmodule.exports = {\n  add,\n  rm,\n  saveTypeMap,\n  hasSubKey\n};","map":{"version":3,"sources":["/Users/johndoe/Nebe-data-vistualization/node_modules/npm/node_modules/@npmcli/arborist/lib/add-rm-pkg-deps.js"],"names":["add","pkg","saveBundle","saveType","log","spec","addSingle","saveTypeMap","Map","name","rawSpec","inferSaveType","deleteSubKey","depType","get","undefined","dependencies","optionalDependencies","pdm","peerDependenciesMeta","optional","devDependencies","peerDependencies","bd","Set","bundleDependencies","sort","a","b","localeCompare","keys","hasSubKey","Object","prototype","hasOwnProperty","call","replacedBy","warn","length","rm","values","filter","includes","module","exports"],"mappings":"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","sourcesContent":["// add and remove dependency specs to/from pkg manifest\n\nconst add = ({pkg, add, saveBundle, saveType, log}) => {\n  for (const spec of add)\n    addSingle({pkg, spec, saveBundle, saveType, log})\n\n  return pkg\n}\n\n// Canonical source of both the map between saveType and where it correlates to\n// in the package, and the names of all our dependencies attributes\nconst saveTypeMap = new Map([\n  ['dev', 'devDependencies'],\n  ['optional', 'optionalDependencies'],\n  ['prod', 'dependencies'],\n  ['peerOptional', 'peerDependencies'],\n  ['peer', 'peerDependencies'],\n])\n\nconst addSingle = ({pkg, spec, saveBundle, saveType, log}) => {\n  const { name, rawSpec } = spec\n\n  // if the user does not give us a type, we infer which type(s)\n  // to keep based on the same order of priority we do when\n  // building the tree as defined in the _loadDeps method of\n  // the node class.\n  if (!saveType)\n    saveType = inferSaveType(pkg, spec.name)\n\n  if (saveType === 'prod') {\n    // a production dependency can only exist as production (rpj ensures it\n    // doesn't coexist w/ optional)\n    deleteSubKey(pkg, 'devDependencies', name, 'dependencies', log)\n    deleteSubKey(pkg, 'peerDependencies', name, 'dependencies', log)\n  } else if (saveType === 'dev') {\n    // a dev dependency may co-exist as peer, or optional, but not production\n    deleteSubKey(pkg, 'dependencies', name, 'devDependencies', log)\n  } else if (saveType === 'optional') {\n    // an optional dependency may co-exist as dev (rpj ensures it doesn't\n    // coexist w/ prod)\n    deleteSubKey(pkg, 'peerDependencies', name, 'optionalDependencies', log)\n  } else { // peer or peerOptional is all that's left\n    // a peer dependency may coexist as dev\n    deleteSubKey(pkg, 'dependencies', name, 'peerDependencies', log)\n    deleteSubKey(pkg, 'optionalDependencies', name, 'peerDependencies', log)\n  }\n\n  const depType = saveTypeMap.get(saveType)\n\n  pkg[depType] = pkg[depType] || {}\n  if (rawSpec !== '' || pkg[depType][name] === undefined)\n    pkg[depType][name] = rawSpec || '*'\n  if (saveType === 'optional') {\n    // Affordance for previous npm versions that require this behaviour\n    pkg.dependencies = pkg.dependencies || {}\n    pkg.dependencies[name] = pkg.optionalDependencies[name]\n  }\n\n  if (saveType === 'peer' || saveType === 'peerOptional') {\n    const pdm = pkg.peerDependenciesMeta || {}\n    if (saveType === 'peer' && pdm[name] && pdm[name].optional)\n      pdm[name].optional = false\n    else if (saveType === 'peerOptional') {\n      pdm[name] = pdm[name] || {}\n      pdm[name].optional = true\n      pkg.peerDependenciesMeta = pdm\n    }\n    // peerDeps are often also a devDep, so that they can be tested when\n    // using package managers that don't auto-install peer deps\n    if (pkg.devDependencies && pkg.devDependencies[name] !== undefined)\n      pkg.devDependencies[name] = pkg.peerDependencies[name]\n  }\n\n  if (saveBundle && saveType !== 'peer' && saveType !== 'peerOptional') {\n    // keep it sorted, keep it unique\n    const bd = new Set(pkg.bundleDependencies || [])\n    bd.add(spec.name)\n    pkg.bundleDependencies = [...bd].sort((a, b) => a.localeCompare(b, 'en'))\n  }\n}\n\n// Finds where the package is already in the spec and infers saveType from that\nconst inferSaveType = (pkg, name) => {\n  for (const saveType of saveTypeMap.keys()) {\n    if (hasSubKey(pkg, saveTypeMap.get(saveType), name)) {\n      if (\n        saveType === 'peerOptional' &&\n        (!hasSubKey(pkg, 'peerDependenciesMeta', name) ||\n        !pkg.peerDependenciesMeta[name].optional)\n      )\n        return 'peer'\n      return saveType\n    }\n  }\n  return 'prod'\n}\n\nconst hasSubKey = (pkg, depType, name) => {\n  return pkg[depType] && Object.prototype.hasOwnProperty.call(pkg[depType], name)\n}\n\n// Removes a subkey and warns about it if it's being replaced\nconst deleteSubKey = (pkg, depType, name, replacedBy, log) => {\n  if (hasSubKey(pkg, depType, name)) {\n    if (replacedBy && log)\n      log.warn('idealTree', `Removing ${depType}.${name} in favor of ${replacedBy}.${name}`)\n    delete pkg[depType][name]\n\n    // clean up peerDependenciesMeta if we are removing something from peerDependencies\n    if (depType === 'peerDependencies' && pkg.peerDependenciesMeta) {\n      delete pkg.peerDependenciesMeta[name]\n      if (!Object.keys(pkg.peerDependenciesMeta).length)\n        delete pkg.peerDependenciesMeta\n    }\n\n    if (!Object.keys(pkg[depType]).length)\n      delete pkg[depType]\n  }\n}\n\nconst rm = (pkg, rm) => {\n  for (const depType of new Set(saveTypeMap.values())) {\n    for (const name of rm)\n      deleteSubKey(pkg, depType, name)\n  }\n  if (pkg.bundleDependencies) {\n    pkg.bundleDependencies = pkg.bundleDependencies\n      .filter(name => !rm.includes(name))\n    if (!pkg.bundleDependencies.length)\n      delete pkg.bundleDependencies\n  }\n  return pkg\n}\n\nmodule.exports = { add, rm, saveTypeMap, hasSubKey }\n"]},"metadata":{},"sourceType":"script"}