{"ast":null,"code":"// mixin providing the loadVirtual method\nconst {\n  resolve\n} = require('path');\n\nconst nameFromFolder = require('@npmcli/name-from-folder');\n\nconst consistentResolve = require('../consistent-resolve.js');\n\nconst Shrinkwrap = require('../shrinkwrap.js');\n\nconst Node = require('../node.js');\n\nconst Link = require('../link.js');\n\nconst relpath = require('../relpath.js');\n\nconst calcDepFlags = require('../calc-dep-flags.js');\n\nconst rpj = require('read-package-json-fast');\n\nconst treeCheck = require('../tree-check.js');\n\nconst loadFromShrinkwrap = Symbol('loadFromShrinkwrap');\nconst resolveNodes = Symbol('resolveNodes');\nconst resolveLinks = Symbol('resolveLinks');\nconst assignBundles = Symbol('assignBundles');\nconst loadRoot = Symbol('loadRoot');\nconst loadNode = Symbol('loadVirtualNode');\nconst loadLink = Symbol('loadVirtualLink');\nconst loadWorkspaces = Symbol.for('loadWorkspaces');\nconst loadWorkspacesVirtual = Symbol.for('loadWorkspacesVirtual');\nconst flagsSuspect = Symbol.for('flagsSuspect');\nconst reCalcDepFlags = Symbol('reCalcDepFlags');\nconst checkRootEdges = Symbol('checkRootEdges');\nconst rootOptionProvided = Symbol('rootOptionProvided');\n\nconst depsToEdges = (type, deps) => Object.entries(deps).map(d => [type, ...d]);\n\nmodule.exports = cls => class VirtualLoader extends cls {\n  constructor(options) {\n    super(options); // the virtual tree we load from a shrinkwrap\n\n    this.virtualTree = options.virtualTree;\n    this[flagsSuspect] = false;\n  } // public method\n\n\n  async loadVirtual(options = {}) {\n    if (this.virtualTree) return this.virtualTree; // allow the user to set reify options on the ctor as well.\n    // XXX: deprecate separate reify() options object.\n\n    options = { ...this.options,\n      ...options\n    };\n\n    if (options.root && options.root.meta) {\n      await this[loadFromShrinkwrap](options.root.meta, options.root);\n      return treeCheck(this.virtualTree);\n    }\n\n    const s = await Shrinkwrap.load({\n      path: this.path\n    });\n\n    if (!s.loadedFromDisk && !options.root) {\n      const er = new Error('loadVirtual requires existing shrinkwrap file');\n      throw Object.assign(er, {\n        code: 'ENOLOCK'\n      });\n    } // when building the ideal tree, we pass in a root node to this function\n    // otherwise, load it from the root package json or the lockfile\n\n\n    const {\n      root = await this[loadRoot](s)\n    } = options;\n    this[rootOptionProvided] = options.root;\n    await this[loadFromShrinkwrap](s, root);\n    return treeCheck(this.virtualTree);\n  }\n\n  async [loadRoot](s) {\n    const pj = this.path + '/package.json';\n    const pkg = (await rpj(pj).catch(() => s.data.packages[''])) || {};\n    return this[loadWorkspaces](this[loadNode]('', pkg));\n  }\n\n  async [loadFromShrinkwrap](s, root) {\n    if (!this[rootOptionProvided]) {\n      // root is never any of these things, but might be a brand new\n      // baby Node object that never had its dep flags calculated.\n      root.extraneous = false;\n      root.dev = false;\n      root.optional = false;\n      root.devOptional = false;\n      root.peer = false;\n    } else this[flagsSuspect] = true;\n\n    this[checkRootEdges](s, root);\n    root.meta = s;\n    this.virtualTree = root;\n    const {\n      links,\n      nodes\n    } = this[resolveNodes](s, root);\n    await this[resolveLinks](links, nodes);\n    if (!(s.originalLockfileVersion >= 2)) this[assignBundles](nodes);\n    if (this[flagsSuspect]) this[reCalcDepFlags](nodes.values());\n    return root;\n  }\n\n  [reCalcDepFlags](nodes) {\n    // reset all dep flags\n    // can't use inventory here, because virtualTree might not be root\n    for (const node of nodes) {\n      if (node.isRoot || node === this[rootOptionProvided]) continue;\n      node.extraneous = true;\n      node.dev = true;\n      node.optional = true;\n      node.devOptional = true;\n      node.peer = true;\n    }\n\n    calcDepFlags(this.virtualTree, !this[rootOptionProvided]);\n  } // check the lockfile deps, and see if they match.  if they do not\n  // then we have to reset dep flags at the end.  for example, if the\n  // user manually edits their package.json file, then we need to know\n  // that the idealTree is no longer entirely trustworthy.\n\n\n  [checkRootEdges](s, root) {\n    // loaded virtually from tree, no chance of being out of sync\n    // ancient lockfiles are critically damaged by this process,\n    // so we need to just hope for the best in those cases.\n    if (!s.loadedFromDisk || s.ancientLockfile) return;\n    const lock = s.get('');\n    const prod = lock.dependencies || {};\n    const dev = lock.devDependencies || {};\n    const optional = lock.optionalDependencies || {};\n    const peer = lock.peerDependencies || {};\n    const peerOptional = {};\n\n    if (lock.peerDependenciesMeta) {\n      for (const [name, meta] of Object.entries(lock.peerDependenciesMeta)) {\n        if (meta.optional && peer[name] !== undefined) {\n          peerOptional[name] = peer[name];\n          delete peer[name];\n        }\n      }\n    }\n\n    for (const name of Object.keys(optional)) delete prod[name];\n\n    const lockWS = [];\n    const workspaces = this[loadWorkspacesVirtual]({\n      cwd: this.path,\n      lockfile: s.data\n    });\n\n    for (const [name, path] of workspaces.entries()) lockWS.push(['workspace', name, `file:${path}`]);\n\n    const lockEdges = [...depsToEdges('prod', prod), ...depsToEdges('dev', dev), ...depsToEdges('optional', optional), ...depsToEdges('peer', peer), ...depsToEdges('peerOptional', peerOptional), ...lockWS].sort(([atype, aname], [btype, bname]) => atype.localeCompare(btype, 'en') || aname.localeCompare(bname, 'en'));\n    const rootEdges = [...root.edgesOut.values()].map(e => [e.type, e.name, e.spec]).sort(([atype, aname], [btype, bname]) => atype.localeCompare(btype, 'en') || aname.localeCompare(bname, 'en'));\n\n    if (rootEdges.length !== lockEdges.length) {\n      // something added or removed\n      return this[flagsSuspect] = true;\n    }\n\n    for (let i = 0; i < lockEdges.length; i++) {\n      if (rootEdges[i][0] !== lockEdges[i][0] || rootEdges[i][1] !== lockEdges[i][1] || rootEdges[i][2] !== lockEdges[i][2]) return this[flagsSuspect] = true;\n    }\n  } // separate out link metadatas, and create Node objects for nodes\n\n\n  [resolveNodes](s, root) {\n    const links = new Map();\n    const nodes = new Map([['', root]]);\n\n    for (const [location, meta] of Object.entries(s.data.packages)) {\n      // skip the root because we already got it\n      if (!location) continue;\n      if (meta.link) links.set(location, meta);else nodes.set(location, this[loadNode](location, meta));\n    }\n\n    return {\n      links,\n      nodes\n    };\n  } // links is the set of metadata, and nodes is the map of non-Link nodes\n  // Set the targets to nodes in the set, if we have them (we might not)\n\n\n  async [resolveLinks](links, nodes) {\n    for (const [location, meta] of links.entries()) {\n      const targetPath = resolve(this.path, meta.resolved);\n      const targetLoc = relpath(this.path, targetPath);\n      const target = nodes.get(targetLoc);\n      const link = this[loadLink](location, targetLoc, target, meta);\n      nodes.set(location, link);\n      nodes.set(targetLoc, link.target); // we always need to read the package.json for link targets\n      // outside node_modules because they can be changed by the local user\n\n      if (!link.target.parent) {\n        const pj = link.realpath + '/package.json';\n        const pkg = await rpj(pj).catch(() => null);\n        if (pkg) link.target.package = pkg;\n      }\n    }\n  }\n\n  [assignBundles](nodes) {\n    for (const [location, node] of nodes) {\n      // Skip assignment of parentage for the root package\n      if (!location || node.isLink && !node.target.location) continue;\n      const {\n        name,\n        parent,\n        package: {\n          inBundle\n        }\n      } = node;\n      if (!parent) continue; // read inBundle from package because 'package' here is\n      // actually a v2 lockfile metadata entry.\n      // If the *parent* is also bundled, though, or if the parent has\n      // no dependency on it, then we assume that it's being pulled in\n      // just by virtue of its parent or a transitive dep being bundled.\n\n      const {\n        package: ppkg\n      } = parent;\n      const {\n        inBundle: parentBundled\n      } = ppkg;\n\n      if (inBundle && !parentBundled && parent.edgesOut.has(node.name)) {\n        if (!ppkg.bundleDependencies) ppkg.bundleDependencies = [name];else ppkg.bundleDependencies.push(name);\n      }\n    }\n  }\n\n  [loadNode](location, sw) {\n    const p = this.virtualTree ? this.virtualTree.realpath : this.path;\n    const path = resolve(p, location); // shrinkwrap doesn't include package name unless necessary\n\n    if (!sw.name) sw.name = nameFromFolder(path);\n    const dev = sw.dev;\n    const optional = sw.optional;\n    const devOptional = dev || optional || sw.devOptional;\n    const peer = sw.peer;\n    const node = new Node({\n      legacyPeerDeps: this.legacyPeerDeps,\n      root: this.virtualTree,\n      path,\n      realpath: path,\n      integrity: sw.integrity,\n      resolved: consistentResolve(sw.resolved, this.path, path),\n      pkg: sw,\n      hasShrinkwrap: sw.hasShrinkwrap,\n      dev,\n      optional,\n      devOptional,\n      peer\n    }); // cast to boolean because they're undefined in the lock file when false\n\n    node.extraneous = !!sw.extraneous;\n    node.devOptional = !!(sw.devOptional || sw.dev || sw.optional);\n    node.peer = !!sw.peer;\n    node.optional = !!sw.optional;\n    node.dev = !!sw.dev;\n    return node;\n  }\n\n  [loadLink](location, targetLoc, target, meta) {\n    const path = resolve(this.path, location);\n    const link = new Link({\n      legacyPeerDeps: this.legacyPeerDeps,\n      path,\n      realpath: resolve(this.path, targetLoc),\n      target,\n      pkg: target && target.package\n    });\n    link.extraneous = target.extraneous;\n    link.devOptional = target.devOptional;\n    link.peer = target.peer;\n    link.optional = target.optional;\n    link.dev = target.dev;\n    return link;\n  }\n\n};","map":{"version":3,"sources":["/Users/johndoe/Nebe-data-vistualization/node_modules/npm/node_modules/@npmcli/arborist/lib/arborist/load-virtual.js"],"names":["resolve","require","nameFromFolder","consistentResolve","Shrinkwrap","Node","Link","relpath","calcDepFlags","rpj","treeCheck","loadFromShrinkwrap","Symbol","resolveNodes","resolveLinks","assignBundles","loadRoot","loadNode","loadLink","loadWorkspaces","for","loadWorkspacesVirtual","flagsSuspect","reCalcDepFlags","checkRootEdges","rootOptionProvided","depsToEdges","type","deps","Object","entries","map","d","module","exports","cls","VirtualLoader","constructor","options","virtualTree","loadVirtual","root","meta","s","load","path","loadedFromDisk","er","Error","assign","code","pj","pkg","catch","data","packages","extraneous","dev","optional","devOptional","peer","links","nodes","originalLockfileVersion","values","node","isRoot","ancientLockfile","lock","get","prod","dependencies","devDependencies","optionalDependencies","peerDependencies","peerOptional","peerDependenciesMeta","name","undefined","keys","lockWS","workspaces","cwd","lockfile","push","lockEdges","sort","atype","aname","btype","bname","localeCompare","rootEdges","edgesOut","e","spec","length","i","Map","location","link","set","targetPath","resolved","targetLoc","target","parent","realpath","package","isLink","inBundle","ppkg","parentBundled","has","bundleDependencies","sw","p","legacyPeerDeps","integrity","hasShrinkwrap"],"mappings":"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","sourcesContent":["// mixin providing the loadVirtual method\n\nconst {resolve} = require('path')\n\nconst nameFromFolder = require('@npmcli/name-from-folder')\nconst consistentResolve = require('../consistent-resolve.js')\nconst Shrinkwrap = require('../shrinkwrap.js')\nconst Node = require('../node.js')\nconst Link = require('../link.js')\nconst relpath = require('../relpath.js')\nconst calcDepFlags = require('../calc-dep-flags.js')\nconst rpj = require('read-package-json-fast')\nconst treeCheck = require('../tree-check.js')\n\nconst loadFromShrinkwrap = Symbol('loadFromShrinkwrap')\nconst resolveNodes = Symbol('resolveNodes')\nconst resolveLinks = Symbol('resolveLinks')\nconst assignBundles = Symbol('assignBundles')\nconst loadRoot = Symbol('loadRoot')\nconst loadNode = Symbol('loadVirtualNode')\nconst loadLink = Symbol('loadVirtualLink')\nconst loadWorkspaces = Symbol.for('loadWorkspaces')\nconst loadWorkspacesVirtual = Symbol.for('loadWorkspacesVirtual')\nconst flagsSuspect = Symbol.for('flagsSuspect')\nconst reCalcDepFlags = Symbol('reCalcDepFlags')\nconst checkRootEdges = Symbol('checkRootEdges')\nconst rootOptionProvided = Symbol('rootOptionProvided')\n\nconst depsToEdges = (type, deps) =>\n  Object.entries(deps).map(d => [type, ...d])\n\nmodule.exports = cls => class VirtualLoader extends cls {\n  constructor (options) {\n    super(options)\n\n    // the virtual tree we load from a shrinkwrap\n    this.virtualTree = options.virtualTree\n    this[flagsSuspect] = false\n  }\n\n  // public method\n  async loadVirtual (options = {}) {\n    if (this.virtualTree)\n      return this.virtualTree\n\n    // allow the user to set reify options on the ctor as well.\n    // XXX: deprecate separate reify() options object.\n    options = { ...this.options, ...options }\n\n    if (options.root && options.root.meta) {\n      await this[loadFromShrinkwrap](options.root.meta, options.root)\n      return treeCheck(this.virtualTree)\n    }\n\n    const s = await Shrinkwrap.load({ path: this.path })\n    if (!s.loadedFromDisk && !options.root) {\n      const er = new Error('loadVirtual requires existing shrinkwrap file')\n      throw Object.assign(er, { code: 'ENOLOCK' })\n    }\n\n    // when building the ideal tree, we pass in a root node to this function\n    // otherwise, load it from the root package json or the lockfile\n    const {\n      root = await this[loadRoot](s),\n    } = options\n\n    this[rootOptionProvided] = options.root\n\n    await this[loadFromShrinkwrap](s, root)\n    return treeCheck(this.virtualTree)\n  }\n\n  async [loadRoot] (s) {\n    const pj = this.path + '/package.json'\n    const pkg = await rpj(pj).catch(() => s.data.packages['']) || {}\n    return this[loadWorkspaces](this[loadNode]('', pkg))\n  }\n\n  async [loadFromShrinkwrap] (s, root) {\n    if (!this[rootOptionProvided]) {\n      // root is never any of these things, but might be a brand new\n      // baby Node object that never had its dep flags calculated.\n      root.extraneous = false\n      root.dev = false\n      root.optional = false\n      root.devOptional = false\n      root.peer = false\n    } else\n      this[flagsSuspect] = true\n\n    this[checkRootEdges](s, root)\n    root.meta = s\n    this.virtualTree = root\n    const {links, nodes} = this[resolveNodes](s, root)\n    await this[resolveLinks](links, nodes)\n    if (!(s.originalLockfileVersion >= 2))\n      this[assignBundles](nodes)\n    if (this[flagsSuspect])\n      this[reCalcDepFlags](nodes.values())\n    return root\n  }\n\n  [reCalcDepFlags] (nodes) {\n    // reset all dep flags\n    // can't use inventory here, because virtualTree might not be root\n    for (const node of nodes) {\n      if (node.isRoot || node === this[rootOptionProvided])\n        continue\n      node.extraneous = true\n      node.dev = true\n      node.optional = true\n      node.devOptional = true\n      node.peer = true\n    }\n    calcDepFlags(this.virtualTree, !this[rootOptionProvided])\n  }\n\n  // check the lockfile deps, and see if they match.  if they do not\n  // then we have to reset dep flags at the end.  for example, if the\n  // user manually edits their package.json file, then we need to know\n  // that the idealTree is no longer entirely trustworthy.\n  [checkRootEdges] (s, root) {\n    // loaded virtually from tree, no chance of being out of sync\n    // ancient lockfiles are critically damaged by this process,\n    // so we need to just hope for the best in those cases.\n    if (!s.loadedFromDisk || s.ancientLockfile)\n      return\n\n    const lock = s.get('')\n    const prod = lock.dependencies || {}\n    const dev = lock.devDependencies || {}\n    const optional = lock.optionalDependencies || {}\n    const peer = lock.peerDependencies || {}\n    const peerOptional = {}\n    if (lock.peerDependenciesMeta) {\n      for (const [name, meta] of Object.entries(lock.peerDependenciesMeta)) {\n        if (meta.optional && peer[name] !== undefined) {\n          peerOptional[name] = peer[name]\n          delete peer[name]\n        }\n      }\n    }\n    for (const name of Object.keys(optional))\n      delete prod[name]\n\n    const lockWS = []\n    const workspaces = this[loadWorkspacesVirtual]({\n      cwd: this.path,\n      lockfile: s.data,\n    })\n    for (const [name, path] of workspaces.entries())\n      lockWS.push(['workspace', name, `file:${path}`])\n\n    const lockEdges = [\n      ...depsToEdges('prod', prod),\n      ...depsToEdges('dev', dev),\n      ...depsToEdges('optional', optional),\n      ...depsToEdges('peer', peer),\n      ...depsToEdges('peerOptional', peerOptional),\n      ...lockWS,\n    ].sort(([atype, aname], [btype, bname]) =>\n      atype.localeCompare(btype, 'en') || aname.localeCompare(bname, 'en'))\n\n    const rootEdges = [...root.edgesOut.values()]\n      .map(e => [e.type, e.name, e.spec])\n      .sort(([atype, aname], [btype, bname]) =>\n        atype.localeCompare(btype, 'en') || aname.localeCompare(bname, 'en'))\n\n    if (rootEdges.length !== lockEdges.length) {\n      // something added or removed\n      return this[flagsSuspect] = true\n    }\n\n    for (let i = 0; i < lockEdges.length; i++) {\n      if (rootEdges[i][0] !== lockEdges[i][0] ||\n          rootEdges[i][1] !== lockEdges[i][1] ||\n          rootEdges[i][2] !== lockEdges[i][2])\n        return this[flagsSuspect] = true\n    }\n  }\n\n  // separate out link metadatas, and create Node objects for nodes\n  [resolveNodes] (s, root) {\n    const links = new Map()\n    const nodes = new Map([['', root]])\n    for (const [location, meta] of Object.entries(s.data.packages)) {\n      // skip the root because we already got it\n      if (!location)\n        continue\n\n      if (meta.link)\n        links.set(location, meta)\n      else\n        nodes.set(location, this[loadNode](location, meta))\n    }\n    return {links, nodes}\n  }\n\n  // links is the set of metadata, and nodes is the map of non-Link nodes\n  // Set the targets to nodes in the set, if we have them (we might not)\n  async [resolveLinks] (links, nodes) {\n    for (const [location, meta] of links.entries()) {\n      const targetPath = resolve(this.path, meta.resolved)\n      const targetLoc = relpath(this.path, targetPath)\n      const target = nodes.get(targetLoc)\n      const link = this[loadLink](location, targetLoc, target, meta)\n      nodes.set(location, link)\n      nodes.set(targetLoc, link.target)\n\n      // we always need to read the package.json for link targets\n      // outside node_modules because they can be changed by the local user\n      if (!link.target.parent) {\n        const pj = link.realpath + '/package.json'\n        const pkg = await rpj(pj).catch(() => null)\n        if (pkg)\n          link.target.package = pkg\n      }\n    }\n  }\n\n  [assignBundles] (nodes) {\n    for (const [location, node] of nodes) {\n      // Skip assignment of parentage for the root package\n      if (!location || node.isLink && !node.target.location)\n        continue\n      const { name, parent, package: { inBundle }} = node\n\n      if (!parent)\n        continue\n\n      // read inBundle from package because 'package' here is\n      // actually a v2 lockfile metadata entry.\n      // If the *parent* is also bundled, though, or if the parent has\n      // no dependency on it, then we assume that it's being pulled in\n      // just by virtue of its parent or a transitive dep being bundled.\n      const { package: ppkg } = parent\n      const { inBundle: parentBundled } = ppkg\n      if (inBundle && !parentBundled && parent.edgesOut.has(node.name)) {\n        if (!ppkg.bundleDependencies)\n          ppkg.bundleDependencies = [name]\n        else\n          ppkg.bundleDependencies.push(name)\n      }\n    }\n  }\n\n  [loadNode] (location, sw) {\n    const p = this.virtualTree ? this.virtualTree.realpath : this.path\n    const path = resolve(p, location)\n    // shrinkwrap doesn't include package name unless necessary\n    if (!sw.name)\n      sw.name = nameFromFolder(path)\n\n    const dev = sw.dev\n    const optional = sw.optional\n    const devOptional = dev || optional || sw.devOptional\n    const peer = sw.peer\n\n    const node = new Node({\n      legacyPeerDeps: this.legacyPeerDeps,\n      root: this.virtualTree,\n      path,\n      realpath: path,\n      integrity: sw.integrity,\n      resolved: consistentResolve(sw.resolved, this.path, path),\n      pkg: sw,\n      hasShrinkwrap: sw.hasShrinkwrap,\n      dev,\n      optional,\n      devOptional,\n      peer,\n    })\n    // cast to boolean because they're undefined in the lock file when false\n    node.extraneous = !!sw.extraneous\n    node.devOptional = !!(sw.devOptional || sw.dev || sw.optional)\n    node.peer = !!sw.peer\n    node.optional = !!sw.optional\n    node.dev = !!sw.dev\n    return node\n  }\n\n  [loadLink] (location, targetLoc, target, meta) {\n    const path = resolve(this.path, location)\n    const link = new Link({\n      legacyPeerDeps: this.legacyPeerDeps,\n      path,\n      realpath: resolve(this.path, targetLoc),\n      target,\n      pkg: target && target.package,\n    })\n    link.extraneous = target.extraneous\n    link.devOptional = target.devOptional\n    link.peer = target.peer\n    link.optional = target.optional\n    link.dev = target.dev\n    return link\n  }\n}\n"]},"metadata":{},"sourceType":"script"}