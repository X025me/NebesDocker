{"ast":null,"code":"// mixin implementing the reify method\nconst onExit = require('../signal-handling.js');\n\nconst pacote = require('pacote');\n\nconst AuditReport = require('../audit-report.js');\n\nconst {\n  subset,\n  intersects\n} = require('semver');\n\nconst npa = require('npm-package-arg');\n\nconst {\n  dirname,\n  resolve,\n  relative\n} = require('path');\n\nconst {\n  depth: dfwalk\n} = require('treeverse');\n\nconst fs = require('fs');\n\nconst {\n  promisify\n} = require('util');\n\nconst symlink = promisify(fs.symlink);\n\nconst mkdirp = require('mkdirp-infer-owner');\n\nconst justMkdirp = require('mkdirp');\n\nconst moveFile = require('@npmcli/move-file');\n\nconst rimraf = promisify(require('rimraf'));\n\nconst PackageJson = require('@npmcli/package-json');\n\nconst packageContents = require('@npmcli/installed-package-contents');\n\nconst {\n  checkEngine,\n  checkPlatform\n} = require('npm-install-checks');\n\nconst treeCheck = require('../tree-check.js');\n\nconst relpath = require('../relpath.js');\n\nconst Diff = require('../diff.js');\n\nconst retirePath = require('../retire-path.js');\n\nconst promiseAllRejectLate = require('promise-all-reject-late');\n\nconst optionalSet = require('../optional-set.js');\n\nconst calcDepFlags = require('../calc-dep-flags.js');\n\nconst {\n  saveTypeMap,\n  hasSubKey\n} = require('../add-rm-pkg-deps.js');\n\nconst _retiredPaths = Symbol('retiredPaths');\n\nconst _retiredUnchanged = Symbol('retiredUnchanged');\n\nconst _sparseTreeDirs = Symbol('sparseTreeDirs');\n\nconst _sparseTreeRoots = Symbol('sparseTreeRoots');\n\nconst _savePrefix = Symbol('savePrefix');\n\nconst _retireShallowNodes = Symbol.for('retireShallowNodes');\n\nconst _getBundlesByDepth = Symbol('getBundlesByDepth');\n\nconst _registryResolved = Symbol('registryResolved');\n\nconst _addNodeToTrashList = Symbol('addNodeToTrashList');\n\nconst _workspaces = Symbol.for('workspaces'); // shared by rebuild mixin\n\n\nconst _trashList = Symbol.for('trashList');\n\nconst _handleOptionalFailure = Symbol.for('handleOptionalFailure');\n\nconst _loadTrees = Symbol.for('loadTrees'); // shared symbols for swapping out when testing\n\n\nconst _diffTrees = Symbol.for('diffTrees');\n\nconst _createSparseTree = Symbol.for('createSparseTree');\n\nconst _loadShrinkwrapsAndUpdateTrees = Symbol.for('loadShrinkwrapsAndUpdateTrees');\n\nconst _shrinkwrapInflated = Symbol('shrinkwrapInflated');\n\nconst _bundleUnpacked = Symbol('bundleUnpacked');\n\nconst _reifyNode = Symbol.for('reifyNode');\n\nconst _extractOrLink = Symbol('extractOrLink'); // defined by rebuild mixin\n\n\nconst _checkBins = Symbol.for('checkBins');\n\nconst _symlink = Symbol('symlink');\n\nconst _warnDeprecated = Symbol('warnDeprecated');\n\nconst _loadBundlesAndUpdateTrees = Symbol.for('loadBundlesAndUpdateTrees');\n\nconst _submitQuickAudit = Symbol('submitQuickAudit');\n\nconst _awaitQuickAudit = Symbol('awaitQuickAudit');\n\nconst _unpackNewModules = Symbol.for('unpackNewModules');\n\nconst _moveContents = Symbol.for('moveContents');\n\nconst _moveBackRetiredUnchanged = Symbol.for('moveBackRetiredUnchanged');\n\nconst _build = Symbol.for('build');\n\nconst _removeTrash = Symbol.for('removeTrash');\n\nconst _renamePath = Symbol.for('renamePath');\n\nconst _rollbackRetireShallowNodes = Symbol.for('rollbackRetireShallowNodes');\n\nconst _rollbackCreateSparseTree = Symbol.for('rollbackCreateSparseTree');\n\nconst _rollbackMoveBackRetiredUnchanged = Symbol.for('rollbackMoveBackRetiredUnchanged');\n\nconst _saveIdealTree = Symbol.for('saveIdealTree');\n\nconst _saveLockFile = Symbol('saveLockFile');\n\nconst _copyIdealToActual = Symbol('copyIdealToActual');\n\nconst _addOmitsToTrashList = Symbol('addOmitsToTrashList');\n\nconst _packageLockOnly = Symbol('packageLockOnly');\n\nconst _dryRun = Symbol('dryRun');\n\nconst _validatePath = Symbol('validatePath');\n\nconst _reifyPackages = Symbol('reifyPackages');\n\nconst _omitDev = Symbol('omitDev');\n\nconst _omitOptional = Symbol('omitOptional');\n\nconst _omitPeer = Symbol('omitPeer');\n\nconst _global = Symbol.for('global'); // defined by Ideal mixin\n\n\nconst _pruneBundledMetadeps = Symbol.for('pruneBundledMetadeps');\n\nconst _resolvedAdd = Symbol.for('resolvedAdd');\n\nconst _usePackageLock = Symbol.for('usePackageLock');\n\nconst _formatPackageLock = Symbol.for('formatPackageLock');\n\nmodule.exports = cls => class Reifier extends cls {\n  constructor(options) {\n    super(options);\n    const {\n      savePrefix = '^',\n      packageLockOnly = false,\n      dryRun = false,\n      formatPackageLock = true\n    } = options;\n    this[_dryRun] = !!dryRun;\n    this[_packageLockOnly] = !!packageLockOnly;\n    this[_savePrefix] = savePrefix;\n    this[_formatPackageLock] = !!formatPackageLock;\n    this.diff = null;\n    this[_retiredPaths] = {};\n    this[_shrinkwrapInflated] = new Set();\n    this[_retiredUnchanged] = {};\n    this[_sparseTreeDirs] = new Set();\n    this[_sparseTreeRoots] = new Set();\n    this[_trashList] = new Set();\n  } // public method\n\n\n  async reify(options = {}) {\n    if (this[_packageLockOnly] && this[_global]) {\n      const er = new Error('cannot generate lockfile for global packages');\n      er.code = 'ESHRINKWRAPGLOBAL';\n      throw er;\n    }\n\n    const omit = new Set(options.omit || []);\n    this[_omitDev] = omit.has('dev');\n    this[_omitOptional] = omit.has('optional');\n    this[_omitPeer] = omit.has('peer'); // start tracker block\n\n    this.addTracker('reify');\n    process.emit('time', 'reify');\n    await this[_validatePath]();\n    await this[_loadTrees](options);\n    await this[_diffTrees]();\n    await this[_reifyPackages]();\n    await this[_saveIdealTree](options);\n    await this[_copyIdealToActual]();\n    await this[_awaitQuickAudit]();\n    this.finishTracker('reify');\n    process.emit('timeEnd', 'reify');\n    return treeCheck(this.actualTree);\n  }\n\n  async [_validatePath]() {\n    // don't create missing dirs on dry runs\n    if (this[_packageLockOnly] || this[_dryRun]) return; // we do NOT want to set ownership on this folder, especially\n    // recursively, because it can have other side effects to do that\n    // in a project directory.  We just want to make it if it's missing.\n\n    await justMkdirp(resolve(this.path));\n  }\n\n  async [_reifyPackages]() {\n    // we don't submit the audit report or write to disk on dry runs\n    if (this[_dryRun]) return;\n\n    if (this[_packageLockOnly]) {\n      // we already have the complete tree, so just audit it now,\n      // and that's all we have to do here.\n      return this[_submitQuickAudit]();\n    } // ok, we're about to start touching the fs.  need to roll back\n    // if we get an early termination.\n\n\n    let reifyTerminated = null;\n    const removeHandler = onExit(({\n      signal\n    }) => {\n      // only call once.  if signal hits twice, we just terminate\n      removeHandler();\n      reifyTerminated = Object.assign(new Error('process terminated'), {\n        signal\n      });\n      return false;\n    }); // [rollbackfn, [...actions]]\n    // after each step, if the process was terminated, execute the rollback\n    // note that each rollback *also* calls the previous one when it's\n    // finished, and then the first one throws the error, so we only need\n    // a new rollback step when we have a new thing that must be done to\n    // revert the install.\n\n    const steps = [[_rollbackRetireShallowNodes, [_retireShallowNodes]], [_rollbackCreateSparseTree, [_createSparseTree, _addOmitsToTrashList, _loadShrinkwrapsAndUpdateTrees, _loadBundlesAndUpdateTrees, _submitQuickAudit, _unpackNewModules]], [_rollbackMoveBackRetiredUnchanged, [_moveBackRetiredUnchanged, _build]]];\n\n    for (const [rollback, actions] of steps) {\n      for (const action of actions) {\n        try {\n          await this[action]();\n          if (reifyTerminated) throw reifyTerminated;\n        } catch (er) {\n          await this[rollback](er);\n          /* istanbul ignore next - rollback throws, should never hit this */\n\n          throw er;\n        }\n      }\n    } // no rollback for this one, just exit with the error, since the\n    // install completed and can't be safely recovered at this point.\n\n\n    await this[_removeTrash]();\n    if (reifyTerminated) throw reifyTerminated; // done modifying the file system, no need to keep listening for sigs\n\n    removeHandler();\n  } // when doing a local install, we load everything and figure it all out.\n  // when doing a global install, we *only* care about the explicit requests.\n\n\n  [_loadTrees](options) {\n    process.emit('time', 'reify:loadTrees');\n    const bitOpt = { ...options,\n      complete: this[_packageLockOnly] || this[_dryRun]\n    }; // if we're only writing a package lock, then it doesn't matter what's here\n\n    if (this[_packageLockOnly]) {\n      return this.buildIdealTree(bitOpt).then(() => process.emit('timeEnd', 'reify:loadTrees'));\n    }\n\n    const actualOpt = this[_global] ? {\n      ignoreMissing: true,\n      global: true,\n      filter: (node, kid) => {\n        // if it's not the project root, and we have no explicit requests,\n        // then we're already into a nested dep, so we keep it\n        if (this.explicitRequests.size === 0 || !node.isProjectRoot) return true; // if we added it as an edgeOut, then we want it\n\n        if (this.idealTree.edgesOut.has(kid)) return true; // if it's an explicit request, then we want it\n\n        const hasExplicit = [...this.explicitRequests].some(edge => edge.name === kid);\n        if (hasExplicit) return true; // ignore the rest of the global install folder\n\n        return false;\n      }\n    } : {\n      ignoreMissing: true\n    };\n\n    if (!this[_global]) {\n      return Promise.all([this.loadActual(actualOpt), this.buildIdealTree(bitOpt)]).then(() => process.emit('timeEnd', 'reify:loadTrees'));\n    } // the global install space tends to have a lot of stuff in it.  don't\n    // load all of it, just what we care about.  we won't be saving a\n    // hidden lockfile in there anyway.  Note that we have to load ideal\n    // BEFORE loading actual, so that the actualOpt can use the\n    // explicitRequests which is set during buildIdealTree\n\n\n    return this.buildIdealTree(bitOpt).then(() => this.loadActual(actualOpt)).then(() => process.emit('timeEnd', 'reify:loadTrees'));\n  }\n\n  [_diffTrees]() {\n    if (this[_packageLockOnly]) return;\n    process.emit('time', 'reify:diffTrees'); // XXX if we have an existing diff already, there should be a way\n    // to just invalidate the parts that changed, but avoid walking the\n    // whole tree again.\n\n    const filterNodes = [];\n\n    if (this[_global] && this.explicitRequests.size) {\n      const idealTree = this.idealTree.target;\n      const actualTree = this.actualTree.target; // we ONLY are allowed to make changes in the global top-level\n      // children where there's an explicit request.\n\n      for (const {\n        name\n      } of this.explicitRequests) {\n        const ideal = idealTree.children.get(name);\n        if (ideal) filterNodes.push(ideal);\n        const actual = actualTree.children.get(name);\n        if (actual) filterNodes.push(actual);\n      }\n    } else {\n      for (const ws of this[_workspaces]) {\n        const ideal = this.idealTree.children.get(ws);\n        if (ideal) filterNodes.push(ideal);\n        const actual = this.actualTree.children.get(ws);\n        if (actual) filterNodes.push(actual);\n      }\n    } // find all the nodes that need to change between the actual\n    // and ideal trees.\n\n\n    this.diff = Diff.calculate({\n      shrinkwrapInflated: this[_shrinkwrapInflated],\n      filterNodes,\n      actual: this.actualTree,\n      ideal: this.idealTree\n    });\n\n    for (const node of this.diff.removed) {\n      // a node in a dep bundle will only be removed if its bundling dep\n      // is removed as well.  in which case, we don't have to delete it!\n      if (!node.inDepBundle) this[_addNodeToTrashList](node);\n    }\n\n    process.emit('timeEnd', 'reify:diffTrees');\n  } // add the node and all its bins to the list of things to be\n  // removed later on in the process.  optionally, also mark them\n  // as a retired paths, so that we move them out of the way and\n  // replace them when rolling back on failure.\n\n\n  [_addNodeToTrashList](node, retire) {\n    const paths = [node.path, ...node.binPaths];\n    const moves = this[_retiredPaths];\n    this.log.silly('reify', 'mark', retire ? 'retired' : 'deleted', paths);\n\n    for (const path of paths) {\n      if (retire) {\n        const retired = retirePath(path);\n        moves[path] = retired;\n\n        this[_trashList].add(retired);\n      } else this[_trashList].add(path);\n    }\n  } // move aside the shallowest nodes in the tree that have to be\n  // changed or removed, so that we can rollback if necessary.\n\n\n  [_retireShallowNodes]() {\n    process.emit('time', 'reify:retireShallow');\n    const moves = this[_retiredPaths] = {};\n\n    for (const diff of this.diff.children) {\n      if (diff.action === 'CHANGE' || diff.action === 'REMOVE') {\n        // we'll have to clean these up at the end, so add them to the list\n        this[_addNodeToTrashList](diff.actual, true);\n      }\n    }\n\n    this.log.silly('reify', 'moves', moves);\n    const movePromises = Object.entries(moves).map(([from, to]) => this[_renamePath](from, to));\n    return promiseAllRejectLate(movePromises).then(() => process.emit('timeEnd', 'reify:retireShallow'));\n  }\n\n  [_renamePath](from, to, didMkdirp = false) {\n    return moveFile(from, to).catch(er => {\n      // Occasionally an expected bin file might not exist in the package,\n      // or a shim/symlink might have been moved aside.  If we've already\n      // handled the most common cause of ENOENT (dir doesn't exist yet),\n      // then just ignore any ENOENT.\n      if (er.code === 'ENOENT') {\n        return didMkdirp ? null : mkdirp(dirname(to)).then(() => this[_renamePath](from, to, true));\n      } else if (er.code === 'EEXIST') return rimraf(to).then(() => moveFile(from, to));else throw er;\n    });\n  }\n\n  [_rollbackRetireShallowNodes](er) {\n    process.emit('time', 'reify:rollback:retireShallow');\n    const moves = this[_retiredPaths];\n    const movePromises = Object.entries(moves).map(([from, to]) => this[_renamePath](to, from));\n    return promiseAllRejectLate(movePromises) // ignore subsequent rollback errors\n    .catch(er => {}).then(() => process.emit('timeEnd', 'reify:rollback:retireShallow')).then(() => {\n      throw er;\n    });\n  } // adding to the trash list will skip reifying, and delete them\n  // if they are currently in the tree and otherwise untouched.\n\n\n  [_addOmitsToTrashList]() {\n    if (!this[_omitDev] && !this[_omitOptional] && !this[_omitPeer]) return;\n    process.emit('time', 'reify:trashOmits');\n\n    const filter = node => node.top.isProjectRoot && (node.peer && this[_omitPeer] || node.dev && this[_omitDev] || node.optional && this[_omitOptional] || node.devOptional && this[_omitOptional] && this[_omitDev]);\n\n    for (const node of this.idealTree.inventory.filter(filter)) this[_addNodeToTrashList](node);\n\n    process.emit('timeEnd', 'reify:trashOmits');\n  }\n\n  [_createSparseTree]() {\n    process.emit('time', 'reify:createSparse'); // if we call this fn again, we look for the previous list\n    // so that we can avoid making the same directory multiple times\n\n    const dirs = this.diff.leaves.filter(diff => {\n      return (diff.action === 'ADD' || diff.action === 'CHANGE') && !this[_sparseTreeDirs].has(diff.ideal.path) && !diff.ideal.isLink;\n    }).map(diff => diff.ideal.path);\n    return promiseAllRejectLate(dirs.map(d => mkdirp(d))).then(made => {\n      made.forEach(made => this[_sparseTreeRoots].add(made));\n      dirs.forEach(dir => this[_sparseTreeDirs].add(dir));\n    }).then(() => process.emit('timeEnd', 'reify:createSparse'));\n  }\n\n  [_rollbackCreateSparseTree](er) {\n    process.emit('time', 'reify:rollback:createSparse'); // cut the roots of the sparse tree that were created, not the leaves\n\n    const roots = this[_sparseTreeRoots]; // also delete the moves that we retired, so that we can move them back\n\n    const failures = [];\n    const targets = [...roots, ...Object.keys(this[_retiredPaths])];\n    const unlinks = targets.map(path => rimraf(path).catch(er => failures.push([path, er])));\n    return promiseAllRejectLate(unlinks).then(() => {\n      if (failures.length) this.log.warn('cleanup', 'Failed to remove some directories', failures);\n    }).then(() => process.emit('timeEnd', 'reify:rollback:createSparse')).then(() => this[_rollbackRetireShallowNodes](er));\n  } // shrinkwrap nodes define their dependency branches with a file, so\n  // we need to unpack them, read that shrinkwrap file, and then update\n  // the tree by calling loadVirtual with the node as the root.\n\n\n  [_loadShrinkwrapsAndUpdateTrees]() {\n    const seen = this[_shrinkwrapInflated];\n    const shrinkwraps = this.diff.leaves.filter(d => (d.action === 'CHANGE' || d.action === 'ADD' || !d.action) && d.ideal.hasShrinkwrap && !seen.has(d.ideal) && !this[_trashList].has(d.ideal.path));\n    if (!shrinkwraps.length) return;\n    process.emit('time', 'reify:loadShrinkwraps');\n    const Arborist = this.constructor;\n    return promiseAllRejectLate(shrinkwraps.map(diff => {\n      const node = diff.ideal;\n      seen.add(node);\n      return diff.action ? this[_reifyNode](node) : node;\n    })).then(nodes => promiseAllRejectLate(nodes.map(node => new Arborist({ ...this.options,\n      path: node.path\n    }).loadVirtual({\n      root: node\n    })))) // reload the diff and sparse tree because the ideal tree changed\n    .then(() => this[_diffTrees]()).then(() => this[_createSparseTree]()).then(() => this[_addOmitsToTrashList]()).then(() => this[_loadShrinkwrapsAndUpdateTrees]()).then(() => process.emit('timeEnd', 'reify:loadShrinkwraps'));\n  } // create a symlink for Links, extract for Nodes\n  // return the node object, since we usually want that\n  // handle optional dep failures here\n  // If node is in trash list, skip it\n  // If reifying fails, and the node is optional, add it and its optionalSet\n  // to the trash list\n  // Always return the node.\n\n\n  [_reifyNode](node) {\n    if (this[_trashList].has(node.path)) return node;\n    const timer = `reifyNode:${node.location}`;\n    process.emit('time', timer);\n    this.addTracker('reify', node.name, node.location);\n    const {\n      npmVersion,\n      nodeVersion\n    } = this.options;\n    const p = Promise.resolve().then(async () => {\n      // when we reify an optional node, check the engine and platform\n      // first. be sure to ignore the --force and --engine-strict flags,\n      // since we always want to skip any optional packages we can't install.\n      // these checks throwing will result in a rollback and removal\n      // of the mismatches\n      if (node.optional) {\n        checkEngine(node.package, npmVersion, nodeVersion, false);\n        checkPlatform(node.package, false);\n      }\n\n      await this[_checkBins](node);\n      await this[_extractOrLink](node);\n      await this[_warnDeprecated](node);\n    });\n    return this[_handleOptionalFailure](node, p).then(() => {\n      this.finishTracker('reify', node.name, node.location);\n      process.emit('timeEnd', timer);\n      return node;\n    });\n  }\n\n  [_extractOrLink](node) {\n    // in normal cases, node.resolved should *always* be set by now.\n    // however, it is possible when a lockfile is damaged, or very old,\n    // or in some other race condition bugs in npm v6, that a previously\n    // bundled dependency will have just a version, but no resolved value,\n    // and no 'bundled: true' setting.\n    // Do the best with what we have, or else remove it from the tree\n    // entirely, since we can't possibly reify it.\n    const res = node.resolved ? `${node.name}@${this[_registryResolved](node.resolved)}` : node.packageName && node.version ? `${node.packageName}@${node.version}` : null; // no idea what this thing is.  remove it from the tree.\n\n    if (!res) {\n      const warning = 'invalid or damaged lockfile detected\\n' + 'please re-try this operation once it completes\\n' + 'so that the damage can be corrected, or perform\\n' + 'a fresh install with no lockfile if the problem persists.';\n      this.log.warn('reify', warning);\n      this.log.verbose('reify', 'unrecognized node in tree', node.path);\n      node.parent = null;\n      node.fsParent = null;\n\n      this[_addNodeToTrashList](node);\n\n      return;\n    }\n\n    return node.isLink ? rimraf(node.path).then(() => this[_symlink](node)) : pacote.extract(res, node.path, { ...this.options,\n      resolved: node.resolved,\n      integrity: node.integrity\n    });\n  }\n\n  async [_symlink](node) {\n    const dir = dirname(node.path);\n    const target = node.realpath;\n    const rel = relative(dir, target);\n    await mkdirp(dir);\n    return symlink(rel, node.path, 'junction');\n  }\n\n  [_warnDeprecated](node) {\n    const {\n      _id,\n      deprecated\n    } = node.package;\n    if (deprecated) this.log.warn('deprecated', `${_id}: ${deprecated}`);\n  } // if the node is optional, then the failure of the promise is nonfatal\n  // just add it and its optional set to the trash list.\n\n\n  [_handleOptionalFailure](node, p) {\n    return (node.optional ? p.catch(er => {\n      const set = optionalSet(node);\n\n      for (node of set) {\n        this.log.verbose('reify', 'failed optional dependency', node.path);\n\n        this[_addNodeToTrashList](node);\n      }\n    }) : p).then(() => node);\n  }\n\n  [_registryResolved](resolved) {\n    // the default registry url is a magic value meaning \"the currently\n    // configured registry\".\n    //\n    // XXX: use a magic string that isn't also a valid value, like\n    // ${REGISTRY} or something.  This has to be threaded through the\n    // Shrinkwrap and Node classes carefully, so for now, just treat\n    // the default reg as the magical animal that it has been.\n    return resolved && resolved.replace(/^https?:\\/\\/registry.npmjs.org\\//, this.registry);\n  } // bundles are *sort of* like shrinkwraps, in that the branch is defined\n  // by the contents of the package.  however, in their case, rather than\n  // shipping a virtual tree that must be reified, they ship an entire\n  // reified actual tree that must be unpacked and not modified.\n\n\n  [_loadBundlesAndUpdateTrees](depth = 0, bundlesByDepth = this[_getBundlesByDepth]()) {\n    if (depth === 0) {\n      this[_bundleUnpacked] = new Set();\n      process.emit('time', 'reify:loadBundles');\n    }\n\n    const maxBundleDepth = bundlesByDepth.get('maxBundleDepth');\n\n    if (depth > maxBundleDepth) {\n      // if we did something, then prune the tree and update the diffs\n      if (maxBundleDepth !== -1) {\n        this[_pruneBundledMetadeps](bundlesByDepth);\n\n        this[_diffTrees]();\n      }\n\n      process.emit('timeEnd', 'reify:loadBundles');\n      return;\n    } // skip any that have since been removed from the tree, eg by a\n    // shallower bundle overwriting them with a bundled meta-dep.\n\n\n    const set = (bundlesByDepth.get(depth) || []).filter(node => node.root === this.idealTree && node.target !== node.root && !this[_trashList].has(node.path));\n    if (!set.length) return this[_loadBundlesAndUpdateTrees](depth + 1, bundlesByDepth); // extract all the nodes with bundles\n\n    return promiseAllRejectLate(set.map(node => {\n      this[_bundleUnpacked].add(node);\n\n      return this[_reifyNode](node);\n    })) // then load their unpacked children and move into the ideal tree\n    .then(nodes => promiseAllRejectLate(nodes.map(node => new this.constructor({ ...this.options,\n      path: node.path\n    }).loadActual({\n      root: node,\n      // don't transplant any sparse folders we created\n      transplantFilter: node => node.package._id\n    })))) // move onto the next level of bundled items\n    .then(() => this[_loadBundlesAndUpdateTrees](depth + 1, bundlesByDepth));\n  }\n\n  [_getBundlesByDepth]() {\n    const bundlesByDepth = new Map();\n    let maxBundleDepth = -1;\n    dfwalk({\n      tree: this.diff,\n      visit: diff => {\n        const node = diff.ideal;\n        if (!node) return;\n        if (node.isProjectRoot) return;\n        const {\n          bundleDependencies\n        } = node.package;\n\n        if (bundleDependencies && bundleDependencies.length) {\n          maxBundleDepth = Math.max(maxBundleDepth, node.depth);\n          if (!bundlesByDepth.has(node.depth)) bundlesByDepth.set(node.depth, [node]);else bundlesByDepth.get(node.depth).push(node);\n        }\n      },\n      getChildren: diff => diff.children\n    });\n    bundlesByDepth.set('maxBundleDepth', maxBundleDepth);\n    return bundlesByDepth;\n  } // https://github.com/npm/cli/issues/1597#issuecomment-667639545\n\n\n  [_pruneBundledMetadeps](bundlesByDepth) {\n    const bundleShadowed = new Set(); // create the list of nodes shadowed by children of bundlers\n\n    for (const bundles of bundlesByDepth.values()) {\n      // skip the 'maxBundleDepth' item\n      if (!Array.isArray(bundles)) continue;\n\n      for (const node of bundles) {\n        for (const name of node.children.keys()) {\n          const shadow = node.parent.resolve(name);\n          if (!shadow) continue;\n          bundleShadowed.add(shadow);\n          shadow.extraneous = true;\n        }\n      }\n    }\n\n    let changed = true;\n\n    while (changed) {\n      changed = false;\n\n      for (const shadow of bundleShadowed) {\n        if (!shadow.extraneous) {\n          bundleShadowed.delete(shadow);\n          continue;\n        }\n\n        for (const edge of shadow.edgesIn) {\n          if (!edge.from.extraneous) {\n            shadow.extraneous = false;\n            bundleShadowed.delete(shadow);\n            changed = true;\n          } else {\n            for (const shadDep of shadow.edgesOut.values()) {\n              /* istanbul ignore else - pretty unusual situation, just being\n               * defensive here. Would mean that a bundled dep has a dependency\n               * that is unmet. which, weird, but if you bundle it, we take\n               * whatever you put there and assume the publisher knows best. */\n              if (shadDep.to) bundleShadowed.add(shadDep.to);\n            }\n          }\n        }\n      }\n    }\n\n    for (const shadow of bundleShadowed) {\n      shadow.parent = null;\n\n      this[_addNodeToTrashList](shadow);\n    }\n  }\n\n  [_submitQuickAudit]() {\n    if (this.options.audit === false) return this.auditReport = null; // we submit the quick audit at this point in the process, as soon as\n    // we have all the deps resolved, so that it can overlap with the other\n    // actions as much as possible.  Stash the promise, which we resolve\n    // before finishing the reify() and returning the tree.  Thus, we do\n    // NOT return the promise, as the intent is for this to run in parallel\n    // with the reification, and be resolved at a later time.\n\n    process.emit('time', 'reify:audit');\n    const options = { ...this.options\n    };\n    const tree = this.idealTree; // if we're operating on a workspace, only audit the workspace deps\n\n    if (this[_workspaces] && this[_workspaces].length) options.filterSet = this.workspaceDependencySet(tree, this[_workspaces]);\n    this.auditReport = AuditReport.load(tree, options).then(res => {\n      process.emit('timeEnd', 'reify:audit');\n      this.auditReport = res;\n    });\n  } // return the promise if we're waiting for it, or the replaced result\n\n\n  [_awaitQuickAudit]() {\n    return this.auditReport;\n  } // ok!  actually unpack stuff into their target locations!\n  // The sparse tree has already been created, so we walk the diff\n  // kicking off each unpack job.  If any fail, we rimraf the sparse\n  // tree entirely and try to put everything back where it was.\n\n\n  [_unpackNewModules]() {\n    process.emit('time', 'reify:unpack');\n    const unpacks = [];\n    dfwalk({\n      tree: this.diff,\n      visit: diff => {\n        // no unpacking if we don't want to change this thing\n        if (diff.action !== 'CHANGE' && diff.action !== 'ADD') return;\n        const node = diff.ideal;\n\n        const bd = this[_bundleUnpacked].has(node);\n\n        const sw = this[_shrinkwrapInflated].has(node); // check whether we still need to unpack this one.\n        // test the inDepBundle last, since that's potentially a tree walk.\n\n\n        const doUnpack = node && // can't unpack if removed!\n        !node.isRoot && // root node already exists\n        !bd && // already unpacked to read bundle\n        !sw && // already unpacked to read sw\n        !node.inDepBundle; // already unpacked by another dep's bundle\n\n        if (doUnpack) unpacks.push(this[_reifyNode](node));\n      },\n      getChildren: diff => diff.children\n    });\n    return promiseAllRejectLate(unpacks).then(() => process.emit('timeEnd', 'reify:unpack'));\n  } // This is the part where we move back the unchanging nodes that were\n  // the children of a node that did change.  If this fails, the rollback\n  // is a three-step process.  First, we try to move the retired unchanged\n  // nodes BACK to their retirement folders, then delete the sparse tree,\n  // then move everything out of retirement.\n\n\n  [_moveBackRetiredUnchanged]() {\n    // get a list of all unchanging children of any shallow retired nodes\n    // if they are not the ancestor of any node in the diff set, then the\n    // directory won't already exist, so just rename it over.\n    // This is sort of an inverse diff tree, of all the nodes where\n    // the actualTree and idealTree _don't_ differ, starting from the\n    // shallowest nodes that we moved aside in the first place.\n    process.emit('time', 'reify:unretire');\n    const moves = this[_retiredPaths];\n    this[_retiredUnchanged] = {};\n    return promiseAllRejectLate(this.diff.children.map(diff => {\n      const realFolder = (diff.actual || diff.ideal).path;\n      const retireFolder = moves[realFolder];\n      this[_retiredUnchanged][retireFolder] = [];\n      return promiseAllRejectLate(diff.unchanged.map(node => {\n        // no need to roll back links, since we'll just delete them anyway\n        if (node.isLink) return mkdirp(dirname(node.path)).then(() => this[_reifyNode](node)); // will have been moved/unpacked along with bundler\n\n        if (node.inDepBundle) return;\n\n        this[_retiredUnchanged][retireFolder].push(node);\n\n        const rel = relative(realFolder, node.path);\n        const fromPath = resolve(retireFolder, rel); // if it has bundleDependencies, then make node_modules.  otherwise\n        // skip it.\n\n        const bd = node.package.bundleDependencies;\n        const dir = bd && bd.length ? node.path + '/node_modules' : node.path;\n        return mkdirp(dir).then(() => this[_moveContents](node, fromPath));\n      }));\n    })).then(() => process.emit('timeEnd', 'reify:unretire'));\n  } // move the contents from the fromPath to the node.path\n\n\n  [_moveContents](node, fromPath) {\n    return packageContents({\n      path: fromPath,\n      depth: 1,\n      packageJsonCache: new Map([[fromPath + '/package.json', node.package]])\n    }).then(res => promiseAllRejectLate(res.map(path => {\n      const rel = relative(fromPath, path);\n      const to = resolve(node.path, rel);\n      return this[_renamePath](path, to);\n    })));\n  }\n\n  [_rollbackMoveBackRetiredUnchanged](er) {\n    const moves = this[_retiredPaths]; // flip the mapping around to go back\n\n    const realFolders = new Map(Object.entries(moves).map(([k, v]) => [v, k]));\n    const promises = Object.entries(this[_retiredUnchanged]).map(([retireFolder, nodes]) => promiseAllRejectLate(nodes.map(node => {\n      const realFolder = realFolders.get(retireFolder);\n      const rel = relative(realFolder, node.path);\n      const fromPath = resolve(retireFolder, rel);\n      return this[_moveContents]({ ...node,\n        path: fromPath\n      }, node.path);\n    })));\n    return promiseAllRejectLate(promises).then(() => this[_rollbackCreateSparseTree](er));\n  }\n\n  [_build]() {\n    process.emit('time', 'reify:build'); // for all the things being installed, run their appropriate scripts\n    // run in tip->root order, so as to be more likely to build a node's\n    // deps before attempting to build it itself\n\n    const nodes = [];\n    dfwalk({\n      tree: this.diff,\n      leave: diff => {\n        if (!diff.ideal.isProjectRoot) nodes.push(diff.ideal);\n      },\n      // process adds before changes, ignore removals\n      getChildren: diff => diff && diff.children,\n      filter: diff => diff.action === 'ADD' || diff.action === 'CHANGE'\n    }); // pick up link nodes from the unchanged list as we want to run their\n    // scripts in every install despite of having a diff status change\n\n    for (const node of this.diff.unchanged) {\n      const tree = node.root.target; // skip links that only live within node_modules as they are most\n      // likely managed by packages we installed, we only want to rebuild\n      // unchanged links we directly manage\n\n      if (node.isLink && node.target.fsTop === tree) nodes.push(node);\n    }\n\n    return this.rebuild({\n      nodes,\n      handleOptionalFailure: true\n    }).then(() => process.emit('timeEnd', 'reify:build'));\n  } // the tree is pretty much built now, so it's cleanup time.\n  // remove the retired folders, and any deleted nodes\n  // If this fails, there isn't much we can do but tell the user about it.\n  // Thankfully, it's pretty unlikely that it'll fail, since rimraf is a tank.\n\n\n  [_removeTrash]() {\n    process.emit('time', 'reify:trash');\n    const promises = [];\n    const failures = [];\n\n    const rm = path => rimraf(path).catch(er => failures.push([path, er]));\n\n    for (const path of this[_trashList]) promises.push(rm(path));\n\n    return promiseAllRejectLate(promises).then(() => {\n      if (failures.length) this.log.warn('cleanup', 'Failed to remove some directories', failures);\n    }).then(() => process.emit('timeEnd', 'reify:trash'));\n  } // last but not least, we save the ideal tree metadata to the package-lock\n  // or shrinkwrap file, and any additions or removals to package.json\n\n\n  async [_saveIdealTree](options) {\n    // the ideal tree is actualized now, hooray!\n    // it still contains all the references to optional nodes that were removed\n    // for install failures.  Those still end up in the shrinkwrap, so we\n    // save it first, then prune out the optional trash, and then return it.\n    // support save=false option\n    if (options.save === false || this[_global] || this[_dryRun]) return false;\n    process.emit('time', 'reify:save');\n    const updatedTrees = new Set(); // resolvedAdd is the list of user add requests, but with names added\n    // to things like git repos and tarball file/urls.  However, if the\n    // user requested 'foo@', and we have a foo@file:../foo, then we should\n    // end up saving the spec we actually used, not whatever they gave us.\n\n    if (this[_resolvedAdd].length) {\n      for (const {\n        name,\n        tree: addTree\n      } of this[_resolvedAdd]) {\n        // addTree either the root, or a workspace\n        const edge = addTree.edgesOut.get(name);\n        const pkg = addTree.package;\n        const req = npa.resolve(name, edge.spec, addTree.realpath);\n        const {\n          rawSpec,\n          subSpec\n        } = req;\n        const spec = subSpec ? subSpec.rawSpec : rawSpec;\n        const child = edge.to;\n        let newSpec;\n\n        if (req.registry) {\n          const version = child.version;\n          const prefixRange = version ? this[_savePrefix] + version : '*'; // if we installed a range, then we save the range specified\n          // if it is not a subset of the ^x.y.z.  eg, installing a range\n          // of `1.x <1.2.3` will not be saved as `^1.2.0`, because that\n          // would allow versions outside the requested range.  Tags and\n          // specific versions save with the save-prefix.\n\n          const isRange = (subSpec || req).type === 'range';\n          let range = spec;\n          if (!isRange || spec === '*' || subset(prefixRange, spec, {\n            loose: true\n          })) range = prefixRange;\n          const pname = child.packageName;\n          const alias = name !== pname;\n          newSpec = alias ? `npm:${pname}@${range}` : range;\n        } else if (req.hosted) {\n          // save the git+https url if it has auth, otherwise shortcut\n          const h = req.hosted;\n          const opt = {\n            noCommittish: false\n          };\n          if (h.https && h.auth) newSpec = `git+${h.https(opt)}`;else newSpec = h.shortcut(opt);\n        } else if (req.type === 'directory' || req.type === 'file') {\n          // save the relative path in package.json\n          // Normally saveSpec is updated with the proper relative\n          // path already, but it's possible to specify a full absolute\n          // path initially, in which case we can end up with the wrong\n          // thing, so just get the ultimate fetchSpec and relativize it.\n          const p = req.fetchSpec.replace(/^file:/, '');\n          const rel = relpath(addTree.realpath, p);\n          newSpec = `file:${rel}`;\n        } else newSpec = req.saveSpec;\n\n        if (options.saveType) {\n          const depType = saveTypeMap.get(options.saveType);\n          pkg[depType][name] = newSpec; // rpj will have moved it here if it was in both\n          // if it is empty it will be deleted later\n\n          if (options.saveType === 'prod' && pkg.optionalDependencies) delete pkg.optionalDependencies[name];\n        } else {\n          if (hasSubKey(pkg, 'dependencies', name)) pkg.dependencies[name] = newSpec;\n\n          if (hasSubKey(pkg, 'devDependencies', name)) {\n            pkg.devDependencies[name] = newSpec; // don't update peer or optional if we don't have to\n\n            if (hasSubKey(pkg, 'peerDependencies', name) && !intersects(newSpec, pkg.peerDependencies[name])) pkg.peerDependencies[name] = newSpec;\n            if (hasSubKey(pkg, 'optionalDependencies', name) && !intersects(newSpec, pkg.optionalDependencies[name])) pkg.optionalDependencies[name] = newSpec;\n          } else {\n            if (hasSubKey(pkg, 'peerDependencies', name)) pkg.peerDependencies[name] = newSpec;\n            if (hasSubKey(pkg, 'optionalDependencies', name)) pkg.optionalDependencies[name] = newSpec;\n          }\n        }\n\n        updatedTrees.add(addTree);\n      }\n    } // preserve indentation, if possible\n\n\n    const {\n      [Symbol.for('indent')]: indent\n    } = this.idealTree.package;\n    const format = indent === undefined ? '  ' : indent;\n    const saveOpt = {\n      format: this[_formatPackageLock] && format ? format : this[_formatPackageLock]\n    };\n    const promises = [this[_saveLockFile](saveOpt)];\n\n    const updatePackageJson = async tree => {\n      const pkgJson = await PackageJson.load(tree.path).catch(() => new PackageJson(tree.path));\n      const {\n        dependencies = {},\n        devDependencies = {},\n        optionalDependencies = {},\n        peerDependencies = {}\n      } = tree.package;\n      pkgJson.update({\n        dependencies,\n        devDependencies,\n        optionalDependencies,\n        peerDependencies\n      });\n      await pkgJson.save();\n    }; // grab any from explicitRequests that had deps removed\n\n\n    for (const {\n      from: tree\n    } of this.explicitRequests) updatedTrees.add(tree);\n\n    for (const tree of updatedTrees) {\n      // refresh the edges so they have the correct specs\n      tree.package = tree.package;\n      promises.push(updatePackageJson(tree));\n    }\n\n    await Promise.all(promises);\n    process.emit('timeEnd', 'reify:save');\n    return true;\n  }\n\n  async [_saveLockFile](saveOpt) {\n    if (!this[_usePackageLock]) return;\n    const {\n      meta\n    } = this.idealTree;\n    return meta.save(saveOpt);\n  }\n\n  async [_copyIdealToActual]() {\n    // clean up any trash that is still in the tree\n    for (const path of this[_trashList]) {\n      const loc = relpath(this.idealTree.realpath, path);\n      const node = this.idealTree.inventory.get(loc);\n      if (node && node.root === this.idealTree) node.parent = null;\n    } // if we filtered to only certain nodes, then anything ELSE needs\n    // to be untouched in the resulting actual tree, even if it differs\n    // in the idealTree.  Copy over anything that was in the actual and\n    // was not changed, delete anything in the ideal and not actual.\n    // Then we move the entire idealTree over to this.actualTree, and\n    // save the hidden lockfile.\n\n\n    if (this.diff && this.diff.filterSet.size) {\n      const reroot = new Set();\n      const {\n        filterSet\n      } = this.diff;\n      const seen = new Set();\n\n      for (const [loc, ideal] of this.idealTree.inventory.entries()) {\n        seen.add(loc); // if it's an ideal node from the filter set, then skip it\n        // because we already made whatever changes were necessary\n\n        if (filterSet.has(ideal)) continue; // otherwise, if it's not in the actualTree, then it's not a thing\n        // that we actually added.  And if it IS in the actualTree, then\n        // it's something that we left untouched, so we need to record\n        // that.\n\n        const actual = this.actualTree.inventory.get(loc);\n        if (!actual) ideal.root = null;else {\n          if ([...actual.linksIn].some(link => filterSet.has(link))) {\n            seen.add(actual.location);\n            continue;\n          }\n\n          const {\n            realpath,\n            isLink\n          } = actual;\n          if (isLink && ideal.isLink && ideal.realpath === realpath) continue;else reroot.add(actual);\n        }\n      } // now find any actual nodes that may not be present in the ideal\n      // tree, but were left behind by virtue of not being in the filter\n\n\n      for (const [loc, actual] of this.actualTree.inventory.entries()) {\n        if (seen.has(loc)) continue;\n        seen.add(loc); // we know that this is something that ISN'T in the idealTree,\n        // or else we will have addressed it in the previous loop.\n        // If it's in the filterSet, that means we intentionally removed\n        // it, so nothing to do here.\n\n        if (filterSet.has(actual)) continue;\n        reroot.add(actual);\n      } // go through the rerooted actual nodes, and move them over.\n\n\n      for (const actual of reroot) actual.root = this.idealTree; // prune out any tops that lack a linkIn, they are no longer relevant.\n\n\n      for (const top of this.idealTree.tops) {\n        if (top.linksIn.size === 0) top.root = null;\n      } // need to calculate dep flags, since nodes may have been marked\n      // as extraneous or otherwise incorrect during transit.\n\n\n      calcDepFlags(this.idealTree);\n    } // save the ideal's meta as a hidden lockfile after we actualize it\n\n\n    this.idealTree.meta.filename = this.idealTree.realpath + '/node_modules/.package-lock.json';\n    this.idealTree.meta.hiddenLockfile = true;\n    this.actualTree = this.idealTree;\n    this.idealTree = null;\n    if (!this[_global]) await this.actualTree.meta.save();\n  }\n\n};","map":{"version":3,"sources":["/Users/johndoe/Nebe-data-vistualization/node_modules/npm/node_modules/@npmcli/arborist/lib/arborist/reify.js"],"names":["onExit","require","pacote","AuditReport","subset","intersects","npa","dirname","resolve","relative","depth","dfwalk","fs","promisify","symlink","mkdirp","justMkdirp","moveFile","rimraf","PackageJson","packageContents","checkEngine","checkPlatform","treeCheck","relpath","Diff","retirePath","promiseAllRejectLate","optionalSet","calcDepFlags","saveTypeMap","hasSubKey","_retiredPaths","Symbol","_retiredUnchanged","_sparseTreeDirs","_sparseTreeRoots","_savePrefix","_retireShallowNodes","for","_getBundlesByDepth","_registryResolved","_addNodeToTrashList","_workspaces","_trashList","_handleOptionalFailure","_loadTrees","_diffTrees","_createSparseTree","_loadShrinkwrapsAndUpdateTrees","_shrinkwrapInflated","_bundleUnpacked","_reifyNode","_extractOrLink","_checkBins","_symlink","_warnDeprecated","_loadBundlesAndUpdateTrees","_submitQuickAudit","_awaitQuickAudit","_unpackNewModules","_moveContents","_moveBackRetiredUnchanged","_build","_removeTrash","_renamePath","_rollbackRetireShallowNodes","_rollbackCreateSparseTree","_rollbackMoveBackRetiredUnchanged","_saveIdealTree","_saveLockFile","_copyIdealToActual","_addOmitsToTrashList","_packageLockOnly","_dryRun","_validatePath","_reifyPackages","_omitDev","_omitOptional","_omitPeer","_global","_pruneBundledMetadeps","_resolvedAdd","_usePackageLock","_formatPackageLock","module","exports","cls","Reifier","constructor","options","savePrefix","packageLockOnly","dryRun","formatPackageLock","diff","Set","reify","er","Error","code","omit","has","addTracker","process","emit","finishTracker","actualTree","path","reifyTerminated","removeHandler","signal","Object","assign","steps","rollback","actions","action","bitOpt","complete","buildIdealTree","then","actualOpt","ignoreMissing","global","filter","node","kid","explicitRequests","size","isProjectRoot","idealTree","edgesOut","hasExplicit","some","edge","name","Promise","all","loadActual","filterNodes","target","ideal","children","get","push","actual","ws","calculate","shrinkwrapInflated","removed","inDepBundle","retire","paths","binPaths","moves","log","silly","retired","add","movePromises","entries","map","from","to","didMkdirp","catch","top","peer","dev","optional","devOptional","inventory","dirs","leaves","isLink","d","made","forEach","dir","roots","failures","targets","keys","unlinks","length","warn","seen","shrinkwraps","hasShrinkwrap","Arborist","nodes","loadVirtual","root","timer","location","npmVersion","nodeVersion","p","package","res","resolved","packageName","version","warning","verbose","parent","fsParent","extract","integrity","realpath","rel","_id","deprecated","set","replace","registry","bundlesByDepth","maxBundleDepth","transplantFilter","Map","tree","visit","bundleDependencies","Math","max","getChildren","bundleShadowed","bundles","values","Array","isArray","shadow","extraneous","changed","delete","edgesIn","shadDep","audit","auditReport","filterSet","workspaceDependencySet","load","unpacks","bd","sw","doUnpack","isRoot","realFolder","retireFolder","unchanged","fromPath","packageJsonCache","realFolders","k","v","promises","leave","fsTop","rebuild","handleOptionalFailure","rm","save","updatedTrees","addTree","pkg","req","spec","rawSpec","subSpec","child","newSpec","prefixRange","isRange","type","range","loose","pname","alias","hosted","h","opt","noCommittish","https","auth","shortcut","fetchSpec","saveSpec","saveType","depType","optionalDependencies","dependencies","devDependencies","peerDependencies","indent","format","undefined","saveOpt","updatePackageJson","pkgJson","update","meta","loc","reroot","linksIn","link","tops","filename","hiddenLockfile"],"mappings":"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","sourcesContent":["// mixin implementing the reify method\n\nconst onExit = require('../signal-handling.js')\nconst pacote = require('pacote')\nconst AuditReport = require('../audit-report.js')\nconst {subset, intersects} = require('semver')\nconst npa = require('npm-package-arg')\n\nconst {dirname, resolve, relative} = require('path')\nconst {depth: dfwalk} = require('treeverse')\nconst fs = require('fs')\nconst {promisify} = require('util')\nconst symlink = promisify(fs.symlink)\nconst mkdirp = require('mkdirp-infer-owner')\nconst justMkdirp = require('mkdirp')\nconst moveFile = require('@npmcli/move-file')\nconst rimraf = promisify(require('rimraf'))\nconst PackageJson = require('@npmcli/package-json')\nconst packageContents = require('@npmcli/installed-package-contents')\nconst { checkEngine, checkPlatform } = require('npm-install-checks')\n\nconst treeCheck = require('../tree-check.js')\nconst relpath = require('../relpath.js')\nconst Diff = require('../diff.js')\nconst retirePath = require('../retire-path.js')\nconst promiseAllRejectLate = require('promise-all-reject-late')\nconst optionalSet = require('../optional-set.js')\nconst calcDepFlags = require('../calc-dep-flags.js')\nconst { saveTypeMap, hasSubKey } = require('../add-rm-pkg-deps.js')\n\nconst _retiredPaths = Symbol('retiredPaths')\nconst _retiredUnchanged = Symbol('retiredUnchanged')\nconst _sparseTreeDirs = Symbol('sparseTreeDirs')\nconst _sparseTreeRoots = Symbol('sparseTreeRoots')\nconst _savePrefix = Symbol('savePrefix')\nconst _retireShallowNodes = Symbol.for('retireShallowNodes')\nconst _getBundlesByDepth = Symbol('getBundlesByDepth')\nconst _registryResolved = Symbol('registryResolved')\nconst _addNodeToTrashList = Symbol('addNodeToTrashList')\nconst _workspaces = Symbol.for('workspaces')\n\n// shared by rebuild mixin\nconst _trashList = Symbol.for('trashList')\nconst _handleOptionalFailure = Symbol.for('handleOptionalFailure')\nconst _loadTrees = Symbol.for('loadTrees')\n\n// shared symbols for swapping out when testing\nconst _diffTrees = Symbol.for('diffTrees')\nconst _createSparseTree = Symbol.for('createSparseTree')\nconst _loadShrinkwrapsAndUpdateTrees = Symbol.for('loadShrinkwrapsAndUpdateTrees')\nconst _shrinkwrapInflated = Symbol('shrinkwrapInflated')\nconst _bundleUnpacked = Symbol('bundleUnpacked')\nconst _reifyNode = Symbol.for('reifyNode')\nconst _extractOrLink = Symbol('extractOrLink')\n// defined by rebuild mixin\nconst _checkBins = Symbol.for('checkBins')\nconst _symlink = Symbol('symlink')\nconst _warnDeprecated = Symbol('warnDeprecated')\nconst _loadBundlesAndUpdateTrees = Symbol.for('loadBundlesAndUpdateTrees')\nconst _submitQuickAudit = Symbol('submitQuickAudit')\nconst _awaitQuickAudit = Symbol('awaitQuickAudit')\nconst _unpackNewModules = Symbol.for('unpackNewModules')\nconst _moveContents = Symbol.for('moveContents')\nconst _moveBackRetiredUnchanged = Symbol.for('moveBackRetiredUnchanged')\nconst _build = Symbol.for('build')\nconst _removeTrash = Symbol.for('removeTrash')\nconst _renamePath = Symbol.for('renamePath')\nconst _rollbackRetireShallowNodes = Symbol.for('rollbackRetireShallowNodes')\nconst _rollbackCreateSparseTree = Symbol.for('rollbackCreateSparseTree')\nconst _rollbackMoveBackRetiredUnchanged = Symbol.for('rollbackMoveBackRetiredUnchanged')\nconst _saveIdealTree = Symbol.for('saveIdealTree')\nconst _saveLockFile = Symbol('saveLockFile')\nconst _copyIdealToActual = Symbol('copyIdealToActual')\nconst _addOmitsToTrashList = Symbol('addOmitsToTrashList')\nconst _packageLockOnly = Symbol('packageLockOnly')\nconst _dryRun = Symbol('dryRun')\nconst _validatePath = Symbol('validatePath')\nconst _reifyPackages = Symbol('reifyPackages')\n\nconst _omitDev = Symbol('omitDev')\nconst _omitOptional = Symbol('omitOptional')\nconst _omitPeer = Symbol('omitPeer')\n\nconst _global = Symbol.for('global')\n\n// defined by Ideal mixin\nconst _pruneBundledMetadeps = Symbol.for('pruneBundledMetadeps')\nconst _resolvedAdd = Symbol.for('resolvedAdd')\nconst _usePackageLock = Symbol.for('usePackageLock')\nconst _formatPackageLock = Symbol.for('formatPackageLock')\n\nmodule.exports = cls => class Reifier extends cls {\n  constructor (options) {\n    super(options)\n\n    const {\n      savePrefix = '^',\n      packageLockOnly = false,\n      dryRun = false,\n      formatPackageLock = true,\n    } = options\n\n    this[_dryRun] = !!dryRun\n    this[_packageLockOnly] = !!packageLockOnly\n    this[_savePrefix] = savePrefix\n    this[_formatPackageLock] = !!formatPackageLock\n\n    this.diff = null\n    this[_retiredPaths] = {}\n    this[_shrinkwrapInflated] = new Set()\n    this[_retiredUnchanged] = {}\n    this[_sparseTreeDirs] = new Set()\n    this[_sparseTreeRoots] = new Set()\n    this[_trashList] = new Set()\n  }\n\n  // public method\n  async reify (options = {}) {\n    if (this[_packageLockOnly] && this[_global]) {\n      const er = new Error('cannot generate lockfile for global packages')\n      er.code = 'ESHRINKWRAPGLOBAL'\n      throw er\n    }\n\n    const omit = new Set(options.omit || [])\n    this[_omitDev] = omit.has('dev')\n    this[_omitOptional] = omit.has('optional')\n    this[_omitPeer] = omit.has('peer')\n\n    // start tracker block\n    this.addTracker('reify')\n    process.emit('time', 'reify')\n    await this[_validatePath]()\n    await this[_loadTrees](options)\n    await this[_diffTrees]()\n    await this[_reifyPackages]()\n    await this[_saveIdealTree](options)\n    await this[_copyIdealToActual]()\n    await this[_awaitQuickAudit]()\n\n    this.finishTracker('reify')\n    process.emit('timeEnd', 'reify')\n    return treeCheck(this.actualTree)\n  }\n\n  async [_validatePath] () {\n    // don't create missing dirs on dry runs\n    if (this[_packageLockOnly] || this[_dryRun])\n      return\n\n    // we do NOT want to set ownership on this folder, especially\n    // recursively, because it can have other side effects to do that\n    // in a project directory.  We just want to make it if it's missing.\n    await justMkdirp(resolve(this.path))\n  }\n\n  async [_reifyPackages] () {\n    // we don't submit the audit report or write to disk on dry runs\n    if (this[_dryRun])\n      return\n\n    if (this[_packageLockOnly]) {\n      // we already have the complete tree, so just audit it now,\n      // and that's all we have to do here.\n      return this[_submitQuickAudit]()\n    }\n\n    // ok, we're about to start touching the fs.  need to roll back\n    // if we get an early termination.\n    let reifyTerminated = null\n    const removeHandler = onExit(({signal}) => {\n      // only call once.  if signal hits twice, we just terminate\n      removeHandler()\n      reifyTerminated = Object.assign(new Error('process terminated'), {\n        signal,\n      })\n      return false\n    })\n\n    // [rollbackfn, [...actions]]\n    // after each step, if the process was terminated, execute the rollback\n    // note that each rollback *also* calls the previous one when it's\n    // finished, and then the first one throws the error, so we only need\n    // a new rollback step when we have a new thing that must be done to\n    // revert the install.\n    const steps = [\n      [_rollbackRetireShallowNodes, [\n        _retireShallowNodes,\n      ]],\n      [_rollbackCreateSparseTree, [\n        _createSparseTree,\n        _addOmitsToTrashList,\n        _loadShrinkwrapsAndUpdateTrees,\n        _loadBundlesAndUpdateTrees,\n        _submitQuickAudit,\n        _unpackNewModules,\n      ]],\n      [_rollbackMoveBackRetiredUnchanged, [\n        _moveBackRetiredUnchanged,\n        _build,\n      ]],\n    ]\n    for (const [rollback, actions] of steps) {\n      for (const action of actions) {\n        try {\n          await this[action]()\n          if (reifyTerminated)\n            throw reifyTerminated\n        } catch (er) {\n          await this[rollback](er)\n          /* istanbul ignore next - rollback throws, should never hit this */\n          throw er\n        }\n      }\n    }\n\n    // no rollback for this one, just exit with the error, since the\n    // install completed and can't be safely recovered at this point.\n    await this[_removeTrash]()\n    if (reifyTerminated)\n      throw reifyTerminated\n\n    // done modifying the file system, no need to keep listening for sigs\n    removeHandler()\n  }\n\n  // when doing a local install, we load everything and figure it all out.\n  // when doing a global install, we *only* care about the explicit requests.\n  [_loadTrees] (options) {\n    process.emit('time', 'reify:loadTrees')\n    const bitOpt = {\n      ...options,\n      complete: this[_packageLockOnly] || this[_dryRun],\n    }\n\n    // if we're only writing a package lock, then it doesn't matter what's here\n    if (this[_packageLockOnly]) {\n      return this.buildIdealTree(bitOpt)\n        .then(() => process.emit('timeEnd', 'reify:loadTrees'))\n    }\n\n    const actualOpt = this[_global] ? {\n      ignoreMissing: true,\n      global: true,\n      filter: (node, kid) => {\n        // if it's not the project root, and we have no explicit requests,\n        // then we're already into a nested dep, so we keep it\n        if (this.explicitRequests.size === 0 || !node.isProjectRoot)\n          return true\n\n        // if we added it as an edgeOut, then we want it\n        if (this.idealTree.edgesOut.has(kid))\n          return true\n\n        // if it's an explicit request, then we want it\n        const hasExplicit = [...this.explicitRequests]\n          .some(edge => edge.name === kid)\n        if (hasExplicit)\n          return true\n\n        // ignore the rest of the global install folder\n        return false\n      },\n    } : { ignoreMissing: true }\n\n    if (!this[_global]) {\n      return Promise.all([this.loadActual(actualOpt), this.buildIdealTree(bitOpt)])\n        .then(() => process.emit('timeEnd', 'reify:loadTrees'))\n    }\n\n    // the global install space tends to have a lot of stuff in it.  don't\n    // load all of it, just what we care about.  we won't be saving a\n    // hidden lockfile in there anyway.  Note that we have to load ideal\n    // BEFORE loading actual, so that the actualOpt can use the\n    // explicitRequests which is set during buildIdealTree\n    return this.buildIdealTree(bitOpt)\n      .then(() => this.loadActual(actualOpt))\n      .then(() => process.emit('timeEnd', 'reify:loadTrees'))\n  }\n\n  [_diffTrees] () {\n    if (this[_packageLockOnly])\n      return\n\n    process.emit('time', 'reify:diffTrees')\n    // XXX if we have an existing diff already, there should be a way\n    // to just invalidate the parts that changed, but avoid walking the\n    // whole tree again.\n\n    const filterNodes = []\n    if (this[_global] && this.explicitRequests.size) {\n      const idealTree = this.idealTree.target\n      const actualTree = this.actualTree.target\n      // we ONLY are allowed to make changes in the global top-level\n      // children where there's an explicit request.\n      for (const { name } of this.explicitRequests) {\n        const ideal = idealTree.children.get(name)\n        if (ideal)\n          filterNodes.push(ideal)\n        const actual = actualTree.children.get(name)\n        if (actual)\n          filterNodes.push(actual)\n      }\n    } else {\n      for (const ws of this[_workspaces]) {\n        const ideal = this.idealTree.children.get(ws)\n        if (ideal)\n          filterNodes.push(ideal)\n        const actual = this.actualTree.children.get(ws)\n        if (actual)\n          filterNodes.push(actual)\n      }\n    }\n\n    // find all the nodes that need to change between the actual\n    // and ideal trees.\n    this.diff = Diff.calculate({\n      shrinkwrapInflated: this[_shrinkwrapInflated],\n      filterNodes,\n      actual: this.actualTree,\n      ideal: this.idealTree,\n    })\n\n    for (const node of this.diff.removed) {\n      // a node in a dep bundle will only be removed if its bundling dep\n      // is removed as well.  in which case, we don't have to delete it!\n      if (!node.inDepBundle)\n        this[_addNodeToTrashList](node)\n    }\n    process.emit('timeEnd', 'reify:diffTrees')\n  }\n\n  // add the node and all its bins to the list of things to be\n  // removed later on in the process.  optionally, also mark them\n  // as a retired paths, so that we move them out of the way and\n  // replace them when rolling back on failure.\n  [_addNodeToTrashList] (node, retire) {\n    const paths = [node.path, ...node.binPaths]\n    const moves = this[_retiredPaths]\n    this.log.silly('reify', 'mark', retire ? 'retired' : 'deleted', paths)\n    for (const path of paths) {\n      if (retire) {\n        const retired = retirePath(path)\n        moves[path] = retired\n        this[_trashList].add(retired)\n      } else\n        this[_trashList].add(path)\n    }\n  }\n\n  // move aside the shallowest nodes in the tree that have to be\n  // changed or removed, so that we can rollback if necessary.\n  [_retireShallowNodes] () {\n    process.emit('time', 'reify:retireShallow')\n    const moves = this[_retiredPaths] = {}\n    for (const diff of this.diff.children) {\n      if (diff.action === 'CHANGE' || diff.action === 'REMOVE') {\n        // we'll have to clean these up at the end, so add them to the list\n        this[_addNodeToTrashList](diff.actual, true)\n      }\n    }\n    this.log.silly('reify', 'moves', moves)\n    const movePromises = Object.entries(moves)\n      .map(([from, to]) => this[_renamePath](from, to))\n    return promiseAllRejectLate(movePromises)\n      .then(() => process.emit('timeEnd', 'reify:retireShallow'))\n  }\n\n  [_renamePath] (from, to, didMkdirp = false) {\n    return moveFile(from, to)\n      .catch(er => {\n        // Occasionally an expected bin file might not exist in the package,\n        // or a shim/symlink might have been moved aside.  If we've already\n        // handled the most common cause of ENOENT (dir doesn't exist yet),\n        // then just ignore any ENOENT.\n        if (er.code === 'ENOENT') {\n          return didMkdirp ? null : mkdirp(dirname(to)).then(() =>\n            this[_renamePath](from, to, true))\n        } else if (er.code === 'EEXIST')\n          return rimraf(to).then(() => moveFile(from, to))\n        else\n          throw er\n      })\n  }\n\n  [_rollbackRetireShallowNodes] (er) {\n    process.emit('time', 'reify:rollback:retireShallow')\n    const moves = this[_retiredPaths]\n    const movePromises = Object.entries(moves)\n      .map(([from, to]) => this[_renamePath](to, from))\n    return promiseAllRejectLate(movePromises)\n      // ignore subsequent rollback errors\n      .catch(er => {})\n      .then(() => process.emit('timeEnd', 'reify:rollback:retireShallow'))\n      .then(() => {\n        throw er\n      })\n  }\n\n  // adding to the trash list will skip reifying, and delete them\n  // if they are currently in the tree and otherwise untouched.\n  [_addOmitsToTrashList] () {\n    if (!this[_omitDev] && !this[_omitOptional] && !this[_omitPeer])\n      return\n\n    process.emit('time', 'reify:trashOmits')\n\n    const filter = node =>\n      node.top.isProjectRoot &&\n        (node.peer && this[_omitPeer] ||\n          node.dev && this[_omitDev] ||\n          node.optional && this[_omitOptional] ||\n          node.devOptional && this[_omitOptional] && this[_omitDev])\n\n    for (const node of this.idealTree.inventory.filter(filter))\n      this[_addNodeToTrashList](node)\n\n    process.emit('timeEnd', 'reify:trashOmits')\n  }\n\n  [_createSparseTree] () {\n    process.emit('time', 'reify:createSparse')\n    // if we call this fn again, we look for the previous list\n    // so that we can avoid making the same directory multiple times\n    const dirs = this.diff.leaves\n      .filter(diff => {\n        return (diff.action === 'ADD' || diff.action === 'CHANGE') &&\n          !this[_sparseTreeDirs].has(diff.ideal.path) &&\n          !diff.ideal.isLink\n      })\n      .map(diff => diff.ideal.path)\n\n    return promiseAllRejectLate(dirs.map(d => mkdirp(d)))\n      .then(made => {\n        made.forEach(made => this[_sparseTreeRoots].add(made))\n        dirs.forEach(dir => this[_sparseTreeDirs].add(dir))\n      })\n      .then(() => process.emit('timeEnd', 'reify:createSparse'))\n  }\n\n  [_rollbackCreateSparseTree] (er) {\n    process.emit('time', 'reify:rollback:createSparse')\n    // cut the roots of the sparse tree that were created, not the leaves\n    const roots = this[_sparseTreeRoots]\n    // also delete the moves that we retired, so that we can move them back\n    const failures = []\n    const targets = [...roots, ...Object.keys(this[_retiredPaths])]\n    const unlinks = targets\n      .map(path => rimraf(path).catch(er => failures.push([path, er])))\n    return promiseAllRejectLate(unlinks)\n      .then(() => {\n        if (failures.length)\n          this.log.warn('cleanup', 'Failed to remove some directories', failures)\n      })\n      .then(() => process.emit('timeEnd', 'reify:rollback:createSparse'))\n      .then(() => this[_rollbackRetireShallowNodes](er))\n  }\n\n  // shrinkwrap nodes define their dependency branches with a file, so\n  // we need to unpack them, read that shrinkwrap file, and then update\n  // the tree by calling loadVirtual with the node as the root.\n  [_loadShrinkwrapsAndUpdateTrees] () {\n    const seen = this[_shrinkwrapInflated]\n    const shrinkwraps = this.diff.leaves\n      .filter(d => (d.action === 'CHANGE' || d.action === 'ADD' || !d.action) &&\n        d.ideal.hasShrinkwrap && !seen.has(d.ideal) &&\n        !this[_trashList].has(d.ideal.path))\n\n    if (!shrinkwraps.length)\n      return\n\n    process.emit('time', 'reify:loadShrinkwraps')\n\n    const Arborist = this.constructor\n    return promiseAllRejectLate(shrinkwraps.map(diff => {\n      const node = diff.ideal\n      seen.add(node)\n      return diff.action ? this[_reifyNode](node) : node\n    }))\n      .then(nodes => promiseAllRejectLate(nodes.map(node => new Arborist({\n        ...this.options,\n        path: node.path,\n      }).loadVirtual({ root: node }))))\n      // reload the diff and sparse tree because the ideal tree changed\n      .then(() => this[_diffTrees]())\n      .then(() => this[_createSparseTree]())\n      .then(() => this[_addOmitsToTrashList]())\n      .then(() => this[_loadShrinkwrapsAndUpdateTrees]())\n      .then(() => process.emit('timeEnd', 'reify:loadShrinkwraps'))\n  }\n\n  // create a symlink for Links, extract for Nodes\n  // return the node object, since we usually want that\n  // handle optional dep failures here\n  // If node is in trash list, skip it\n  // If reifying fails, and the node is optional, add it and its optionalSet\n  // to the trash list\n  // Always return the node.\n  [_reifyNode] (node) {\n    if (this[_trashList].has(node.path))\n      return node\n\n    const timer = `reifyNode:${node.location}`\n    process.emit('time', timer)\n    this.addTracker('reify', node.name, node.location)\n\n    const { npmVersion, nodeVersion } = this.options\n    const p = Promise.resolve()\n      .then(async () => {\n        // when we reify an optional node, check the engine and platform\n        // first. be sure to ignore the --force and --engine-strict flags,\n        // since we always want to skip any optional packages we can't install.\n        // these checks throwing will result in a rollback and removal\n        // of the mismatches\n        if (node.optional) {\n          checkEngine(node.package, npmVersion, nodeVersion, false)\n          checkPlatform(node.package, false)\n        }\n        await this[_checkBins](node)\n        await this[_extractOrLink](node)\n        await this[_warnDeprecated](node)\n      })\n\n    return this[_handleOptionalFailure](node, p)\n      .then(() => {\n        this.finishTracker('reify', node.name, node.location)\n        process.emit('timeEnd', timer)\n        return node\n      })\n  }\n\n  [_extractOrLink] (node) {\n    // in normal cases, node.resolved should *always* be set by now.\n    // however, it is possible when a lockfile is damaged, or very old,\n    // or in some other race condition bugs in npm v6, that a previously\n    // bundled dependency will have just a version, but no resolved value,\n    // and no 'bundled: true' setting.\n    // Do the best with what we have, or else remove it from the tree\n    // entirely, since we can't possibly reify it.\n    const res = node.resolved ? `${node.name}@${this[_registryResolved](node.resolved)}`\n      : node.packageName && node.version\n        ? `${node.packageName}@${node.version}`\n        : null\n\n    // no idea what this thing is.  remove it from the tree.\n    if (!res) {\n      const warning = 'invalid or damaged lockfile detected\\n' +\n        'please re-try this operation once it completes\\n' +\n        'so that the damage can be corrected, or perform\\n' +\n        'a fresh install with no lockfile if the problem persists.'\n      this.log.warn('reify', warning)\n      this.log.verbose('reify', 'unrecognized node in tree', node.path)\n      node.parent = null\n      node.fsParent = null\n      this[_addNodeToTrashList](node)\n      return\n    }\n\n    return node.isLink\n      ? rimraf(node.path).then(() => this[_symlink](node))\n      : pacote.extract(res, node.path, {\n        ...this.options,\n        resolved: node.resolved,\n        integrity: node.integrity,\n      })\n  }\n\n  async [_symlink] (node) {\n    const dir = dirname(node.path)\n    const target = node.realpath\n    const rel = relative(dir, target)\n    await mkdirp(dir)\n    return symlink(rel, node.path, 'junction')\n  }\n\n  [_warnDeprecated] (node) {\n    const {_id, deprecated} = node.package\n    if (deprecated)\n      this.log.warn('deprecated', `${_id}: ${deprecated}`)\n  }\n\n  // if the node is optional, then the failure of the promise is nonfatal\n  // just add it and its optional set to the trash list.\n  [_handleOptionalFailure] (node, p) {\n    return (node.optional ? p.catch(er => {\n      const set = optionalSet(node)\n      for (node of set) {\n        this.log.verbose('reify', 'failed optional dependency', node.path)\n        this[_addNodeToTrashList](node)\n      }\n    }) : p).then(() => node)\n  }\n\n  [_registryResolved] (resolved) {\n    // the default registry url is a magic value meaning \"the currently\n    // configured registry\".\n    //\n    // XXX: use a magic string that isn't also a valid value, like\n    // ${REGISTRY} or something.  This has to be threaded through the\n    // Shrinkwrap and Node classes carefully, so for now, just treat\n    // the default reg as the magical animal that it has been.\n    return resolved && resolved\n      .replace(/^https?:\\/\\/registry.npmjs.org\\//, this.registry)\n  }\n\n  // bundles are *sort of* like shrinkwraps, in that the branch is defined\n  // by the contents of the package.  however, in their case, rather than\n  // shipping a virtual tree that must be reified, they ship an entire\n  // reified actual tree that must be unpacked and not modified.\n  [_loadBundlesAndUpdateTrees] (\n    depth = 0, bundlesByDepth = this[_getBundlesByDepth]()\n  ) {\n    if (depth === 0) {\n      this[_bundleUnpacked] = new Set()\n      process.emit('time', 'reify:loadBundles')\n    }\n    const maxBundleDepth = bundlesByDepth.get('maxBundleDepth')\n    if (depth > maxBundleDepth) {\n      // if we did something, then prune the tree and update the diffs\n      if (maxBundleDepth !== -1) {\n        this[_pruneBundledMetadeps](bundlesByDepth)\n        this[_diffTrees]()\n      }\n      process.emit('timeEnd', 'reify:loadBundles')\n      return\n    }\n\n    // skip any that have since been removed from the tree, eg by a\n    // shallower bundle overwriting them with a bundled meta-dep.\n    const set = (bundlesByDepth.get(depth) || [])\n      .filter(node => node.root === this.idealTree &&\n        node.target !== node.root &&\n        !this[_trashList].has(node.path))\n\n    if (!set.length)\n      return this[_loadBundlesAndUpdateTrees](depth + 1, bundlesByDepth)\n\n    // extract all the nodes with bundles\n    return promiseAllRejectLate(set.map(node => {\n      this[_bundleUnpacked].add(node)\n      return this[_reifyNode](node)\n    }))\n    // then load their unpacked children and move into the ideal tree\n      .then(nodes =>\n        promiseAllRejectLate(nodes.map(node => new this.constructor({\n          ...this.options,\n          path: node.path,\n        }).loadActual({\n          root: node,\n          // don't transplant any sparse folders we created\n          transplantFilter: node => node.package._id,\n        }))))\n    // move onto the next level of bundled items\n      .then(() => this[_loadBundlesAndUpdateTrees](depth + 1, bundlesByDepth))\n  }\n\n  [_getBundlesByDepth] () {\n    const bundlesByDepth = new Map()\n    let maxBundleDepth = -1\n    dfwalk({\n      tree: this.diff,\n      visit: diff => {\n        const node = diff.ideal\n        if (!node)\n          return\n        if (node.isProjectRoot)\n          return\n\n        const { bundleDependencies } = node.package\n        if (bundleDependencies && bundleDependencies.length) {\n          maxBundleDepth = Math.max(maxBundleDepth, node.depth)\n          if (!bundlesByDepth.has(node.depth))\n            bundlesByDepth.set(node.depth, [node])\n          else\n            bundlesByDepth.get(node.depth).push(node)\n        }\n      },\n      getChildren: diff => diff.children,\n    })\n\n    bundlesByDepth.set('maxBundleDepth', maxBundleDepth)\n    return bundlesByDepth\n  }\n\n  // https://github.com/npm/cli/issues/1597#issuecomment-667639545\n  [_pruneBundledMetadeps] (bundlesByDepth) {\n    const bundleShadowed = new Set()\n    // create the list of nodes shadowed by children of bundlers\n    for (const bundles of bundlesByDepth.values()) {\n      // skip the 'maxBundleDepth' item\n      if (!Array.isArray(bundles))\n        continue\n      for (const node of bundles) {\n        for (const name of node.children.keys()) {\n          const shadow = node.parent.resolve(name)\n          if (!shadow)\n            continue\n          bundleShadowed.add(shadow)\n          shadow.extraneous = true\n        }\n      }\n    }\n    let changed = true\n    while (changed) {\n      changed = false\n      for (const shadow of bundleShadowed) {\n        if (!shadow.extraneous) {\n          bundleShadowed.delete(shadow)\n          continue\n        }\n\n        for (const edge of shadow.edgesIn) {\n          if (!edge.from.extraneous) {\n            shadow.extraneous = false\n            bundleShadowed.delete(shadow)\n            changed = true\n          } else {\n            for (const shadDep of shadow.edgesOut.values()) {\n              /* istanbul ignore else - pretty unusual situation, just being\n               * defensive here. Would mean that a bundled dep has a dependency\n               * that is unmet. which, weird, but if you bundle it, we take\n               * whatever you put there and assume the publisher knows best. */\n              if (shadDep.to)\n                bundleShadowed.add(shadDep.to)\n            }\n          }\n        }\n      }\n    }\n    for (const shadow of bundleShadowed) {\n      shadow.parent = null\n      this[_addNodeToTrashList](shadow)\n    }\n  }\n\n  [_submitQuickAudit] () {\n    if (this.options.audit === false)\n      return this.auditReport = null\n\n    // we submit the quick audit at this point in the process, as soon as\n    // we have all the deps resolved, so that it can overlap with the other\n    // actions as much as possible.  Stash the promise, which we resolve\n    // before finishing the reify() and returning the tree.  Thus, we do\n    // NOT return the promise, as the intent is for this to run in parallel\n    // with the reification, and be resolved at a later time.\n    process.emit('time', 'reify:audit')\n    const options = { ...this.options }\n    const tree = this.idealTree\n\n    // if we're operating on a workspace, only audit the workspace deps\n    if (this[_workspaces] && this[_workspaces].length)\n      options.filterSet = this.workspaceDependencySet(tree, this[_workspaces])\n\n    this.auditReport = AuditReport.load(tree, options)\n      .then(res => {\n        process.emit('timeEnd', 'reify:audit')\n        this.auditReport = res\n      })\n  }\n\n  // return the promise if we're waiting for it, or the replaced result\n  [_awaitQuickAudit] () {\n    return this.auditReport\n  }\n\n  // ok!  actually unpack stuff into their target locations!\n  // The sparse tree has already been created, so we walk the diff\n  // kicking off each unpack job.  If any fail, we rimraf the sparse\n  // tree entirely and try to put everything back where it was.\n  [_unpackNewModules] () {\n    process.emit('time', 'reify:unpack')\n    const unpacks = []\n    dfwalk({\n      tree: this.diff,\n      visit: diff => {\n        // no unpacking if we don't want to change this thing\n        if (diff.action !== 'CHANGE' && diff.action !== 'ADD')\n          return\n\n        const node = diff.ideal\n        const bd = this[_bundleUnpacked].has(node)\n        const sw = this[_shrinkwrapInflated].has(node)\n\n        // check whether we still need to unpack this one.\n        // test the inDepBundle last, since that's potentially a tree walk.\n        const doUnpack = node && // can't unpack if removed!\n          !node.isRoot && // root node already exists\n          !bd && // already unpacked to read bundle\n          !sw && // already unpacked to read sw\n          !node.inDepBundle // already unpacked by another dep's bundle\n\n        if (doUnpack)\n          unpacks.push(this[_reifyNode](node))\n      },\n      getChildren: diff => diff.children,\n    })\n    return promiseAllRejectLate(unpacks)\n      .then(() => process.emit('timeEnd', 'reify:unpack'))\n  }\n\n  // This is the part where we move back the unchanging nodes that were\n  // the children of a node that did change.  If this fails, the rollback\n  // is a three-step process.  First, we try to move the retired unchanged\n  // nodes BACK to their retirement folders, then delete the sparse tree,\n  // then move everything out of retirement.\n  [_moveBackRetiredUnchanged] () {\n    // get a list of all unchanging children of any shallow retired nodes\n    // if they are not the ancestor of any node in the diff set, then the\n    // directory won't already exist, so just rename it over.\n    // This is sort of an inverse diff tree, of all the nodes where\n    // the actualTree and idealTree _don't_ differ, starting from the\n    // shallowest nodes that we moved aside in the first place.\n    process.emit('time', 'reify:unretire')\n    const moves = this[_retiredPaths]\n    this[_retiredUnchanged] = {}\n    return promiseAllRejectLate(this.diff.children.map(diff => {\n      const realFolder = (diff.actual || diff.ideal).path\n      const retireFolder = moves[realFolder]\n      this[_retiredUnchanged][retireFolder] = []\n      return promiseAllRejectLate(diff.unchanged.map(node => {\n        // no need to roll back links, since we'll just delete them anyway\n        if (node.isLink)\n          return mkdirp(dirname(node.path)).then(() => this[_reifyNode](node))\n\n        // will have been moved/unpacked along with bundler\n        if (node.inDepBundle)\n          return\n\n        this[_retiredUnchanged][retireFolder].push(node)\n\n        const rel = relative(realFolder, node.path)\n        const fromPath = resolve(retireFolder, rel)\n        // if it has bundleDependencies, then make node_modules.  otherwise\n        // skip it.\n        const bd = node.package.bundleDependencies\n        const dir = bd && bd.length ? node.path + '/node_modules' : node.path\n        return mkdirp(dir).then(() => this[_moveContents](node, fromPath))\n      }))\n    }))\n      .then(() => process.emit('timeEnd', 'reify:unretire'))\n  }\n\n  // move the contents from the fromPath to the node.path\n  [_moveContents] (node, fromPath) {\n    return packageContents({\n      path: fromPath,\n      depth: 1,\n      packageJsonCache: new Map([[fromPath + '/package.json', node.package]]),\n    }).then(res => promiseAllRejectLate(res.map(path => {\n      const rel = relative(fromPath, path)\n      const to = resolve(node.path, rel)\n      return this[_renamePath](path, to)\n    })))\n  }\n\n  [_rollbackMoveBackRetiredUnchanged] (er) {\n    const moves = this[_retiredPaths]\n    // flip the mapping around to go back\n    const realFolders = new Map(Object.entries(moves).map(([k, v]) => [v, k]))\n    const promises = Object.entries(this[_retiredUnchanged])\n      .map(([retireFolder, nodes]) => promiseAllRejectLate(nodes.map(node => {\n        const realFolder = realFolders.get(retireFolder)\n        const rel = relative(realFolder, node.path)\n        const fromPath = resolve(retireFolder, rel)\n        return this[_moveContents]({ ...node, path: fromPath }, node.path)\n      })))\n    return promiseAllRejectLate(promises)\n      .then(() => this[_rollbackCreateSparseTree](er))\n  }\n\n  [_build] () {\n    process.emit('time', 'reify:build')\n\n    // for all the things being installed, run their appropriate scripts\n    // run in tip->root order, so as to be more likely to build a node's\n    // deps before attempting to build it itself\n    const nodes = []\n    dfwalk({\n      tree: this.diff,\n      leave: diff => {\n        if (!diff.ideal.isProjectRoot)\n          nodes.push(diff.ideal)\n      },\n      // process adds before changes, ignore removals\n      getChildren: diff => diff && diff.children,\n      filter: diff => diff.action === 'ADD' || diff.action === 'CHANGE',\n    })\n\n    // pick up link nodes from the unchanged list as we want to run their\n    // scripts in every install despite of having a diff status change\n    for (const node of this.diff.unchanged) {\n      const tree = node.root.target\n\n      // skip links that only live within node_modules as they are most\n      // likely managed by packages we installed, we only want to rebuild\n      // unchanged links we directly manage\n      if (node.isLink && node.target.fsTop === tree)\n        nodes.push(node)\n    }\n\n    return this.rebuild({ nodes, handleOptionalFailure: true })\n      .then(() => process.emit('timeEnd', 'reify:build'))\n  }\n\n  // the tree is pretty much built now, so it's cleanup time.\n  // remove the retired folders, and any deleted nodes\n  // If this fails, there isn't much we can do but tell the user about it.\n  // Thankfully, it's pretty unlikely that it'll fail, since rimraf is a tank.\n  [_removeTrash] () {\n    process.emit('time', 'reify:trash')\n    const promises = []\n    const failures = []\n    const rm = path => rimraf(path).catch(er => failures.push([path, er]))\n\n    for (const path of this[_trashList])\n      promises.push(rm(path))\n\n    return promiseAllRejectLate(promises).then(() => {\n      if (failures.length)\n        this.log.warn('cleanup', 'Failed to remove some directories', failures)\n    })\n      .then(() => process.emit('timeEnd', 'reify:trash'))\n  }\n\n  // last but not least, we save the ideal tree metadata to the package-lock\n  // or shrinkwrap file, and any additions or removals to package.json\n  async [_saveIdealTree] (options) {\n    // the ideal tree is actualized now, hooray!\n    // it still contains all the references to optional nodes that were removed\n    // for install failures.  Those still end up in the shrinkwrap, so we\n    // save it first, then prune out the optional trash, and then return it.\n\n    // support save=false option\n    if (options.save === false || this[_global] || this[_dryRun])\n      return false\n\n    process.emit('time', 'reify:save')\n\n    const updatedTrees = new Set()\n\n    // resolvedAdd is the list of user add requests, but with names added\n    // to things like git repos and tarball file/urls.  However, if the\n    // user requested 'foo@', and we have a foo@file:../foo, then we should\n    // end up saving the spec we actually used, not whatever they gave us.\n    if (this[_resolvedAdd].length) {\n      for (const { name, tree: addTree } of this[_resolvedAdd]) {\n        // addTree either the root, or a workspace\n        const edge = addTree.edgesOut.get(name)\n        const pkg = addTree.package\n        const req = npa.resolve(name, edge.spec, addTree.realpath)\n        const {rawSpec, subSpec} = req\n\n        const spec = subSpec ? subSpec.rawSpec : rawSpec\n        const child = edge.to\n\n        let newSpec\n        if (req.registry) {\n          const version = child.version\n          const prefixRange = version ? this[_savePrefix] + version : '*'\n          // if we installed a range, then we save the range specified\n          // if it is not a subset of the ^x.y.z.  eg, installing a range\n          // of `1.x <1.2.3` will not be saved as `^1.2.0`, because that\n          // would allow versions outside the requested range.  Tags and\n          // specific versions save with the save-prefix.\n          const isRange = (subSpec || req).type === 'range'\n\n          let range = spec\n          if (\n            !isRange ||\n            spec === '*' ||\n            subset(prefixRange, spec, { loose: true })\n          )\n            range = prefixRange\n\n          const pname = child.packageName\n          const alias = name !== pname\n          newSpec = alias ? `npm:${pname}@${range}` : range\n        } else if (req.hosted) {\n          // save the git+https url if it has auth, otherwise shortcut\n          const h = req.hosted\n          const opt = { noCommittish: false }\n          if (h.https && h.auth)\n            newSpec = `git+${h.https(opt)}`\n          else\n            newSpec = h.shortcut(opt)\n        } else if (req.type === 'directory' || req.type === 'file') {\n          // save the relative path in package.json\n          // Normally saveSpec is updated with the proper relative\n          // path already, but it's possible to specify a full absolute\n          // path initially, in which case we can end up with the wrong\n          // thing, so just get the ultimate fetchSpec and relativize it.\n          const p = req.fetchSpec.replace(/^file:/, '')\n          const rel = relpath(addTree.realpath, p)\n          newSpec = `file:${rel}`\n        } else\n          newSpec = req.saveSpec\n\n        if (options.saveType) {\n          const depType = saveTypeMap.get(options.saveType)\n          pkg[depType][name] = newSpec\n          // rpj will have moved it here if it was in both\n          // if it is empty it will be deleted later\n          if (options.saveType === 'prod' && pkg.optionalDependencies)\n            delete pkg.optionalDependencies[name]\n        } else {\n          if (hasSubKey(pkg, 'dependencies', name))\n            pkg.dependencies[name] = newSpec\n\n          if (hasSubKey(pkg, 'devDependencies', name)) {\n            pkg.devDependencies[name] = newSpec\n            // don't update peer or optional if we don't have to\n            if (hasSubKey(pkg, 'peerDependencies', name) && !intersects(newSpec, pkg.peerDependencies[name]))\n              pkg.peerDependencies[name] = newSpec\n\n            if (hasSubKey(pkg, 'optionalDependencies', name) && !intersects(newSpec, pkg.optionalDependencies[name]))\n              pkg.optionalDependencies[name] = newSpec\n          } else {\n            if (hasSubKey(pkg, 'peerDependencies', name))\n              pkg.peerDependencies[name] = newSpec\n\n            if (hasSubKey(pkg, 'optionalDependencies', name))\n              pkg.optionalDependencies[name] = newSpec\n          }\n        }\n\n        updatedTrees.add(addTree)\n      }\n    }\n\n    // preserve indentation, if possible\n    const {\n      [Symbol.for('indent')]: indent,\n    } = this.idealTree.package\n    const format = indent === undefined ? '  ' : indent\n\n    const saveOpt = {\n      format: (this[_formatPackageLock] && format) ? format\n      : this[_formatPackageLock],\n    }\n\n    const promises = [this[_saveLockFile](saveOpt)]\n\n    const updatePackageJson = async (tree) => {\n      const pkgJson = await PackageJson.load(tree.path)\n        .catch(() => new PackageJson(tree.path))\n      const {\n        dependencies = {},\n        devDependencies = {},\n        optionalDependencies = {},\n        peerDependencies = {},\n      } = tree.package\n\n      pkgJson.update({\n        dependencies,\n        devDependencies,\n        optionalDependencies,\n        peerDependencies,\n      })\n      await pkgJson.save()\n    }\n\n    // grab any from explicitRequests that had deps removed\n    for (const { from: tree } of this.explicitRequests)\n      updatedTrees.add(tree)\n\n    for (const tree of updatedTrees) {\n      // refresh the edges so they have the correct specs\n      tree.package = tree.package\n      promises.push(updatePackageJson(tree))\n    }\n\n    await Promise.all(promises)\n    process.emit('timeEnd', 'reify:save')\n    return true\n  }\n\n  async [_saveLockFile] (saveOpt) {\n    if (!this[_usePackageLock])\n      return\n\n    const { meta } = this.idealTree\n\n    return meta.save(saveOpt)\n  }\n\n  async [_copyIdealToActual] () {\n    // clean up any trash that is still in the tree\n    for (const path of this[_trashList]) {\n      const loc = relpath(this.idealTree.realpath, path)\n      const node = this.idealTree.inventory.get(loc)\n      if (node && node.root === this.idealTree)\n        node.parent = null\n    }\n\n    // if we filtered to only certain nodes, then anything ELSE needs\n    // to be untouched in the resulting actual tree, even if it differs\n    // in the idealTree.  Copy over anything that was in the actual and\n    // was not changed, delete anything in the ideal and not actual.\n    // Then we move the entire idealTree over to this.actualTree, and\n    // save the hidden lockfile.\n    if (this.diff && this.diff.filterSet.size) {\n      const reroot = new Set()\n\n      const { filterSet } = this.diff\n      const seen = new Set()\n      for (const [loc, ideal] of this.idealTree.inventory.entries()) {\n        seen.add(loc)\n\n        // if it's an ideal node from the filter set, then skip it\n        // because we already made whatever changes were necessary\n        if (filterSet.has(ideal))\n          continue\n\n        // otherwise, if it's not in the actualTree, then it's not a thing\n        // that we actually added.  And if it IS in the actualTree, then\n        // it's something that we left untouched, so we need to record\n        // that.\n        const actual = this.actualTree.inventory.get(loc)\n        if (!actual)\n          ideal.root = null\n        else {\n          if ([...actual.linksIn].some(link => filterSet.has(link))) {\n            seen.add(actual.location)\n            continue\n          }\n          const { realpath, isLink } = actual\n          if (isLink && ideal.isLink && ideal.realpath === realpath)\n            continue\n          else\n            reroot.add(actual)\n        }\n      }\n\n      // now find any actual nodes that may not be present in the ideal\n      // tree, but were left behind by virtue of not being in the filter\n      for (const [loc, actual] of this.actualTree.inventory.entries()) {\n        if (seen.has(loc))\n          continue\n        seen.add(loc)\n\n        // we know that this is something that ISN'T in the idealTree,\n        // or else we will have addressed it in the previous loop.\n        // If it's in the filterSet, that means we intentionally removed\n        // it, so nothing to do here.\n        if (filterSet.has(actual))\n          continue\n\n        reroot.add(actual)\n      }\n\n      // go through the rerooted actual nodes, and move them over.\n      for (const actual of reroot)\n        actual.root = this.idealTree\n\n      // prune out any tops that lack a linkIn, they are no longer relevant.\n      for (const top of this.idealTree.tops) {\n        if (top.linksIn.size === 0)\n          top.root = null\n      }\n\n      // need to calculate dep flags, since nodes may have been marked\n      // as extraneous or otherwise incorrect during transit.\n      calcDepFlags(this.idealTree)\n    }\n\n    // save the ideal's meta as a hidden lockfile after we actualize it\n    this.idealTree.meta.filename =\n      this.idealTree.realpath + '/node_modules/.package-lock.json'\n    this.idealTree.meta.hiddenLockfile = true\n\n    this.actualTree = this.idealTree\n    this.idealTree = null\n\n    if (!this[_global])\n      await this.actualTree.meta.save()\n  }\n}\n"]},"metadata":{},"sourceType":"script"}