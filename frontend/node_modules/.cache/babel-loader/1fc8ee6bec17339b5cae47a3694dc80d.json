{"ast":null,"code":"// inventory, path, realpath, root, and parent\n//\n// node.root is a reference to the root module in the tree (ie, typically the\n// cwd project folder)\n//\n// node.location is the /-delimited path from the root module to the node.  In\n// the case of link targets that may be outside of the root's package tree,\n// this can include some number of /../ path segments.  The location of the\n// root module is always '.'.  node.location thus never contains drive letters\n// or absolute paths, and is portable within a given project, suitable for\n// inclusion in lockfiles and metadata.\n//\n// node.path is the path to the place where this node lives on disk.  It is\n// system-specific and absolute.\n//\n// node.realpath is the path to where the module actually resides on disk.  In\n// the case of non-link nodes, node.realpath is equivalent to node.path.  In\n// the case of link nodes, it is equivalent to node.target.path.\n//\n// Setting node.parent will set the node's root to the parent's root, as well\n// as updating edgesIn and edgesOut to reload dependency resolutions as needed,\n// and setting node.path to parent.path/node_modules/name.\n//\n// node.inventory is a Map of name to a Set() of all the nodes under a given\n// root by that name.  It's empty for non-root nodes, and changing the root\n// reference will remove it from the old root's inventory and add it to the new\n// one.  This map is useful for cases like `npm update foo` or `npm ls foo`\n// where we need to quickly find all instances of a given package name within a\n// tree.\nconst semver = require('semver');\n\nconst nameFromFolder = require('@npmcli/name-from-folder');\n\nconst Edge = require('./edge.js');\n\nconst Inventory = require('./inventory.js');\n\nconst {\n  normalize\n} = require('read-package-json-fast');\n\nconst {\n  getPaths: getBinPaths\n} = require('bin-links');\n\nconst npa = require('npm-package-arg');\n\nconst debug = require('./debug.js');\n\nconst gatherDepSet = require('./gather-dep-set.js');\n\nconst treeCheck = require('./tree-check.js');\n\nconst walkUp = require('walk-up-path');\n\nconst {\n  resolve,\n  relative,\n  dirname,\n  basename\n} = require('path');\n\nconst util = require('util');\n\nconst _package = Symbol('_package');\n\nconst _parent = Symbol('_parent');\n\nconst _target = Symbol.for('_target');\n\nconst _fsParent = Symbol('_fsParent');\n\nconst _loadDepType = Symbol('_loadDepType');\n\nconst _loadWorkspaces = Symbol('_loadWorkspaces');\n\nconst _reloadNamedEdges = Symbol('_reloadNamedEdges'); // overridden by Link class\n\n\nconst _loadDeps = Symbol.for('Arborist.Node._loadDeps');\n\nconst _root = Symbol('_root');\n\nconst _refreshLocation = Symbol.for('_refreshLocation');\n\nconst _changePath = Symbol.for('_changePath'); // used by Link class as well\n\n\nconst _delistFromMeta = Symbol.for('_delistFromMeta');\n\nconst _global = Symbol.for('global');\n\nconst _workspaces = Symbol('_workspaces');\n\nconst _explain = Symbol('_explain');\n\nconst _explanation = Symbol('_explanation');\n\nconst _meta = Symbol('_meta');\n\nconst relpath = require('./relpath.js');\n\nconst consistentResolve = require('./consistent-resolve.js');\n\nconst printableTree = require('./printable.js');\n\nclass Node {\n  constructor(options) {\n    // NB: path can be null if it's a link target\n    const {\n      root,\n      path,\n      realpath,\n      parent,\n      error,\n      meta,\n      fsParent,\n      resolved,\n      integrity,\n      // allow setting name explicitly when we haven't set a path yet\n      name,\n      children,\n      fsChildren,\n      legacyPeerDeps = false,\n      linksIn,\n      hasShrinkwrap,\n      extraneous = true,\n      dev = true,\n      optional = true,\n      devOptional = true,\n      peer = true,\n      global = false,\n      dummy = false,\n      sourceReference = null\n    } = options; // true if part of a global install\n\n    this[_global] = global;\n    this[_workspaces] = null;\n    this.errors = error ? [error] : []; // this will usually be null, except when modeling a\n    // package's dependencies in a virtual root.\n\n    this.sourceReference = sourceReference;\n    const pkg = sourceReference ? sourceReference.package : normalize(options.pkg || {});\n    this.name = name || nameFromFolder(path || pkg.name || realpath) || pkg.name || null; // should be equal if not a link\n\n    this.path = path ? resolve(path) : null;\n    if (!this.name && (!this.path || this.path !== dirname(this.path))) throw new TypeError('could not detect node name from path or package');\n    this.realpath = !this.isLink ? this.path : resolve(realpath);\n    this.resolved = resolved || null;\n\n    if (!this.resolved) {\n      // note: this *only* works for non-file: deps, so we avoid even\n      // trying here.\n      // file: deps are tracked in package.json will _resolved set to the\n      // full path to the tarball or link target.  However, if the package\n      // is checked into git or moved to another location, that's 100% not\n      // portable at all!  The _where and _location don't provide much help,\n      // since _location is just where the module ended up in the tree,\n      // and _where can be different than the actual root if it's a\n      // meta-dep deeper in the dependency graph.\n      //\n      // If we don't have the other oldest indicators of legacy npm, then it's\n      // probably what we're getting from pacote, which IS trustworthy.\n      //\n      // Otherwise, hopefully a shrinkwrap will help us out.\n      const resolved = consistentResolve(pkg._resolved);\n      if (resolved && !(/^file:/.test(resolved) && pkg._where)) this.resolved = resolved;\n    }\n\n    this.integrity = integrity || pkg._integrity || null;\n    this.hasShrinkwrap = hasShrinkwrap || pkg._hasShrinkwrap || false;\n    this.legacyPeerDeps = legacyPeerDeps;\n    this.children = new Map();\n    this.fsChildren = new Set();\n    this.inventory = new Inventory({});\n    this.tops = new Set();\n    this.linksIn = new Set(linksIn || []); // these three are set by an Arborist taking a catalog\n    // after the tree is built.  We don't get this along the way,\n    // because they have a tendency to change as new children are\n    // added, especially when they're deduped.  Eg, a dev dep may be\n    // a 3-levels-deep dependency of a non-dev dep.  If we calc the\n    // flags along the way, then they'll tend to be invalid  by the\n    // time we need to look at them.\n\n    if (!dummy) {\n      this.dev = dev;\n      this.optional = optional;\n      this.devOptional = devOptional;\n      this.peer = peer;\n      this.extraneous = extraneous;\n      this.dummy = false;\n    } else {\n      // true if this is a placeholder for the purpose of serving as a\n      // fsParent to link targets that get their deps resolved outside\n      // the root tree folder.\n      this.dummy = true;\n      this.dev = false;\n      this.optional = false;\n      this.devOptional = false;\n      this.peer = false;\n      this.extraneous = false;\n    }\n\n    this.edgesIn = new Set();\n    this.edgesOut = new Map(); // have to set the internal package ref before assigning the parent,\n    // because this.package is read when adding to inventory\n\n    this[_package] = pkg && typeof pkg === 'object' ? pkg : {}; // only relevant for the root and top nodes\n\n    this.meta = meta; // Note: this is _slightly_ less efficient for the initial tree\n    // building than it could be, but in exchange, it's a much simpler\n    // algorithm.\n    // If this node has a bunch of children, and those children satisfy\n    // its various deps, then we're going to _first_ create all the\n    // edges, and _then_ assign the children into place, re-resolving\n    // them all in _reloadNamedEdges.\n    // A more efficient, but more complicated, approach would be to\n    // flag this node as being a part of a tree build, so it could\n    // hold off on resolving its deps until its children are in place.\n    // call the parent setter\n    // Must be set prior to calling _loadDeps, because top-ness is relevant\n    // will also assign root if present on the parent\n\n    this[_parent] = null;\n    this.parent = parent || null;\n    this[_fsParent] = null;\n    this.fsParent = fsParent || null; // see parent/root setters below.\n    // root is set to parent's root if we have a parent, otherwise if it's\n    // null, then it's set to the node itself.\n\n    if (!parent && !fsParent) this.root = root || null; // mostly a convenience for testing, but also a way to create\n    // trees in a more declarative way than setting parent on each\n\n    if (children) {\n      for (const c of children) new Node({ ...c,\n        parent: this\n      });\n    }\n\n    if (fsChildren) {\n      for (const c of fsChildren) new Node({ ...c,\n        fsParent: this\n      });\n    } // now load all the dep edges\n\n\n    this[_loadDeps]();\n  }\n\n  get meta() {\n    return this[_meta];\n  }\n\n  set meta(meta) {\n    this[_meta] = meta;\n    if (meta) meta.add(this);\n  }\n\n  get global() {\n    return this.root[_global];\n  } // true for packages installed directly in the global node_modules folder\n\n\n  get globalTop() {\n    return this.global && this.parent.isProjectRoot;\n  }\n\n  get workspaces() {\n    return this[_workspaces];\n  }\n\n  set workspaces(workspaces) {\n    // deletes edges if they already exists\n    if (this[_workspaces]) {\n      for (const name of this[_workspaces].keys()) {\n        if (!workspaces.has(name)) this.edgesOut.get(name).detach();\n      }\n    }\n\n    this[_workspaces] = workspaces;\n\n    this[_loadWorkspaces]();\n\n    this[_loadDeps]();\n  }\n\n  get binPaths() {\n    if (!this.parent) return [];\n    return getBinPaths({\n      pkg: this[_package],\n      path: this.path,\n      global: this.global,\n      top: this.globalTop\n    });\n  }\n\n  get hasInstallScript() {\n    const {\n      hasInstallScript,\n      scripts\n    } = this.package;\n    const {\n      install,\n      preinstall,\n      postinstall\n    } = scripts || {};\n    return !!(hasInstallScript || install || preinstall || postinstall);\n  }\n\n  get version() {\n    return this[_package].version || '';\n  }\n\n  get packageName() {\n    return this[_package].name || null;\n  }\n\n  get pkgid() {\n    const {\n      name = '',\n      version = ''\n    } = this.package; // root package will prefer package name over folder name,\n    // and never be called an alias.\n\n    const {\n      isProjectRoot\n    } = this;\n    const myname = isProjectRoot ? name || this.name : this.name;\n    const alias = !isProjectRoot && name && myname !== name ? `npm:${name}@` : '';\n    return `${myname}@${alias}${version}`;\n  }\n\n  get package() {\n    return this[_package];\n  }\n\n  set package(pkg) {\n    // just detach them all.  we could make this _slightly_ more efficient\n    // by only detaching the ones that changed, but we'd still have to walk\n    // them all, and the comparison logic gets a bit tricky.  we generally\n    // only do this more than once at the root level, so the resolve() calls\n    // are only one level deep, and there's not much to be saved, anyway.\n    // simpler to just toss them all out.\n    for (const edge of this.edgesOut.values()) edge.detach();\n\n    this[_explanation] = null;\n    /* istanbul ignore next - should be impossible */\n\n    if (!pkg || typeof pkg !== 'object') {\n      debug(() => {\n        throw new Error('setting Node.package to non-object');\n      });\n      pkg = {};\n    }\n\n    this[_package] = pkg;\n\n    this[_loadWorkspaces]();\n\n    this[_loadDeps](); // do a hard reload, since the dependents may now be valid or invalid\n    // as a result of the package change.\n\n\n    this.edgesIn.forEach(edge => edge.reload(true));\n  } // node.explain(nodes seen already, edge we're trying to satisfy\n  // if edge is not specified, it lists every edge into the node.\n\n\n  explain(edge = null, seen = []) {\n    if (this[_explanation]) return this[_explanation];\n    return this[_explanation] = this[_explain](edge, seen);\n  }\n\n  [_explain](edge, seen) {\n    if (this.isProjectRoot && !this.sourceReference) {\n      return {\n        location: this.path\n      };\n    }\n\n    const why = {\n      name: this.isProjectRoot || this.isTop ? this.packageName : this.name,\n      version: this.package.version\n    };\n\n    if (this.errors.length || !this.packageName || !this.package.version) {\n      why.errors = this.errors.length ? this.errors : [new Error('invalid package: lacks name and/or version')];\n      why.package = this.package;\n    }\n\n    if (this.root.sourceReference) {\n      const {\n        name,\n        version\n      } = this.root.package;\n      why.whileInstalling = {\n        name,\n        version,\n        path: this.root.sourceReference.path\n      };\n    }\n\n    if (this.sourceReference) return this.sourceReference.explain(edge, seen);\n    if (seen.includes(this)) return why;\n    why.location = this.location;\n    why.isWorkspace = this.isWorkspace; // make a new list each time.  we can revisit, but not loop.\n\n    seen = seen.concat(this);\n    why.dependents = [];\n    if (edge) why.dependents.push(edge.explain(seen));else {\n      // ignore invalid edges, since those aren't satisfied by this thing,\n      // and are not keeping it held in this spot anyway.\n      const edges = [];\n\n      for (const edge of this.edgesIn) {\n        if (!edge.valid && !edge.from.isProjectRoot) continue;\n        edges.push(edge);\n      }\n\n      for (const edge of edges) why.dependents.push(edge.explain(seen));\n    }\n    if (this.linksIn.size) why.linksIn = [...this.linksIn].map(link => link[_explain](edge, seen));\n    return why;\n  }\n\n  isDescendantOf(node) {\n    for (let p = this; p; p = p.resolveParent) {\n      if (p === node) return true;\n    }\n\n    return false;\n  }\n\n  getBundler(path = []) {\n    // made a cycle, definitely not bundled!\n    if (path.includes(this)) return null;\n    path.push(this);\n    const parent = this[_parent];\n    if (!parent) return null;\n    const pBundler = parent.getBundler(path);\n    if (pBundler) return pBundler;\n    const ppkg = parent.package;\n    const bd = ppkg && ppkg.bundleDependencies; // explicit bundling\n\n    if (Array.isArray(bd) && bd.includes(this.name)) return parent; // deps that are deduped up to the bundling level are bundled.\n    // however, if they get their dep met further up than that,\n    // then they are not bundled.  Ie, installing a package with\n    // unmet bundled deps will not cause your deps to be bundled.\n\n    for (const edge of this.edgesIn) {\n      const eBundler = edge.from.getBundler(path);\n      if (!eBundler) continue;\n      if (eBundler === parent) return eBundler;\n    }\n\n    return null;\n  }\n\n  get inBundle() {\n    return !!this.getBundler();\n  } // when reifying, if a package is technically in a bundleDependencies list,\n  // but that list is the root project, we still have to install it.  This\n  // getter returns true if it's in a dependency's bundle list, not the root's.\n\n\n  get inDepBundle() {\n    const bundler = this.getBundler();\n    return !!bundler && bundler !== this.root;\n  }\n\n  get isWorkspace() {\n    if (this.isProjectRoot) return false;\n    const {\n      root\n    } = this;\n    const {\n      type,\n      to\n    } = root.edgesOut.get(this.packageName) || {};\n    return type === 'workspace' && to && (to.target === this || to === this);\n  }\n\n  get isRoot() {\n    return this === this.root;\n  }\n\n  get isProjectRoot() {\n    return this === this.root || this === this.root.target;\n  }\n\n  set root(root) {\n    // setting to null means this is the new root\n    // should only ever be one step\n    while (root && root.root !== root) root = root.root;\n\n    root = root || this; // delete from current root inventory\n\n    this[_delistFromMeta](); // can't set the root (yet) if there's no way to determine location\n    // this allows us to do new Node({...}) and then set the root later.\n    // just make the assignment so we don't lose it, and move on.\n\n\n    if (!this.path || !root.realpath || !root.path) return this[_root] = root; // temporarily become a root node\n\n    this[_root] = this; // break all linksIn, we're going to re-set them if needed later\n\n    for (const link of this.linksIn) {\n      link[_target] = null;\n      this.linksIn.delete(link);\n    } // temporarily break this link as well, we'll re-set if possible later\n\n\n    const {\n      target\n    } = this;\n\n    if (this.isLink) {\n      if (target) {\n        target.linksIn.delete(this);\n        if (target.root === this) target[_delistFromMeta]();\n      }\n\n      this[_target] = null;\n    } // if this is part of a cascading root set, then don't do this bit\n    // but if the parent/fsParent is in a different set, we have to break\n    // that reference before proceeding\n\n\n    if (this.parent && this.parent.root !== root) {\n      this.parent.children.delete(this.name);\n      this[_parent] = null;\n    }\n\n    if (this.fsParent && this.fsParent.root !== root) {\n      this.fsParent.fsChildren.delete(this);\n      this[_fsParent] = null;\n    }\n\n    if (root === this) this[_refreshLocation]();else {\n      // setting to some different node.\n      const loc = relpath(root.realpath, this.path);\n      const current = root.inventory.get(loc); // clobber whatever is there now\n\n      if (current) current.root = null;\n      this[_root] = root; // set this.location and add to inventory\n\n      this[_refreshLocation](); // try to find our parent/fsParent in the new root inventory\n\n\n      for (const p of walkUp(dirname(this.path))) {\n        if (p === this.path) continue;\n        const ploc = relpath(root.realpath, p);\n        const parent = root.inventory.get(ploc);\n\n        if (parent) {\n          /* istanbul ignore next - impossible */\n          if (parent.isLink) {\n            debug(() => {\n              throw Object.assign(new Error('assigning parentage to link'), {\n                path: this.path,\n                parent: parent.path,\n                parentReal: parent.realpath\n              });\n            });\n            continue;\n          }\n\n          const childLoc = `${ploc}${ploc ? '/' : ''}node_modules/${this.name}`;\n          const isParent = this.location === childLoc;\n\n          if (isParent) {\n            const oldChild = parent.children.get(this.name);\n            if (oldChild && oldChild !== this) oldChild.root = null;\n\n            if (this.parent) {\n              this.parent.children.delete(this.name);\n\n              this.parent[_reloadNamedEdges](this.name);\n            }\n\n            parent.children.set(this.name, this);\n            this[_parent] = parent; // don't do it for links, because they don't have a target yet\n            // we'll hit them up a bit later on.\n\n            if (!this.isLink) parent[_reloadNamedEdges](this.name);\n          } else {\n            /* istanbul ignore if - should be impossible, since we break\n             * all fsParent/child relationships when moving? */\n            if (this.fsParent) this.fsParent.fsChildren.delete(this);\n            parent.fsChildren.add(this);\n            this[_fsParent] = parent;\n          }\n\n          break;\n        }\n      } // if it doesn't have a parent, it's a top node\n\n\n      if (!this.parent) root.tops.add(this);else root.tops.delete(this); // assign parentage for any nodes that need to have this as a parent\n      // this can happen when we have a node at nm/a/nm/b added *before*\n      // the node at nm/a, which might have the root node as a fsParent.\n      // we can't rely on the public setter here, because it calls into\n      // this function to set up these references!\n\n      const nmloc = `${this.location}${this.location ? '/' : ''}node_modules/`;\n\n      const isChild = n => n.location === nmloc + n.name; // check dirname so that /foo isn't treated as the fsparent of /foo-bar\n\n\n      const isFsChild = n => dirname(n.path).startsWith(this.path) && n !== this && !n.parent && (!n.fsParent || n.fsParent === this || dirname(this.path).startsWith(n.fsParent.path));\n\n      const isKid = n => isChild(n) || isFsChild(n); // only walk top nodes, since anything else already has a parent.\n\n\n      for (const child of root.tops) {\n        if (!isKid(child)) continue; // set up the internal parentage links\n\n        if (this.isLink) child.root = null;else {\n          // can't possibly have a parent, because it's in tops\n          if (child.fsParent) child.fsParent.fsChildren.delete(child);\n          child[_fsParent] = null;\n\n          if (isChild(child)) {\n            this.children.set(child.name, child);\n            child[_parent] = this;\n            root.tops.delete(child);\n          } else {\n            this.fsChildren.add(child);\n            child[_fsParent] = this;\n          }\n        }\n      } // look for any nodes with the same realpath.  either they're links\n      // to that realpath, or a thing at that realpath if we're adding a link\n      // (if we're adding a regular node, we already deleted the old one)\n\n\n      for (const node of root.inventory.query('realpath', this.realpath)) {\n        if (node === this) continue;\n        /* istanbul ignore next - should be impossible */\n\n        debug(() => {\n          if (node.root !== root) throw new Error('inventory contains node from other root');\n        });\n\n        if (this.isLink) {\n          const target = node.target;\n          this[_target] = target;\n          this[_package] = target.package;\n          target.linksIn.add(this); // reload edges here, because now we have a target\n\n          if (this.parent) this.parent[_reloadNamedEdges](this.name);\n          break;\n        } else {\n          /* istanbul ignore else - should be impossible */\n          if (node.isLink) {\n            node[_target] = this;\n            node[_package] = this.package;\n            this.linksIn.add(node);\n            if (node.parent) node.parent[_reloadNamedEdges](node.name);\n          } else {\n            debug(() => {\n              throw Object.assign(new Error('duplicate node in root setter'), {\n                path: this.path,\n                realpath: this.realpath,\n                root: root.realpath\n              });\n            });\n          }\n        }\n      }\n    } // reload all edgesIn where the root doesn't match, so we don't have\n    // cross-tree dependency graphs\n\n    for (const edge of this.edgesIn) {\n      if (edge.from.root !== root) edge.reload();\n    } // reload all edgesOut where root doens't match, or is missing, since\n    // it might not be missing in the new tree\n\n\n    for (const edge of this.edgesOut.values()) {\n      if (!edge.to || edge.to.root !== root) edge.reload();\n    } // now make sure our family comes along for the ride!\n\n\n    const family = new Set([...this.fsChildren, ...this.children.values(), ...this.inventory.values()].filter(n => n !== this));\n\n    for (const child of family) {\n      if (child.root !== root) {\n        child[_delistFromMeta]();\n\n        child[_parent] = null;\n        this.children.delete(child.name);\n        child[_fsParent] = null;\n        this.fsChildren.delete(child);\n\n        for (const l of child.linksIn) {\n          l[_target] = null;\n          child.linksIn.delete(l);\n        }\n      }\n    }\n\n    for (const child of family) {\n      if (child.root !== root) child.root = root;\n    } // if we had a target, and didn't find one in the new root, then bring\n    // it over as well, but only if we're setting the link into a new root,\n    // as we don't want to lose the target any time we remove a link.\n\n\n    if (this.isLink && target && !this.target && root !== this) target.root = root; // tree should always be valid upon root setter completion.\n\n    treeCheck(this);\n    treeCheck(root);\n  }\n\n  get root() {\n    return this[_root] || this;\n  }\n\n  [_loadWorkspaces]() {\n    if (!this[_workspaces]) return;\n\n    for (const [name, path] of this[_workspaces].entries()) new Edge({\n      from: this,\n      name,\n      spec: `file:${path}`,\n      type: 'workspace'\n    });\n  }\n\n  [_loadDeps]() {\n    // Caveat!  Order is relevant!\n    // Packages in optionalDependencies are optional.\n    // Packages in both deps and devDeps are required.\n    // Note the subtle breaking change from v6: it is no longer possible\n    // to have a different spec for a devDep than production dep.\n    // Linked targets that are disconnected from the tree are tops,\n    // but don't have a 'path' field, only a 'realpath', because we\n    // don't know their canonical location. We don't need their devDeps.\n    const pd = this.package.peerDependencies;\n\n    if (pd && typeof pd === 'object' && !this.legacyPeerDeps) {\n      const pm = this.package.peerDependenciesMeta || {};\n      const peerDependencies = {};\n      const peerOptional = {};\n\n      for (const [name, dep] of Object.entries(pd)) {\n        if (pm[name] && pm[name].optional) peerOptional[name] = dep;else peerDependencies[name] = dep;\n      }\n\n      this[_loadDepType](peerDependencies, 'peer');\n\n      this[_loadDepType](peerOptional, 'peerOptional');\n    }\n\n    this[_loadDepType](this.package.dependencies, 'prod');\n\n    this[_loadDepType](this.package.optionalDependencies, 'optional');\n\n    const {\n      isTop,\n      path,\n      sourceReference\n    } = this;\n    const {\n      isTop: srcTop,\n      path: srcPath\n    } = sourceReference || {};\n    if (isTop && path && (!sourceReference || srcTop && srcPath)) this[_loadDepType](this.package.devDependencies, 'dev');\n  }\n\n  [_loadDepType](deps, type) {\n    const ad = this.package.acceptDependencies || {}; // Because of the order in which _loadDeps runs, we always want to\n    // prioritize a new edge over an existing one\n\n    for (const [name, spec] of Object.entries(deps || {})) {\n      const current = this.edgesOut.get(name);\n      if (!current || current.type !== 'workspace') new Edge({\n        from: this,\n        name,\n        spec,\n        accept: ad[name],\n        type\n      });\n    }\n  }\n\n  get fsParent() {\n    const parent = this[_fsParent];\n    /* istanbul ignore next - should be impossible */\n\n    debug(() => {\n      if (parent === this) throw new Error('node set to its own fsParent');\n    });\n    return parent;\n  }\n\n  set fsParent(fsParent) {\n    if (!fsParent) {\n      if (this[_fsParent]) this.root = null;\n      return;\n    }\n\n    debug(() => {\n      if (fsParent === this) throw new Error('setting node to its own fsParent');\n      if (fsParent.realpath === this.realpath) throw new Error('setting fsParent to same path'); // the initial set MUST be an actual walk-up from the realpath\n      // subsequent sets will re-root on the new fsParent's path.\n\n      if (!this[_fsParent] && this.realpath.indexOf(fsParent.realpath) !== 0) {\n        throw Object.assign(new Error('setting fsParent improperly'), {\n          path: this.path,\n          realpath: this.realpath,\n          fsParent: {\n            path: fsParent.path,\n            realpath: fsParent.realpath\n          }\n        });\n      }\n    });\n    if (fsParent.isLink) fsParent = fsParent.target; // setting a thing to its own fsParent is not normal, but no-op for safety\n\n    if (this === fsParent || fsParent.realpath === this.realpath) return; // nothing to do\n\n    if (this[_fsParent] === fsParent) return;\n    const oldFsParent = this[_fsParent];\n    const newPath = !oldFsParent ? this.path : resolve(fsParent.path, relative(oldFsParent.path, this.path));\n    const nmPath = resolve(fsParent.path, 'node_modules', this.name); // this is actually the parent, set that instead\n\n    if (newPath === nmPath) {\n      this.parent = fsParent;\n      return;\n    }\n\n    const pathChange = newPath !== this.path; // remove from old parent/fsParent\n\n    const oldParent = this.parent;\n    const oldName = this.name;\n\n    if (this.parent) {\n      this.parent.children.delete(this.name);\n      this[_parent] = null;\n    }\n\n    if (this.fsParent) {\n      this.fsParent.fsChildren.delete(this);\n      this[_fsParent] = null;\n    } // update this.path/realpath for this and all children/fsChildren\n\n\n    if (pathChange) this[_changePath](newPath);\n    if (oldParent) oldParent[_reloadNamedEdges](oldName); // clobbers anything at that path, resets all appropriate references\n\n    this.root = fsParent.root;\n  } // is it safe to replace one node with another?  check the edges to\n  // make sure no one will get upset.  Note that the node might end up\n  // having its own unmet dependencies, if the new node has new deps.\n  // Note that there are cases where Arborist will opt to insert a node\n  // into the tree even though this function returns false!  This is\n  // necessary when a root dependency is added or updated, or when a\n  // root dependency brings peer deps along with it.  In that case, we\n  // will go ahead and create the invalid state, and then try to resolve\n  // it with more tree construction, because it's a user request.\n\n\n  canReplaceWith(node) {\n    if (node.name !== this.name) return false; // gather up all the deps of this node and that are only depended\n    // upon by deps of this node.  those ones don't count, since\n    // they'll be replaced if this node is replaced anyway.\n\n    const depSet = gatherDepSet([this], e => e.to !== this && e.valid);\n\n    for (const edge of this.edgesIn) {\n      // only care about edges that don't originate from this node\n      if (!depSet.has(edge.from) && !edge.satisfiedBy(node)) return false;\n    }\n\n    return true;\n  }\n\n  canReplace(node) {\n    return node.canReplaceWith(this);\n  } // return true if it's safe to remove this node, because anything that\n  // is depending on it would be fine with the thing that they would resolve\n  // to if it was removed, or nothing is depending on it in the first place.\n\n\n  canDedupe(preferDedupe = false) {\n    // not allowed to mess with shrinkwraps or bundles\n    if (this.inDepBundle || this.inShrinkwrap) return false; // it's a top level pkg, or a dep of one\n\n    if (!this.resolveParent || !this.resolveParent.resolveParent) return false; // no one wants it, remove it\n\n    if (this.edgesIn.size === 0) return true;\n    const other = this.resolveParent.resolveParent.resolve(this.name); // nothing else, need this one\n\n    if (!other) return false; // if it's the same thing, then always fine to remove\n\n    if (other.matches(this)) return true; // if the other thing can't replace this, then skip it\n\n    if (!other.canReplace(this)) return false; // if we prefer dedupe, or if the version is greater/equal, take the other\n\n    if (preferDedupe || semver.gte(other.version, this.version)) return true;\n    return false;\n  }\n\n  satisfies(requested) {\n    if (requested instanceof Edge) return this.name === requested.name && requested.satisfiedBy(this);\n    const parsed = npa(requested);\n    const {\n      name = this.name,\n      rawSpec: spec\n    } = parsed;\n    return this.name === name && this.satisfies(new Edge({\n      from: new Node({\n        path: this.root.realpath\n      }),\n      type: 'prod',\n      name,\n      spec\n    }));\n  }\n\n  matches(node) {\n    // if the nodes are literally the same object, obviously a match.\n    if (node === this) return true; // if the names don't match, they're different things, even if\n    // the package contents are identical.\n\n    if (node.name !== this.name) return false; // if they're links, they match if the targets match\n\n    if (this.isLink) return node.isLink && this.target.matches(node.target); // if they're two project root nodes, they're different if the paths differ\n\n    if (this.isProjectRoot && node.isProjectRoot) return this.path === node.path; // if the integrity matches, then they're the same.\n\n    if (this.integrity && node.integrity) return this.integrity === node.integrity; // if no integrity, check resolved\n\n    if (this.resolved && node.resolved) return this.resolved === node.resolved; // if no resolved, check both package name and version\n    // otherwise, conclude that they are different things\n\n    return this.packageName && node.packageName && this.packageName === node.packageName && this.version && node.version && this.version === node.version;\n  } // replace this node with the supplied argument\n  // Useful when mutating an ideal tree, so we can avoid having to call\n  // the parent/root setters more than necessary.\n\n\n  replaceWith(node) {\n    node.replace(this);\n  }\n\n  replace(node) {\n    this[_delistFromMeta]();\n\n    this.path = node.path;\n    this.name = node.name;\n    if (!this.isLink) this.realpath = this.path;\n\n    this[_refreshLocation](); // keep children when a node replaces another\n\n\n    if (!this.isLink) {\n      for (const kid of node.children.values()) kid.parent = this;\n    }\n\n    if (!node.isRoot) this.root = node.root;\n    treeCheck(this);\n  }\n\n  get inShrinkwrap() {\n    return this.parent && (this.parent.hasShrinkwrap || this.parent.inShrinkwrap);\n  }\n\n  get parent() {\n    const parent = this[_parent];\n    /* istanbul ignore next - should be impossible */\n\n    debug(() => {\n      if (parent === this) throw new Error('node set to its own parent');\n    });\n    return parent;\n  } // This setter keeps everything in order when we move a node from\n  // one point in a logical tree to another.  Edges get reloaded,\n  // metadata updated, etc.  It's also called when we *replace* a node\n  // with another by the same name (eg, to update or dedupe).\n  // This does a couple of walks out on the node_modules tree, recursing\n  // into child nodes.  However, as setting the parent is typically done\n  // with nodes that don't have have many children, and (deduped) package\n  // trees tend to be broad rather than deep, it's not that bad.\n  // The only walk that starts from the parent rather than this node is\n  // limited by edge name.\n\n\n  set parent(parent) {\n    // when setting to null, just remove it from the tree entirely\n    if (!parent) {\n      // but only delete it if we actually had a parent in the first place\n      // otherwise it's just setting to null when it's already null\n      if (this[_parent]) this.root = null;\n      return;\n    }\n\n    if (parent.isLink) parent = parent.target; // setting a thing to its own parent is not normal, but no-op for safety\n\n    if (this === parent) return;\n    const oldParent = this[_parent]; // nothing to do\n\n    if (oldParent === parent) return; // ok now we know something is actually changing, and parent is not a link\n\n    const newPath = resolve(parent.path, 'node_modules', this.name);\n    const pathChange = newPath !== this.path; // remove from old parent/fsParent\n\n    if (oldParent) {\n      oldParent.children.delete(this.name);\n      this[_parent] = null;\n    }\n\n    if (this.fsParent) {\n      this.fsParent.fsChildren.delete(this);\n      this[_fsParent] = null;\n    } // update this.path/realpath for this and all children/fsChildren\n\n\n    if (pathChange) this[_changePath](newPath); // clobbers anything at that path, resets all appropriate references\n\n    this.root = parent.root;\n  } // Call this before changing path or updating the _root reference.\n  // Removes the node from its root the metadata and inventory.\n\n\n  [_delistFromMeta]() {\n    const root = this.root;\n    if (!root.realpath || !this.path) return;\n    root.inventory.delete(this);\n    root.tops.delete(this);\n    if (root.meta) root.meta.delete(this.path);\n    /* istanbul ignore next - should be impossible */\n\n    debug(() => {\n      if ([...root.inventory.values()].includes(this)) throw new Error('failed to delist');\n    });\n  } // update this.path/realpath and the paths of all children/fsChildren\n\n\n  [_changePath](newPath) {\n    // have to de-list before changing paths\n    this[_delistFromMeta]();\n\n    const oldPath = this.path;\n    this.path = newPath;\n    const namePattern = /(?:^|\\/|\\\\)node_modules[\\\\/](@[^/\\\\]+[\\\\/][^\\\\/]+|[^\\\\/]+)$/;\n    const nameChange = newPath.match(namePattern);\n    if (nameChange && this.name !== nameChange[1]) this.name = nameChange[1].replace(/\\\\/g, '/'); // if we move a link target, update link realpaths\n\n    if (!this.isLink) {\n      this.realpath = newPath;\n\n      for (const link of this.linksIn) {\n        link[_delistFromMeta]();\n\n        link.realpath = newPath;\n\n        link[_refreshLocation]();\n      }\n    } // if we move /x to /y, then a module at /x/a/b becomes /y/a/b\n\n\n    for (const child of this.fsChildren) child[_changePath](resolve(newPath, relative(oldPath, child.path)));\n\n    for (const [name, child] of this.children.entries()) child[_changePath](resolve(newPath, 'node_modules', name));\n\n    this[_refreshLocation]();\n  } // Called whenever the root/parent is changed.\n  // NB: need to remove from former root's meta/inventory and then update\n  // this.path BEFORE calling this method!\n\n\n  [_refreshLocation]() {\n    const root = this.root;\n    const loc = relpath(root.realpath, this.path);\n    this.location = loc;\n    root.inventory.add(this);\n    if (root.meta) root.meta.add(this);\n  }\n\n  addEdgeOut(edge) {\n    this.edgesOut.set(edge.name, edge);\n  }\n\n  addEdgeIn(edge) {\n    this.edgesIn.add(edge); // try to get metadata from the yarn.lock file\n\n    if (this.root.meta) this.root.meta.addEdge(edge);\n  }\n\n  [_reloadNamedEdges](name, rootLoc = this.location) {\n    const edge = this.edgesOut.get(name); // if we don't have an edge, do nothing, but keep descending\n\n    const rootLocResolved = edge && edge.to && edge.to.location === `${rootLoc}/node_modules/${edge.name}`;\n    const sameResolved = edge && this.resolve(name) === edge.to;\n    const recheck = rootLocResolved || !sameResolved;\n    if (edge && recheck) edge.reload(true);\n\n    for (const c of this.children.values()) c[_reloadNamedEdges](name, rootLoc);\n\n    for (const c of this.fsChildren) c[_reloadNamedEdges](name, rootLoc);\n  }\n\n  get isLink() {\n    return false;\n  }\n\n  get target() {\n    return this;\n  }\n\n  set target(n) {\n    debug(() => {\n      throw Object.assign(new Error('cannot set target on non-Link Nodes'), {\n        path: this.path\n      });\n    });\n  }\n\n  get depth() {\n    return this.isTop ? 0 : this.parent.depth + 1;\n  }\n\n  get isTop() {\n    return !this.parent;\n  }\n\n  get top() {\n    return this.isTop ? this : this.parent.top;\n  }\n\n  get isFsTop() {\n    return !this.fsParent;\n  }\n\n  get fsTop() {\n    return this.isFsTop ? this : this.fsParent.fsTop;\n  }\n\n  get resolveParent() {\n    return this.parent || this.fsParent;\n  }\n\n  resolve(name) {\n    const mine = this.children.get(name);\n    if (mine) return mine;\n    const resolveParent = this.resolveParent;\n    if (resolveParent) return resolveParent.resolve(name);\n    return null;\n  }\n\n  inNodeModules() {\n    const rp = this.realpath;\n    const name = this.name;\n    const scoped = name.charAt(0) === '@';\n    const d = dirname(rp);\n    const nm = scoped ? dirname(d) : d;\n    const dir = dirname(nm);\n    const base = scoped ? `${basename(d)}/${basename(rp)}` : basename(rp);\n    return base === name && basename(nm) === 'node_modules' ? dir : false;\n  }\n\n  toJSON() {\n    return printableTree(this);\n  }\n\n  [util.inspect.custom]() {\n    return this.toJSON();\n  }\n\n}\n\nmodule.exports = Node;","map":{"version":3,"sources":["/Users/johndoe/Nebe-data-vistualization/node_modules/npm/node_modules/@npmcli/arborist/lib/node.js"],"names":["semver","require","nameFromFolder","Edge","Inventory","normalize","getPaths","getBinPaths","npa","debug","gatherDepSet","treeCheck","walkUp","resolve","relative","dirname","basename","util","_package","Symbol","_parent","_target","for","_fsParent","_loadDepType","_loadWorkspaces","_reloadNamedEdges","_loadDeps","_root","_refreshLocation","_changePath","_delistFromMeta","_global","_workspaces","_explain","_explanation","_meta","relpath","consistentResolve","printableTree","Node","constructor","options","root","path","realpath","parent","error","meta","fsParent","resolved","integrity","name","children","fsChildren","legacyPeerDeps","linksIn","hasShrinkwrap","extraneous","dev","optional","devOptional","peer","global","dummy","sourceReference","errors","pkg","package","TypeError","isLink","_resolved","test","_where","_integrity","_hasShrinkwrap","Map","Set","inventory","tops","edgesIn","edgesOut","c","add","globalTop","isProjectRoot","workspaces","keys","has","get","detach","binPaths","top","hasInstallScript","scripts","install","preinstall","postinstall","version","packageName","pkgid","myname","alias","edge","values","Error","forEach","reload","explain","seen","location","why","isTop","length","whileInstalling","includes","isWorkspace","concat","dependents","push","edges","valid","from","size","map","link","isDescendantOf","node","p","resolveParent","getBundler","pBundler","ppkg","bd","bundleDependencies","Array","isArray","eBundler","inBundle","inDepBundle","bundler","type","to","target","isRoot","delete","loc","current","ploc","Object","assign","parentReal","childLoc","isParent","oldChild","set","nmloc","isChild","n","isFsChild","startsWith","isKid","child","query","family","filter","l","entries","spec","pd","peerDependencies","pm","peerDependenciesMeta","peerOptional","dep","dependencies","optionalDependencies","srcTop","srcPath","devDependencies","deps","ad","acceptDependencies","accept","indexOf","oldFsParent","newPath","nmPath","pathChange","oldParent","oldName","canReplaceWith","depSet","e","satisfiedBy","canReplace","canDedupe","preferDedupe","inShrinkwrap","other","matches","gte","satisfies","requested","parsed","rawSpec","replaceWith","replace","kid","oldPath","namePattern","nameChange","match","addEdgeOut","addEdgeIn","addEdge","rootLoc","rootLocResolved","sameResolved","recheck","depth","isFsTop","fsTop","mine","inNodeModules","rp","scoped","charAt","d","nm","dir","base","toJSON","inspect","custom","module","exports"],"mappings":"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","sourcesContent":["// inventory, path, realpath, root, and parent\n//\n// node.root is a reference to the root module in the tree (ie, typically the\n// cwd project folder)\n//\n// node.location is the /-delimited path from the root module to the node.  In\n// the case of link targets that may be outside of the root's package tree,\n// this can include some number of /../ path segments.  The location of the\n// root module is always '.'.  node.location thus never contains drive letters\n// or absolute paths, and is portable within a given project, suitable for\n// inclusion in lockfiles and metadata.\n//\n// node.path is the path to the place where this node lives on disk.  It is\n// system-specific and absolute.\n//\n// node.realpath is the path to where the module actually resides on disk.  In\n// the case of non-link nodes, node.realpath is equivalent to node.path.  In\n// the case of link nodes, it is equivalent to node.target.path.\n//\n// Setting node.parent will set the node's root to the parent's root, as well\n// as updating edgesIn and edgesOut to reload dependency resolutions as needed,\n// and setting node.path to parent.path/node_modules/name.\n//\n// node.inventory is a Map of name to a Set() of all the nodes under a given\n// root by that name.  It's empty for non-root nodes, and changing the root\n// reference will remove it from the old root's inventory and add it to the new\n// one.  This map is useful for cases like `npm update foo` or `npm ls foo`\n// where we need to quickly find all instances of a given package name within a\n// tree.\n\nconst semver = require('semver')\nconst nameFromFolder = require('@npmcli/name-from-folder')\nconst Edge = require('./edge.js')\nconst Inventory = require('./inventory.js')\nconst {normalize} = require('read-package-json-fast')\nconst {getPaths: getBinPaths} = require('bin-links')\nconst npa = require('npm-package-arg')\nconst debug = require('./debug.js')\nconst gatherDepSet = require('./gather-dep-set.js')\nconst treeCheck = require('./tree-check.js')\nconst walkUp = require('walk-up-path')\n\nconst {resolve, relative, dirname, basename} = require('path')\nconst util = require('util')\nconst _package = Symbol('_package')\nconst _parent = Symbol('_parent')\nconst _target = Symbol.for('_target')\nconst _fsParent = Symbol('_fsParent')\nconst _loadDepType = Symbol('_loadDepType')\nconst _loadWorkspaces = Symbol('_loadWorkspaces')\nconst _reloadNamedEdges = Symbol('_reloadNamedEdges')\n// overridden by Link class\nconst _loadDeps = Symbol.for('Arborist.Node._loadDeps')\nconst _root = Symbol('_root')\nconst _refreshLocation = Symbol.for('_refreshLocation')\nconst _changePath = Symbol.for('_changePath')\n// used by Link class as well\nconst _delistFromMeta = Symbol.for('_delistFromMeta')\nconst _global = Symbol.for('global')\nconst _workspaces = Symbol('_workspaces')\nconst _explain = Symbol('_explain')\nconst _explanation = Symbol('_explanation')\nconst _meta = Symbol('_meta')\n\nconst relpath = require('./relpath.js')\nconst consistentResolve = require('./consistent-resolve.js')\n\nconst printableTree = require('./printable.js')\n\nclass Node {\n  constructor (options) {\n    // NB: path can be null if it's a link target\n    const {\n      root,\n      path,\n      realpath,\n      parent,\n      error,\n      meta,\n      fsParent,\n      resolved,\n      integrity,\n      // allow setting name explicitly when we haven't set a path yet\n      name,\n      children,\n      fsChildren,\n      legacyPeerDeps = false,\n      linksIn,\n      hasShrinkwrap,\n      extraneous = true,\n      dev = true,\n      optional = true,\n      devOptional = true,\n      peer = true,\n      global = false,\n      dummy = false,\n      sourceReference = null,\n    } = options\n\n    // true if part of a global install\n    this[_global] = global\n\n    this[_workspaces] = null\n\n    this.errors = error ? [error] : []\n\n    // this will usually be null, except when modeling a\n    // package's dependencies in a virtual root.\n    this.sourceReference = sourceReference\n\n    const pkg = sourceReference ? sourceReference.package\n      : normalize(options.pkg || {})\n\n    this.name = name ||\n      nameFromFolder(path || pkg.name || realpath) ||\n      pkg.name ||\n      null\n\n    // should be equal if not a link\n    this.path = path ? resolve(path) : null\n\n    if (!this.name && (!this.path || this.path !== dirname(this.path)))\n      throw new TypeError('could not detect node name from path or package')\n\n    this.realpath = !this.isLink ? this.path : resolve(realpath)\n\n    this.resolved = resolved || null\n    if (!this.resolved) {\n      // note: this *only* works for non-file: deps, so we avoid even\n      // trying here.\n      // file: deps are tracked in package.json will _resolved set to the\n      // full path to the tarball or link target.  However, if the package\n      // is checked into git or moved to another location, that's 100% not\n      // portable at all!  The _where and _location don't provide much help,\n      // since _location is just where the module ended up in the tree,\n      // and _where can be different than the actual root if it's a\n      // meta-dep deeper in the dependency graph.\n      //\n      // If we don't have the other oldest indicators of legacy npm, then it's\n      // probably what we're getting from pacote, which IS trustworthy.\n      //\n      // Otherwise, hopefully a shrinkwrap will help us out.\n      const resolved = consistentResolve(pkg._resolved)\n      if (resolved && !(/^file:/.test(resolved) && pkg._where))\n        this.resolved = resolved\n    }\n    this.integrity = integrity || pkg._integrity || null\n    this.hasShrinkwrap = hasShrinkwrap || pkg._hasShrinkwrap || false\n    this.legacyPeerDeps = legacyPeerDeps\n\n    this.children = new Map()\n    this.fsChildren = new Set()\n    this.inventory = new Inventory({})\n    this.tops = new Set()\n    this.linksIn = new Set(linksIn || [])\n\n    // these three are set by an Arborist taking a catalog\n    // after the tree is built.  We don't get this along the way,\n    // because they have a tendency to change as new children are\n    // added, especially when they're deduped.  Eg, a dev dep may be\n    // a 3-levels-deep dependency of a non-dev dep.  If we calc the\n    // flags along the way, then they'll tend to be invalid  by the\n    // time we need to look at them.\n    if (!dummy) {\n      this.dev = dev\n      this.optional = optional\n      this.devOptional = devOptional\n      this.peer = peer\n      this.extraneous = extraneous\n      this.dummy = false\n    } else {\n      // true if this is a placeholder for the purpose of serving as a\n      // fsParent to link targets that get their deps resolved outside\n      // the root tree folder.\n      this.dummy = true\n      this.dev = false\n      this.optional = false\n      this.devOptional = false\n      this.peer = false\n      this.extraneous = false\n    }\n\n    this.edgesIn = new Set()\n    this.edgesOut = new Map()\n\n    // have to set the internal package ref before assigning the parent,\n    // because this.package is read when adding to inventory\n    this[_package] = pkg && typeof pkg === 'object' ? pkg : {}\n\n    // only relevant for the root and top nodes\n    this.meta = meta\n\n    // Note: this is _slightly_ less efficient for the initial tree\n    // building than it could be, but in exchange, it's a much simpler\n    // algorithm.\n    // If this node has a bunch of children, and those children satisfy\n    // its various deps, then we're going to _first_ create all the\n    // edges, and _then_ assign the children into place, re-resolving\n    // them all in _reloadNamedEdges.\n    // A more efficient, but more complicated, approach would be to\n    // flag this node as being a part of a tree build, so it could\n    // hold off on resolving its deps until its children are in place.\n\n    // call the parent setter\n    // Must be set prior to calling _loadDeps, because top-ness is relevant\n\n    // will also assign root if present on the parent\n    this[_parent] = null\n    this.parent = parent || null\n\n    this[_fsParent] = null\n    this.fsParent = fsParent || null\n\n    // see parent/root setters below.\n    // root is set to parent's root if we have a parent, otherwise if it's\n    // null, then it's set to the node itself.\n    if (!parent && !fsParent)\n      this.root = root || null\n\n    // mostly a convenience for testing, but also a way to create\n    // trees in a more declarative way than setting parent on each\n    if (children) {\n      for (const c of children)\n        new Node({ ...c, parent: this })\n    }\n    if (fsChildren) {\n      for (const c of fsChildren)\n        new Node({ ...c, fsParent: this })\n    }\n\n    // now load all the dep edges\n    this[_loadDeps]()\n  }\n\n  get meta () {\n    return this[_meta]\n  }\n\n  set meta (meta) {\n    this[_meta] = meta\n    if (meta)\n      meta.add(this)\n  }\n\n  get global () {\n    return this.root[_global]\n  }\n\n  // true for packages installed directly in the global node_modules folder\n  get globalTop () {\n    return this.global && this.parent.isProjectRoot\n  }\n\n  get workspaces () {\n    return this[_workspaces]\n  }\n\n  set workspaces (workspaces) {\n    // deletes edges if they already exists\n    if (this[_workspaces]) {\n      for (const name of this[_workspaces].keys()) {\n        if (!workspaces.has(name))\n          this.edgesOut.get(name).detach()\n      }\n    }\n\n    this[_workspaces] = workspaces\n    this[_loadWorkspaces]()\n    this[_loadDeps]()\n  }\n\n  get binPaths () {\n    if (!this.parent)\n      return []\n\n    return getBinPaths({\n      pkg: this[_package],\n      path: this.path,\n      global: this.global,\n      top: this.globalTop,\n    })\n  }\n\n  get hasInstallScript () {\n    const {hasInstallScript, scripts} = this.package\n    const {install, preinstall, postinstall} = scripts || {}\n    return !!(hasInstallScript || install || preinstall || postinstall)\n  }\n\n  get version () {\n    return this[_package].version || ''\n  }\n\n  get packageName () {\n    return this[_package].name || null\n  }\n\n  get pkgid () {\n    const { name = '', version = '' } = this.package\n    // root package will prefer package name over folder name,\n    // and never be called an alias.\n    const { isProjectRoot } = this\n    const myname = isProjectRoot ? name || this.name\n      : this.name\n    const alias = !isProjectRoot && name && myname !== name ? `npm:${name}@`\n      : ''\n    return `${myname}@${alias}${version}`\n  }\n\n  get package () {\n    return this[_package]\n  }\n\n  set package (pkg) {\n    // just detach them all.  we could make this _slightly_ more efficient\n    // by only detaching the ones that changed, but we'd still have to walk\n    // them all, and the comparison logic gets a bit tricky.  we generally\n    // only do this more than once at the root level, so the resolve() calls\n    // are only one level deep, and there's not much to be saved, anyway.\n    // simpler to just toss them all out.\n    for (const edge of this.edgesOut.values())\n      edge.detach()\n\n    this[_explanation] = null\n    /* istanbul ignore next - should be impossible */\n    if (!pkg || typeof pkg !== 'object') {\n      debug(() => {\n        throw new Error('setting Node.package to non-object')\n      })\n      pkg = {}\n    }\n    this[_package] = pkg\n    this[_loadWorkspaces]()\n    this[_loadDeps]()\n    // do a hard reload, since the dependents may now be valid or invalid\n    // as a result of the package change.\n    this.edgesIn.forEach(edge => edge.reload(true))\n  }\n\n  // node.explain(nodes seen already, edge we're trying to satisfy\n  // if edge is not specified, it lists every edge into the node.\n  explain (edge = null, seen = []) {\n    if (this[_explanation])\n      return this[_explanation]\n\n    return this[_explanation] = this[_explain](edge, seen)\n  }\n\n  [_explain] (edge, seen) {\n    if (this.isProjectRoot && !this.sourceReference) {\n      return {\n        location: this.path,\n      }\n    }\n\n    const why = {\n      name: this.isProjectRoot || this.isTop ? this.packageName : this.name,\n      version: this.package.version,\n    }\n    if (this.errors.length || !this.packageName || !this.package.version) {\n      why.errors = this.errors.length ? this.errors : [\n        new Error('invalid package: lacks name and/or version'),\n      ]\n      why.package = this.package\n    }\n\n    if (this.root.sourceReference) {\n      const {name, version} = this.root.package\n      why.whileInstalling = {\n        name,\n        version,\n        path: this.root.sourceReference.path,\n      }\n    }\n\n    if (this.sourceReference)\n      return this.sourceReference.explain(edge, seen)\n\n    if (seen.includes(this))\n      return why\n\n    why.location = this.location\n    why.isWorkspace = this.isWorkspace\n\n    // make a new list each time.  we can revisit, but not loop.\n    seen = seen.concat(this)\n\n    why.dependents = []\n    if (edge)\n      why.dependents.push(edge.explain(seen))\n    else {\n      // ignore invalid edges, since those aren't satisfied by this thing,\n      // and are not keeping it held in this spot anyway.\n      const edges = []\n      for (const edge of this.edgesIn) {\n        if (!edge.valid && !edge.from.isProjectRoot)\n          continue\n\n        edges.push(edge)\n      }\n      for (const edge of edges)\n        why.dependents.push(edge.explain(seen))\n    }\n\n    if (this.linksIn.size)\n      why.linksIn = [...this.linksIn].map(link => link[_explain](edge, seen))\n\n    return why\n  }\n\n  isDescendantOf (node) {\n    for (let p = this; p; p = p.resolveParent) {\n      if (p === node)\n        return true\n    }\n    return false\n  }\n\n  getBundler (path = []) {\n    // made a cycle, definitely not bundled!\n    if (path.includes(this))\n      return null\n\n    path.push(this)\n\n    const parent = this[_parent]\n    if (!parent)\n      return null\n\n    const pBundler = parent.getBundler(path)\n    if (pBundler)\n      return pBundler\n\n    const ppkg = parent.package\n    const bd = ppkg && ppkg.bundleDependencies\n    // explicit bundling\n    if (Array.isArray(bd) && bd.includes(this.name))\n      return parent\n\n    // deps that are deduped up to the bundling level are bundled.\n    // however, if they get their dep met further up than that,\n    // then they are not bundled.  Ie, installing a package with\n    // unmet bundled deps will not cause your deps to be bundled.\n    for (const edge of this.edgesIn) {\n      const eBundler = edge.from.getBundler(path)\n      if (!eBundler)\n        continue\n\n      if (eBundler === parent)\n        return eBundler\n    }\n\n    return null\n  }\n\n  get inBundle () {\n    return !!this.getBundler()\n  }\n\n  // when reifying, if a package is technically in a bundleDependencies list,\n  // but that list is the root project, we still have to install it.  This\n  // getter returns true if it's in a dependency's bundle list, not the root's.\n  get inDepBundle () {\n    const bundler = this.getBundler()\n    return !!bundler && bundler !== this.root\n  }\n\n  get isWorkspace () {\n    if (this.isProjectRoot)\n      return false\n    const { root } = this\n    const { type, to } = root.edgesOut.get(this.packageName) || {}\n    return type === 'workspace' && to && (to.target === this || to === this)\n  }\n\n  get isRoot () {\n    return this === this.root\n  }\n\n  get isProjectRoot () {\n    return this === this.root || this === this.root.target\n  }\n\n  set root (root) {\n    // setting to null means this is the new root\n    // should only ever be one step\n    while (root && root.root !== root)\n      root = root.root\n\n    root = root || this\n\n    // delete from current root inventory\n    this[_delistFromMeta]()\n\n    // can't set the root (yet) if there's no way to determine location\n    // this allows us to do new Node({...}) and then set the root later.\n    // just make the assignment so we don't lose it, and move on.\n    if (!this.path || !root.realpath || !root.path)\n      return this[_root] = root\n\n    // temporarily become a root node\n    this[_root] = this\n\n    // break all linksIn, we're going to re-set them if needed later\n    for (const link of this.linksIn) {\n      link[_target] = null\n      this.linksIn.delete(link)\n    }\n\n    // temporarily break this link as well, we'll re-set if possible later\n    const { target } = this\n    if (this.isLink) {\n      if (target) {\n        target.linksIn.delete(this)\n        if (target.root === this)\n          target[_delistFromMeta]()\n      }\n      this[_target] = null\n    }\n\n    // if this is part of a cascading root set, then don't do this bit\n    // but if the parent/fsParent is in a different set, we have to break\n    // that reference before proceeding\n    if (this.parent && this.parent.root !== root) {\n      this.parent.children.delete(this.name)\n      this[_parent] = null\n    }\n    if (this.fsParent && this.fsParent.root !== root) {\n      this.fsParent.fsChildren.delete(this)\n      this[_fsParent] = null\n    }\n\n    if (root === this)\n      this[_refreshLocation]()\n    else {\n      // setting to some different node.\n      const loc = relpath(root.realpath, this.path)\n      const current = root.inventory.get(loc)\n\n      // clobber whatever is there now\n      if (current)\n        current.root = null\n\n      this[_root] = root\n      // set this.location and add to inventory\n      this[_refreshLocation]()\n\n      // try to find our parent/fsParent in the new root inventory\n      for (const p of walkUp(dirname(this.path))) {\n        if (p === this.path)\n          continue\n        const ploc = relpath(root.realpath, p)\n        const parent = root.inventory.get(ploc)\n        if (parent) {\n          /* istanbul ignore next - impossible */\n          if (parent.isLink) {\n            debug(() => {\n              throw Object.assign(new Error('assigning parentage to link'), {\n                path: this.path,\n                parent: parent.path,\n                parentReal: parent.realpath,\n              })\n            })\n            continue\n          }\n          const childLoc = `${ploc}${ploc ? '/' : ''}node_modules/${this.name}`\n          const isParent = this.location === childLoc\n          if (isParent) {\n            const oldChild = parent.children.get(this.name)\n            if (oldChild && oldChild !== this)\n              oldChild.root = null\n            if (this.parent) {\n              this.parent.children.delete(this.name)\n              this.parent[_reloadNamedEdges](this.name)\n            }\n            parent.children.set(this.name, this)\n            this[_parent] = parent\n            // don't do it for links, because they don't have a target yet\n            // we'll hit them up a bit later on.\n            if (!this.isLink)\n              parent[_reloadNamedEdges](this.name)\n          } else {\n            /* istanbul ignore if - should be impossible, since we break\n             * all fsParent/child relationships when moving? */\n            if (this.fsParent)\n              this.fsParent.fsChildren.delete(this)\n            parent.fsChildren.add(this)\n            this[_fsParent] = parent\n          }\n          break\n        }\n      }\n\n      // if it doesn't have a parent, it's a top node\n      if (!this.parent)\n        root.tops.add(this)\n      else\n        root.tops.delete(this)\n\n      // assign parentage for any nodes that need to have this as a parent\n      // this can happen when we have a node at nm/a/nm/b added *before*\n      // the node at nm/a, which might have the root node as a fsParent.\n      // we can't rely on the public setter here, because it calls into\n      // this function to set up these references!\n      const nmloc = `${this.location}${this.location ? '/' : ''}node_modules/`\n      const isChild = n => n.location === nmloc + n.name\n      // check dirname so that /foo isn't treated as the fsparent of /foo-bar\n      const isFsChild = n => dirname(n.path).startsWith(this.path) &&\n        n !== this &&\n        !n.parent &&\n        (!n.fsParent || n.fsParent === this || dirname(this.path).startsWith(n.fsParent.path))\n      const isKid = n => isChild(n) || isFsChild(n)\n\n      // only walk top nodes, since anything else already has a parent.\n      for (const child of root.tops) {\n        if (!isKid(child))\n          continue\n\n        // set up the internal parentage links\n        if (this.isLink)\n          child.root = null\n        else {\n          // can't possibly have a parent, because it's in tops\n          if (child.fsParent)\n            child.fsParent.fsChildren.delete(child)\n          child[_fsParent] = null\n          if (isChild(child)) {\n            this.children.set(child.name, child)\n            child[_parent] = this\n            root.tops.delete(child)\n          } else {\n            this.fsChildren.add(child)\n            child[_fsParent] = this\n          }\n        }\n      }\n\n      // look for any nodes with the same realpath.  either they're links\n      // to that realpath, or a thing at that realpath if we're adding a link\n      // (if we're adding a regular node, we already deleted the old one)\n      for (const node of root.inventory.query('realpath', this.realpath)) {\n        if (node === this)\n          continue\n\n        /* istanbul ignore next - should be impossible */\n        debug(() => {\n          if (node.root !== root)\n            throw new Error('inventory contains node from other root')\n        })\n\n        if (this.isLink) {\n          const target = node.target\n          this[_target] = target\n          this[_package] = target.package\n          target.linksIn.add(this)\n          // reload edges here, because now we have a target\n          if (this.parent)\n            this.parent[_reloadNamedEdges](this.name)\n          break\n        } else {\n          /* istanbul ignore else - should be impossible */\n          if (node.isLink) {\n            node[_target] = this\n            node[_package] = this.package\n            this.linksIn.add(node)\n            if (node.parent)\n              node.parent[_reloadNamedEdges](node.name)\n          } else {\n            debug(() => {\n              throw Object.assign(new Error('duplicate node in root setter'), {\n                path: this.path,\n                realpath: this.realpath,\n                root: root.realpath,\n              })\n            })\n          }\n        }\n      }\n    }\n\n    // reload all edgesIn where the root doesn't match, so we don't have\n    // cross-tree dependency graphs\n    for (const edge of this.edgesIn) {\n      if (edge.from.root !== root)\n        edge.reload()\n    }\n    // reload all edgesOut where root doens't match, or is missing, since\n    // it might not be missing in the new tree\n    for (const edge of this.edgesOut.values()) {\n      if (!edge.to || edge.to.root !== root)\n        edge.reload()\n    }\n\n    // now make sure our family comes along for the ride!\n    const family = new Set([\n      ...this.fsChildren,\n      ...this.children.values(),\n      ...this.inventory.values(),\n    ].filter(n => n !== this))\n\n    for (const child of family) {\n      if (child.root !== root) {\n        child[_delistFromMeta]()\n        child[_parent] = null\n        this.children.delete(child.name)\n        child[_fsParent] = null\n        this.fsChildren.delete(child)\n        for (const l of child.linksIn) {\n          l[_target] = null\n          child.linksIn.delete(l)\n        }\n      }\n    }\n    for (const child of family) {\n      if (child.root !== root)\n        child.root = root\n    }\n\n    // if we had a target, and didn't find one in the new root, then bring\n    // it over as well, but only if we're setting the link into a new root,\n    // as we don't want to lose the target any time we remove a link.\n    if (this.isLink && target && !this.target && root !== this)\n      target.root = root\n\n    // tree should always be valid upon root setter completion.\n    treeCheck(this)\n    treeCheck(root)\n  }\n\n  get root () {\n    return this[_root] || this\n  }\n\n  [_loadWorkspaces] () {\n    if (!this[_workspaces])\n      return\n\n    for (const [name, path] of this[_workspaces].entries())\n      new Edge({ from: this, name, spec: `file:${path}`, type: 'workspace' })\n  }\n\n  [_loadDeps] () {\n    // Caveat!  Order is relevant!\n    // Packages in optionalDependencies are optional.\n    // Packages in both deps and devDeps are required.\n    // Note the subtle breaking change from v6: it is no longer possible\n    // to have a different spec for a devDep than production dep.\n\n    // Linked targets that are disconnected from the tree are tops,\n    // but don't have a 'path' field, only a 'realpath', because we\n    // don't know their canonical location. We don't need their devDeps.\n    const pd = this.package.peerDependencies\n    if (pd && typeof pd === 'object' && !this.legacyPeerDeps) {\n      const pm = this.package.peerDependenciesMeta || {}\n      const peerDependencies = {}\n      const peerOptional = {}\n      for (const [name, dep] of Object.entries(pd)) {\n        if (pm[name] && pm[name].optional)\n          peerOptional[name] = dep\n        else\n          peerDependencies[name] = dep\n      }\n      this[_loadDepType](peerDependencies, 'peer')\n      this[_loadDepType](peerOptional, 'peerOptional')\n    }\n\n    this[_loadDepType](this.package.dependencies, 'prod')\n    this[_loadDepType](this.package.optionalDependencies, 'optional')\n\n    const { isTop, path, sourceReference } = this\n    const { isTop: srcTop, path: srcPath } = sourceReference || {}\n    if (isTop && path && (!sourceReference || srcTop && srcPath))\n      this[_loadDepType](this.package.devDependencies, 'dev')\n  }\n\n  [_loadDepType] (deps, type) {\n    const ad = this.package.acceptDependencies || {}\n    // Because of the order in which _loadDeps runs, we always want to\n    // prioritize a new edge over an existing one\n    for (const [name, spec] of Object.entries(deps || {})) {\n      const current = this.edgesOut.get(name)\n      if (!current || current.type !== 'workspace')\n        new Edge({ from: this, name, spec, accept: ad[name], type })\n    }\n  }\n\n  get fsParent () {\n    const parent = this[_fsParent]\n    /* istanbul ignore next - should be impossible */\n    debug(() => {\n      if (parent === this)\n        throw new Error('node set to its own fsParent')\n    })\n    return parent\n  }\n\n  set fsParent (fsParent) {\n    if (!fsParent) {\n      if (this[_fsParent])\n        this.root = null\n      return\n    }\n\n    debug(() => {\n      if (fsParent === this)\n        throw new Error('setting node to its own fsParent')\n\n      if (fsParent.realpath === this.realpath)\n        throw new Error('setting fsParent to same path')\n\n      // the initial set MUST be an actual walk-up from the realpath\n      // subsequent sets will re-root on the new fsParent's path.\n      if (!this[_fsParent] && this.realpath.indexOf(fsParent.realpath) !== 0) {\n        throw Object.assign(new Error('setting fsParent improperly'), {\n          path: this.path,\n          realpath: this.realpath,\n          fsParent: {\n            path: fsParent.path,\n            realpath: fsParent.realpath,\n          },\n        })\n      }\n    })\n\n    if (fsParent.isLink)\n      fsParent = fsParent.target\n\n    // setting a thing to its own fsParent is not normal, but no-op for safety\n    if (this === fsParent || fsParent.realpath === this.realpath)\n      return\n\n    // nothing to do\n    if (this[_fsParent] === fsParent)\n      return\n\n    const oldFsParent = this[_fsParent]\n    const newPath = !oldFsParent ? this.path\n      : resolve(fsParent.path, relative(oldFsParent.path, this.path))\n    const nmPath = resolve(fsParent.path, 'node_modules', this.name)\n\n    // this is actually the parent, set that instead\n    if (newPath === nmPath) {\n      this.parent = fsParent\n      return\n    }\n\n    const pathChange = newPath !== this.path\n\n    // remove from old parent/fsParent\n    const oldParent = this.parent\n    const oldName = this.name\n    if (this.parent) {\n      this.parent.children.delete(this.name)\n      this[_parent] = null\n    }\n    if (this.fsParent) {\n      this.fsParent.fsChildren.delete(this)\n      this[_fsParent] = null\n    }\n\n    // update this.path/realpath for this and all children/fsChildren\n    if (pathChange)\n      this[_changePath](newPath)\n\n    if (oldParent)\n      oldParent[_reloadNamedEdges](oldName)\n\n    // clobbers anything at that path, resets all appropriate references\n    this.root = fsParent.root\n  }\n\n  // is it safe to replace one node with another?  check the edges to\n  // make sure no one will get upset.  Note that the node might end up\n  // having its own unmet dependencies, if the new node has new deps.\n  // Note that there are cases where Arborist will opt to insert a node\n  // into the tree even though this function returns false!  This is\n  // necessary when a root dependency is added or updated, or when a\n  // root dependency brings peer deps along with it.  In that case, we\n  // will go ahead and create the invalid state, and then try to resolve\n  // it with more tree construction, because it's a user request.\n  canReplaceWith (node) {\n    if (node.name !== this.name)\n      return false\n\n    // gather up all the deps of this node and that are only depended\n    // upon by deps of this node.  those ones don't count, since\n    // they'll be replaced if this node is replaced anyway.\n    const depSet = gatherDepSet([this], e => e.to !== this && e.valid)\n\n    for (const edge of this.edgesIn) {\n      // only care about edges that don't originate from this node\n      if (!depSet.has(edge.from) && !edge.satisfiedBy(node))\n        return false\n    }\n\n    return true\n  }\n\n  canReplace (node) {\n    return node.canReplaceWith(this)\n  }\n\n  // return true if it's safe to remove this node, because anything that\n  // is depending on it would be fine with the thing that they would resolve\n  // to if it was removed, or nothing is depending on it in the first place.\n  canDedupe (preferDedupe = false) {\n    // not allowed to mess with shrinkwraps or bundles\n    if (this.inDepBundle || this.inShrinkwrap)\n      return false\n\n    // it's a top level pkg, or a dep of one\n    if (!this.resolveParent || !this.resolveParent.resolveParent)\n      return false\n\n    // no one wants it, remove it\n    if (this.edgesIn.size === 0)\n      return true\n\n    const other = this.resolveParent.resolveParent.resolve(this.name)\n\n    // nothing else, need this one\n    if (!other)\n      return false\n\n    // if it's the same thing, then always fine to remove\n    if (other.matches(this))\n      return true\n\n    // if the other thing can't replace this, then skip it\n    if (!other.canReplace(this))\n      return false\n\n    // if we prefer dedupe, or if the version is greater/equal, take the other\n    if (preferDedupe || semver.gte(other.version, this.version))\n      return true\n\n    return false\n  }\n\n  satisfies (requested) {\n    if (requested instanceof Edge)\n      return this.name === requested.name && requested.satisfiedBy(this)\n\n    const parsed = npa(requested)\n    const { name = this.name, rawSpec: spec } = parsed\n    return this.name === name && this.satisfies(new Edge({\n      from: new Node({ path: this.root.realpath }),\n      type: 'prod',\n      name,\n      spec,\n    }))\n  }\n\n  matches (node) {\n    // if the nodes are literally the same object, obviously a match.\n    if (node === this)\n      return true\n\n    // if the names don't match, they're different things, even if\n    // the package contents are identical.\n    if (node.name !== this.name)\n      return false\n\n    // if they're links, they match if the targets match\n    if (this.isLink)\n      return node.isLink && this.target.matches(node.target)\n\n    // if they're two project root nodes, they're different if the paths differ\n    if (this.isProjectRoot && node.isProjectRoot)\n      return this.path === node.path\n\n    // if the integrity matches, then they're the same.\n    if (this.integrity && node.integrity)\n      return this.integrity === node.integrity\n\n    // if no integrity, check resolved\n    if (this.resolved && node.resolved)\n      return this.resolved === node.resolved\n\n    // if no resolved, check both package name and version\n    // otherwise, conclude that they are different things\n    return this.packageName && node.packageName &&\n      this.packageName === node.packageName &&\n      this.version && node.version &&\n      this.version === node.version\n  }\n\n  // replace this node with the supplied argument\n  // Useful when mutating an ideal tree, so we can avoid having to call\n  // the parent/root setters more than necessary.\n  replaceWith (node) {\n    node.replace(this)\n  }\n\n  replace (node) {\n    this[_delistFromMeta]()\n    this.path = node.path\n    this.name = node.name\n    if (!this.isLink)\n      this.realpath = this.path\n    this[_refreshLocation]()\n\n    // keep children when a node replaces another\n    if (!this.isLink) {\n      for (const kid of node.children.values())\n        kid.parent = this\n    }\n\n    if (!node.isRoot)\n      this.root = node.root\n\n    treeCheck(this)\n  }\n\n  get inShrinkwrap () {\n    return this.parent && (this.parent.hasShrinkwrap || this.parent.inShrinkwrap)\n  }\n\n  get parent () {\n    const parent = this[_parent]\n    /* istanbul ignore next - should be impossible */\n    debug(() => {\n      if (parent === this)\n        throw new Error('node set to its own parent')\n    })\n    return parent\n  }\n\n  // This setter keeps everything in order when we move a node from\n  // one point in a logical tree to another.  Edges get reloaded,\n  // metadata updated, etc.  It's also called when we *replace* a node\n  // with another by the same name (eg, to update or dedupe).\n  // This does a couple of walks out on the node_modules tree, recursing\n  // into child nodes.  However, as setting the parent is typically done\n  // with nodes that don't have have many children, and (deduped) package\n  // trees tend to be broad rather than deep, it's not that bad.\n  // The only walk that starts from the parent rather than this node is\n  // limited by edge name.\n  set parent (parent) {\n    // when setting to null, just remove it from the tree entirely\n    if (!parent) {\n      // but only delete it if we actually had a parent in the first place\n      // otherwise it's just setting to null when it's already null\n      if (this[_parent])\n        this.root = null\n      return\n    }\n\n    if (parent.isLink)\n      parent = parent.target\n\n    // setting a thing to its own parent is not normal, but no-op for safety\n    if (this === parent)\n      return\n\n    const oldParent = this[_parent]\n\n    // nothing to do\n    if (oldParent === parent)\n      return\n\n    // ok now we know something is actually changing, and parent is not a link\n    const newPath = resolve(parent.path, 'node_modules', this.name)\n    const pathChange = newPath !== this.path\n\n    // remove from old parent/fsParent\n    if (oldParent) {\n      oldParent.children.delete(this.name)\n      this[_parent] = null\n    }\n    if (this.fsParent) {\n      this.fsParent.fsChildren.delete(this)\n      this[_fsParent] = null\n    }\n\n    // update this.path/realpath for this and all children/fsChildren\n    if (pathChange)\n      this[_changePath](newPath)\n\n    // clobbers anything at that path, resets all appropriate references\n    this.root = parent.root\n  }\n\n  // Call this before changing path or updating the _root reference.\n  // Removes the node from its root the metadata and inventory.\n  [_delistFromMeta] () {\n    const root = this.root\n    if (!root.realpath || !this.path)\n      return\n    root.inventory.delete(this)\n    root.tops.delete(this)\n    if (root.meta)\n      root.meta.delete(this.path)\n    /* istanbul ignore next - should be impossible */\n    debug(() => {\n      if ([...root.inventory.values()].includes(this))\n        throw new Error('failed to delist')\n    })\n  }\n\n  // update this.path/realpath and the paths of all children/fsChildren\n  [_changePath] (newPath) {\n    // have to de-list before changing paths\n    this[_delistFromMeta]()\n    const oldPath = this.path\n    this.path = newPath\n    const namePattern = /(?:^|\\/|\\\\)node_modules[\\\\/](@[^/\\\\]+[\\\\/][^\\\\/]+|[^\\\\/]+)$/\n    const nameChange = newPath.match(namePattern)\n    if (nameChange && this.name !== nameChange[1])\n      this.name = nameChange[1].replace(/\\\\/g, '/')\n\n    // if we move a link target, update link realpaths\n    if (!this.isLink) {\n      this.realpath = newPath\n      for (const link of this.linksIn) {\n        link[_delistFromMeta]()\n        link.realpath = newPath\n        link[_refreshLocation]()\n      }\n    }\n    // if we move /x to /y, then a module at /x/a/b becomes /y/a/b\n    for (const child of this.fsChildren)\n      child[_changePath](resolve(newPath, relative(oldPath, child.path)))\n    for (const [name, child] of this.children.entries())\n      child[_changePath](resolve(newPath, 'node_modules', name))\n\n    this[_refreshLocation]()\n  }\n\n  // Called whenever the root/parent is changed.\n  // NB: need to remove from former root's meta/inventory and then update\n  // this.path BEFORE calling this method!\n  [_refreshLocation] () {\n    const root = this.root\n    const loc = relpath(root.realpath, this.path)\n\n    this.location = loc\n\n    root.inventory.add(this)\n    if (root.meta)\n      root.meta.add(this)\n  }\n\n  addEdgeOut (edge) {\n    this.edgesOut.set(edge.name, edge)\n  }\n\n  addEdgeIn (edge) {\n    this.edgesIn.add(edge)\n\n    // try to get metadata from the yarn.lock file\n    if (this.root.meta)\n      this.root.meta.addEdge(edge)\n  }\n\n  [_reloadNamedEdges] (name, rootLoc = this.location) {\n    const edge = this.edgesOut.get(name)\n    // if we don't have an edge, do nothing, but keep descending\n    const rootLocResolved = edge && edge.to &&\n      edge.to.location === `${rootLoc}/node_modules/${edge.name}`\n    const sameResolved = edge && this.resolve(name) === edge.to\n    const recheck = rootLocResolved || !sameResolved\n    if (edge && recheck)\n      edge.reload(true)\n    for (const c of this.children.values())\n      c[_reloadNamedEdges](name, rootLoc)\n\n    for (const c of this.fsChildren)\n      c[_reloadNamedEdges](name, rootLoc)\n  }\n\n  get isLink () {\n    return false\n  }\n\n  get target () {\n    return this\n  }\n\n  set target (n) {\n    debug(() => {\n      throw Object.assign(new Error('cannot set target on non-Link Nodes'), {\n        path: this.path,\n      })\n    })\n  }\n\n  get depth () {\n    return this.isTop ? 0 : this.parent.depth + 1\n  }\n\n  get isTop () {\n    return !this.parent\n  }\n\n  get top () {\n    return this.isTop ? this : this.parent.top\n  }\n\n  get isFsTop () {\n    return !this.fsParent\n  }\n\n  get fsTop () {\n    return this.isFsTop ? this : this.fsParent.fsTop\n  }\n\n  get resolveParent () {\n    return this.parent || this.fsParent\n  }\n\n  resolve (name) {\n    const mine = this.children.get(name)\n    if (mine)\n      return mine\n    const resolveParent = this.resolveParent\n    if (resolveParent)\n      return resolveParent.resolve(name)\n    return null\n  }\n\n  inNodeModules () {\n    const rp = this.realpath\n    const name = this.name\n    const scoped = name.charAt(0) === '@'\n    const d = dirname(rp)\n    const nm = scoped ? dirname(d) : d\n    const dir = dirname(nm)\n    const base = scoped ? `${basename(d)}/${basename(rp)}` : basename(rp)\n    return base === name && basename(nm) === 'node_modules' ? dir : false\n  }\n\n  toJSON () {\n    return printableTree(this)\n  }\n\n  [util.inspect.custom] () {\n    return this.toJSON()\n  }\n}\n\nmodule.exports = Node\n"]},"metadata":{},"sourceType":"script"}